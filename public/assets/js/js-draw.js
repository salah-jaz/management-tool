/**
 * Skipped minification because the original files appears to be already minified.
 * Original file: /npm/js-draw@1.24.2/dist/bundle.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
(() => {
    var e = {
        9724: (t, e, o) => { "use strict"; o.d(e, { A: () => a }); var n = o(6758), i = o.n(n), r = o(935), s = o.n(r)()(i()); s.push([t.id, '.clr-picker {\n  display: none;\n  flex-wrap: wrap;\n  position: absolute;\n  width: 200px;\n  z-index: 1000;\n  border-radius: 10px;\n  background-color: #fff;\n  justify-content: flex-end;\n  direction: ltr;\n  box-shadow: 0 0 5px rgba(0,0,0,.05), 0 5px 20px rgba(0,0,0,.1);\n  -moz-user-select: none;\n  -webkit-user-select: none;\n  user-select: none;\n}\n\n.clr-picker.clr-open,\n.clr-picker[data-inline="true"] {\n  display: flex;\n}\n\n.clr-picker[data-inline="true"] {\n  position: relative;\n}\n\n.clr-gradient {\n  position: relative;\n  width: 100%;\n  height: 100px;\n  margin-bottom: 15px;\n  border-radius: 3px 3px 0 0;\n  background-image: linear-gradient(rgba(0,0,0,0), #000), linear-gradient(90deg, #fff, currentColor);\n  cursor: pointer;\n}\n\n.clr-marker {\n  position: absolute;\n  width: 12px;\n  height: 12px;\n  margin: -6px 0 0 -6px;\n  border: 1px solid #fff;\n  border-radius: 50%;\n  background-color: currentColor;\n  cursor: pointer;\n}\n\n.clr-picker input[type="range"]::-webkit-slider-runnable-track {\n  width: 100%;\n  height: 16px;\n}\n\n.clr-picker input[type="range"]::-webkit-slider-thumb {\n  width: 16px;\n  height: 16px;\n  -webkit-appearance: none;\n}\n\n.clr-picker input[type="range"]::-moz-range-track {\n  width: 100%;\n  height: 16px;\n  border: 0;\n}\n\n.clr-picker input[type="range"]::-moz-range-thumb {\n  width: 16px;\n  height: 16px;\n  border: 0;\n}\n\n.clr-hue {\n  background-image: linear-gradient(to right, #f00 0%, #ff0 16.66%, #0f0 33.33%, #0ff 50%, #00f 66.66%, #f0f 83.33%, #f00 100%);\n}\n\n.clr-hue,\n.clr-alpha {\n  position: relative;\n  width: calc(100% - 40px);\n  height: 8px;\n  margin: 5px 20px;\n  border-radius: 4px;\n}\n\n.clr-alpha span {\n  display: block;\n  height: 100%;\n  width: 100%;\n  border-radius: inherit;\n  background-image: linear-gradient(90deg, rgba(0,0,0,0), currentColor);\n}\n\n.clr-hue input,\n.clr-alpha input {\n  position: absolute;\n  width: calc(100% + 32px);\n  height: 16px;\n  left: -16px;\n  top: -4px;\n  margin: 0;\n  background-color: transparent;\n  opacity: 0;\n  cursor: pointer;\n  appearance: none;\n  -webkit-appearance: none;\n}\n\n.clr-hue div,\n.clr-alpha div {\n  position: absolute;\n  width: 16px;\n  height: 16px;\n  left: 0;\n  top: 50%;\n  margin-left: -8px;\n  transform: translateY(-50%);\n  border: 2px solid #fff;\n  border-radius: 50%;\n  background-color: currentColor;\n  box-shadow: 0 0 1px #888;\n  pointer-events: none;\n}\n\n.clr-alpha div:before {\n  content: \'\';\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  left: 0;\n  top: 0;\n  border-radius: 50%;\n  background-color: currentColor;\n}\n\n.clr-format {\n  display: none;\n  order: 1;\n  width: calc(100% - 40px);\n  margin: 0 20px 20px;\n}\n\n.clr-segmented {\n  display: flex;\n  position: relative;\n  width: 100%;\n  margin: 0;\n  padding: 0;\n  border: 1px solid #ddd;\n  border-radius: 15px;\n  box-sizing: border-box;\n  color: #999;\n  font-size: 12px;\n}\n\n.clr-segmented input,\n.clr-segmented legend {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  border: 0;\n  left: 0;\n  top: 0;\n  opacity: 0;\n  pointer-events: none;\n}\n\n.clr-segmented label {\n  flex-grow: 1;\n  margin: 0;\n  padding: 4px 0;\n  font-size: inherit;\n  font-weight: normal;\n  line-height: initial;\n  text-align: center;\n  cursor: pointer;\n}\n\n.clr-segmented label:first-of-type {\n  border-radius: 10px 0 0 10px;\n}\n\n.clr-segmented label:last-of-type {\n  border-radius: 0 10px 10px 0;\n}\n\n.clr-segmented input:checked + label {\n  color: #fff;\n  background-color: #666;\n}\n\n.clr-swatches {\n  order: 2;\n  width: calc(100% - 32px);\n  margin: 0 16px;\n}\n\n.clr-swatches div {\n  display: flex;\n  flex-wrap: wrap;\n  padding-bottom: 12px;\n  justify-content: center;\n}\n\n.clr-swatches button {\n  position: relative;\n  width: 20px;\n  height: 20px;\n  margin: 0 4px 6px 4px;\n  padding: 0;\n  border: 0;\n  border-radius: 50%;\n  color: inherit;\n  text-indent: -1000px;\n  white-space: nowrap;\n  overflow: hidden;\n  cursor: pointer;\n}\n\n.clr-swatches button:after {\n  content: \'\';\n  display: block;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n  border-radius: inherit;\n  background-color: currentColor;\n  box-shadow: inset 0 0 0 1px rgba(0,0,0,.1);\n}\n\ninput.clr-color {\n  order: 1;\n  width: calc(100% - 80px);\n  height: 32px;\n  margin: 15px 20px 20px auto;\n  padding: 0 10px;\n  border: 1px solid #ddd;\n  border-radius: 16px;\n  color: #444;\n  background-color: #fff;\n  font-family: sans-serif;\n  font-size: 14px;\n  text-align: center;\n  box-shadow: none;\n}\n\ninput.clr-color:focus {\n  outline: none;\n  border: 1px solid #1e90ff;\n}\n\n.clr-close,\n.clr-clear {\n  display: none;\n  order: 2;\n  height: 24px;\n  margin: 0 20px 20px;\n  padding: 0 20px;\n  border: 0;\n  border-radius: 12px;\n  color: #fff;\n  background-color: #666;\n  font-family: inherit;\n  font-size: 12px;\n  font-weight: 400;\n  cursor: pointer;\n}\n\n.clr-close {\n  display: block;\n  margin: 0 20px 20px auto;\n}\n\n.clr-preview {\n  position: relative;\n  width: 32px;\n  height: 32px;\n  margin: 15px 0 20px 20px;\n  border-radius: 50%;\n  overflow: hidden;\n}\n\n.clr-preview:before,\n.clr-preview:after {\n  content: \'\';\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  left: 0;\n  top: 0;\n  border: 1px solid #fff;\n  border-radius: 50%;\n}\n\n.clr-preview:after {\n  border: 0;\n  background-color: currentColor;\n  box-shadow: inset 0 0 0 1px rgba(0,0,0,.1);\n}\n\n.clr-preview button {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  z-index: 1;\n  margin: 0;\n  padding: 0;\n  border: 0;\n  border-radius: 50%;\n  outline-offset: -2px;\n  background-color: transparent;\n  text-indent: -9999px;\n  cursor: pointer;\n  overflow: hidden;\n}\n\n.clr-marker,\n.clr-hue div,\n.clr-alpha div,\n.clr-color {\n  box-sizing: border-box;\n}\n\n.clr-field {\n  display: inline-block;\n  position: relative;\n  color: transparent;\n}\n\n.clr-field input {\n  margin: 0;\n  direction: ltr;\n}\n\n.clr-field.clr-rtl input {\n  text-align: right;\n}\n\n.clr-field button {\n  position: absolute;\n  width: 30px;\n  height: 100%;\n  right: 0;\n  top: 50%;\n  transform: translateY(-50%);\n  margin: 0;\n  padding: 0;\n  border: 0;\n  color: inherit;\n  text-indent: -1000px;\n  white-space: nowrap;\n  overflow: hidden;\n  pointer-events: none;\n}\n\n.clr-field.clr-rtl button {\n  right: auto;\n  left: 0;\n}\n\n.clr-field button:after {\n  content: \'\';\n  display: block;\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0;\n  top: 0;\n  border-radius: inherit;\n  background-color: currentColor;\n  box-shadow: inset 0 0 1px rgba(0,0,0,.5);\n}\n\n.clr-alpha,\n.clr-alpha div,\n.clr-swatches button,\n.clr-preview:before,\n.clr-field button {\n  background-image: repeating-linear-gradient(45deg, #aaa 25%, transparent 25%, transparent 75%, #aaa 75%, #aaa), repeating-linear-gradient(45deg, #aaa 25%, #fff 25%, #fff 75%, #aaa 75%, #aaa);\n  background-position: 0 0, 4px 4px;\n  background-size: 8px 8px;\n}\n\n.clr-marker:focus {\n  outline: none;\n}\n\n.clr-keyboard-nav .clr-marker:focus,\n.clr-keyboard-nav .clr-hue input:focus + div,\n.clr-keyboard-nav .clr-alpha input:focus + div,\n.clr-keyboard-nav .clr-segmented input:focus + label {\n  outline: none;\n  box-shadow: 0 0 0 2px #1e90ff, 0 0 2px 2px #fff;\n}\n\n.clr-picker[data-alpha="false"] .clr-alpha {\n  display: none;\n}\n\n.clr-picker[data-minimal="true"] {\n  padding-top: 16px;\n}\n\n.clr-picker[data-minimal="true"] .clr-gradient,\n.clr-picker[data-minimal="true"] .clr-hue,\n.clr-picker[data-minimal="true"] .clr-alpha,\n.clr-picker[data-minimal="true"] .clr-color,\n.clr-picker[data-minimal="true"] .clr-preview {\n  display: none;\n}\n\n/** Dark theme **/\n\n.clr-dark {\n  background-color: #444;\n}\n\n.clr-dark .clr-segmented {\n  border-color: #777;\n}\n\n.clr-dark .clr-swatches button:after {\n  box-shadow: inset 0 0 0 1px rgba(255,255,255,.3);\n}\n\n.clr-dark input.clr-color {\n  color: #fff;\n  border-color: #777;\n  background-color: #555;\n}\n\n.clr-dark input.clr-color:focus {\n  border-color: #1e90ff;\n}\n\n.clr-dark .clr-preview:after {\n  box-shadow: inset 0 0 0 1px rgba(255,255,255,.5);\n}\n\n.clr-dark .clr-alpha,\n.clr-dark .clr-alpha div,\n.clr-dark .clr-swatches button,\n.clr-dark .clr-preview:before {\n  background-image: repeating-linear-gradient(45deg, #666 25%, transparent 25%, transparent 75%, #888 75%, #888), repeating-linear-gradient(45deg, #888 25%, #444 25%, #444 75%, #888 75%, #888);\n}\n\n/** Polaroid theme **/\n\n.clr-picker.clr-polaroid {\n  border-radius: 6px;\n  box-shadow: 0 0 5px rgba(0,0,0,.1), 0 5px 30px rgba(0,0,0,.2);\n}\n\n.clr-picker.clr-polaroid:before {\n  content: \'\';\n  display: block;\n  position: absolute;\n  width: 16px;\n  height: 10px;\n  left: 20px;\n  top: -10px;\n  border: solid transparent;\n  border-width: 0 8px 10px 8px;\n  border-bottom-color: currentColor;\n  box-sizing: border-box;\n  color: #fff;\n  filter: drop-shadow(0 -4px 3px rgba(0,0,0,.1));\n  pointer-events: none;\n}\n\n.clr-picker.clr-polaroid.clr-dark:before {\n  color: #444;\n}\n\n.clr-picker.clr-polaroid.clr-left:before {\n  left: auto;\n  right: 20px;\n}\n\n.clr-picker.clr-polaroid.clr-top:before {\n  top: auto;\n  bottom: -10px;\n  transform: rotateZ(180deg);\n}\n\n.clr-polaroid .clr-gradient {\n  width: calc(100% - 20px);\n  height: 120px;\n  margin: 10px;\n  border-radius: 3px;\n}\n\n.clr-polaroid .clr-hue,\n.clr-polaroid .clr-alpha {\n  width: calc(100% - 30px);\n  height: 10px;\n  margin: 6px 15px;\n  border-radius: 5px;\n}\n\n.clr-polaroid .clr-hue div,\n.clr-polaroid .clr-alpha div {\n  box-shadow: 0 0 5px rgba(0,0,0,.2);\n}\n\n.clr-polaroid .clr-format {\n  width: calc(100% - 20px);\n  margin: 0 10px 15px;\n}\n\n.clr-polaroid .clr-swatches {\n  width: calc(100% - 12px);\n  margin: 0 6px;\n}\n.clr-polaroid .clr-swatches div {\n  padding-bottom: 10px;\n}\n\n.clr-polaroid .clr-swatches button {\n  width: 22px;\n  height: 22px;\n}\n\n.clr-polaroid input.clr-color {\n  width: calc(100% - 60px);\n  margin: 10px 10px 15px auto;\n}\n\n.clr-polaroid .clr-clear {\n  margin: 0 10px 15px 10px;\n}\n\n.clr-polaroid .clr-close {\n  margin: 0 10px 15px auto;\n}\n\n.clr-polaroid .clr-preview {\n  margin: 10px 0 15px 10px;\n}\n\n/** Large theme **/\n\n.clr-picker.clr-large {\n  width: 275px;\n}\n\n.clr-large .clr-gradient {\n  height: 150px;\n}\n\n.clr-large .clr-swatches button {\n  width: 22px;\n  height: 22px;\n}\n\n/** Pill (horizontal) theme **/\n\n.clr-picker.clr-pill {\n  width: 380px;\n  padding-left: 180px;\n  box-sizing: border-box;\n}\n\n.clr-pill .clr-gradient {\n  position: absolute;\n  width: 180px;\n  height: 100%;\n  left: 0;\n  top: 0;\n  margin-bottom: 0;\n  border-radius: 3px 0 0 3px;\n}\n\n.clr-pill .clr-hue {\n  margin-top: 20px;\n}', ""]); const a = s }, 5731: (t, e, o) => { "use strict"; o.d(e, { A: () => a }); var n = o(6758), i = o.n(n), r = o(935), s = o.n(r)()(i()); s.push([t.id, ':root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content>div>div{padding:5px}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content>div{min-height:0}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content img{max-width:100%;max-height:100%;display:block;margin-left:auto;margin-right:auto}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content .insert-image-image-status-view{display:flex;justify-content:space-between;padding-bottom:0}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content .action-button-row{margin-top:4px;display:flex;flex-direction:row;justify-content:flex-end;padding-bottom:0;margin-bottom:0}:root .insert-image-widget-dropdown-content.insert-image-widget-dropdown-content.insert-image-widget-dropdown-content .action-button-row>button{flex-grow:1;text-align:end;max-width:50%;min-width:min(100%,40px)}.toolbar-overflow-widget-overflow-list{display:flex;flex-direction:column;flex-wrap:wrap;justify-content:center}.toolbar-overflow-widget-overflow-list>.toolbar-toolContainer>.toolbar-button{height:var(--toolbar-button-height)}.toolbar-overflow-widget.horizontal .toolbar-overflow-widget-overflow-list{flex-direction:row}.toolbar-overflow-widget.horizontal>.toolbar-dropdown{max-width:100%;left:15px;right:15px;margin-left:0 !important;translate:none !important;padding:4px}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons{display:flex;justify-content:stretch;padding-top:0;padding-bottom:5px;direction:ltr}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons>*{flex-grow:1;text-align:start;margin-inline-end:5px}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons>* .icon{margin:0;margin-inline-start:4px;margin-inline-end:10px}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons>:nth-child(1){direction:ltr}:root .toolbar--pen-tool-toggle-buttons.toolbar--pen-tool-toggle-buttons>:last-child{direction:rtl}.toolbar-zoomLevelEditor{display:flex;flex-direction:row;align-items:center}.toolbar-zoomLevelEditor .zoomDisplay{flex-grow:1}.toolbar-zoomLevelEditor button{min-width:48px}.selection-format-menu.disabled{opacity:.5}.toolbar-document-properties-widget button.about-button{width:100%;text-align:end}.toolbar-document-properties-widget>*{--align-items-to-x: 120px}.toolbar-document-properties-widget .js-draw-size-input-row.js-draw-size-input-row{display:flex}.toolbar-document-properties-widget .js-draw-size-input-row.js-draw-size-input-row.size-input-row--automatic-size{display:none}.toolbar-thicknessSliderContainer{display:flex;flex-direction:row}.toolbar-thicknessSliderContainer input{flex-grow:1}.toolbar-element .clr-field *{cursor:pointer}.toolbar-element .clr-field button{width:1.2em;height:1.2em;top:50%;left:0;border-radius:50%;margin-left:0;margin-right:0}.toolbar-element .clr-field input{opacity:0}.color-input-container{display:inline-flex;flex-direction:row}.color-input-container .coloris_input{height:calc(100% - 6px)}.color-input-container.picker-open .clr-field{pointer-events:none}:root .color-input-container>button.pipetteButton{width:30px;height:30px;padding:0;display:inline-flex}.color-input-container>.color-input-wrapper{display:flex;justify-content:stretch}.color-input-container .pipetteButton>svg{width:100%}.color-input-container .pipetteButton .pickColorInstructions{display:none;font-size:1em;position:absolute;margin-left:30px;background-color:var(--background-color-1);border-radius:30px;padding:4px;opacity:0;transition:.2s ease opacity}@media(prefers-reduced-motion: reduce){.color-input-container .pipetteButton .pickColorInstructions{transition:none}}.color-input-container .pipetteButton.active{background-color:var(--selection-background-color);--icon-color: var(--selection-foreground-color)}.color-input-container .pipetteButton.active .pickColorInstructions{display:block;opacity:.8}.tool-dropdown-separator{--border-color: rgba(100, 100, 100, 0.2);--border-color: color-mix(in srgb, var(--foreground-color-1), rgba(0, 0, 0, 0) 80%);border-top:1px solid var(--border-color);padding-left:2px;margin-top:10px;margin-bottom:10px}.toolbar-element .toolbar--file-input-container{display:flex}.toolbar-element .toolbar--file-input-container.-loading{opacity:.8}.toolbar-element .toolbar--file-input-container>input.file-input{opacity:0;width:0;min-width:0 !important;max-width:0;height:0;overflow:hidden;padding:0;margin:0}.toolbar-element .toolbar--file-input-container>label{display:block;flex-grow:1;padding:0 !important;padding-bottom:5px;--active-border-color: rgba(100, 100, 100, 0.5);--active-border-color: color-mix(in srgb, var(--foreground-color-1), transparent)}.toolbar-element .toolbar--file-input-container>label .cancel-button{padding-left:3px;padding-right:3px}.toolbar-element .toolbar--file-input-container>label>.toolbar--file-input-description{background-color:var(--background-color-3);color:var(--foreground-color-3);border:1px dashed var(--active-border-color);padding:10px;margin-top:10px;display:flex;flex-direction:column;align-items:center;text-align:center;--action-color: var(--primary-action-foreground-color);--icon-color: var(--action-color)}.toolbar-element .toolbar--file-input-container>label>.toolbar--file-input-description>span{white-space:pre-wrap}.toolbar-element .toolbar--file-input-container>label>.toolbar--file-input-description>span>b{color:var(--action-color);cursor:pointer}.toolbar-element .toolbar--file-input-container>label>.toolbar--file-input-description>.icon{width:min(50vw,42px);height:min(50vw,42px);margin-bottom:8px;display:block}.toolbar-element .toolbar--file-input-container>label:active,.toolbar-element .toolbar--file-input-container>label:hover,.toolbar-element .toolbar--file-input-container>label.drag-target{--active-border-color: var(--foreground-color-1)}.toolbar-element .toolbar--file-input-container>label.drag-target>.toolbar--file-input-description{border-width:2px}.toolbar-grid-selector{position:relative}.toolbar-grid-selector>div{display:flex;flex-direction:row;max-width:350px;flex-wrap:wrap;--button-size: 48px}.toolbar-grid-selector .choice-button{display:flex;flex-direction:column-reverse;box-sizing:border-box;cursor:pointer;flex-shrink:1;margin:2px}.toolbar-grid-selector .choice-button.focus-visible{outline:2px solid var(--foreground-color-1)}.toolbar-grid-selector .choice-button input{opacity:0;height:0}.toolbar-grid-selector .choice-button label{display:flex;flex-direction:column;box-sizing:border-box;width:var(--button-size);height:var(--button-size);font-size:.7rem;align-items:center;justify-content:center;padding:4px;user-select:none;-webkit-user-select:none}.toolbar-grid-selector .choice-button .icon{flex-grow:1;flex-shrink:1;width:100%}.toolbar-grid-selector .choice-button.checked{background-color:var(--selection-background-color);color:var(--selection-foreground-color);--icon-color: var(--selection-foreground-color)}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list{height:min(200px,50vh);position:relative;display:flex;align-items:center}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.scroller{display:flex;flex-direction:column;overflow-y:auto;scroll-snap-type:y mandatory;height:100%;width:100%;flex-grow:1}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.scroller>.item{height:100%;width:100%;flex-shrink:0;display:flex;justify-content:center;align-items:center;scroll-snap-align:start;scroll-snap-stop:always;box-sizing:border-box}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.-empty{display:none}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers{overflow:hidden;display:flex;flex-direction:column;align-items:center;max-height:100%;min-height:0}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers.-one-element{visibility:hidden}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers>.marker{padding:2px;opacity:.1;cursor:pointer;left:0;transition:left .2s ease}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers>.marker>.content{background-color:var(--foreground-color-1);border-radius:2px;padding:2px}:root .toolbar-snapped-scroll-list.toolbar-snapped-scroll-list.toolbar-snapped-scroll-list>.page-markers>.marker.-active{position:relative;left:2px;opacity:.2}.toolbar-root{background-color:var(--background-color-1);--icon-color: var(--foreground-color-1);--toolbar-button-height: min(20vh, 60px);flex-wrap:wrap;box-sizing:border-box;width:100%;display:flex;flex-direction:row;justify-content:center}.toolbar-element{z-index:1;font-family:system-ui,-apple-system,sans-serif}.toolbar-element details>summary{cursor:pointer}.toolbar-element>.toolbar-toolContainer>.toolbar-button,.toolbar-element>.toolbar-toolContainer>*>button,.toolbar-element>.toolbar-buttonGroup>button,.toolbar-element>.toolbar-button{white-space:pre;height:var(--toolbar-button-height)}.toolbar-dropdown .toolbar-button>.toolbar-icon{max-width:50px;width:100%}.toolbar-button.disabled{filter:sepia(0.2);opacity:.45;cursor:unset}.toolbar-button,.toolbar-element button{cursor:pointer;text-align:center;border-radius:6px;border:none;box-shadow:0px 0px 2px var(--shadow-color);user-select:none;-webkit-user-select:none;transition:background-color .15s ease,box-shadow .25s ease,opacity .2s ease}.toolbar-button,.toolbar-buttonGroup>button,.toolbar-toolContainer>*>button,.toolbar-root>button{display:flex;flex-direction:column;align-items:center;justify-content:center;padding-left:3px;padding-right:3px;min-width:40px;max-width:105px;width:min-content;font-size:1em}.toolbar-button>label{cursor:inherit;user-select:none;-webkit-user-select:none}.toolbar-root>.toolbar-toolContainer>.toolbar-button>label.long-label{font-size:.75em}.toolbar-dropdown>.toolbar-toolContainer>button,.toolbar-dropdown>.toolbar-toolContainer>.toolbar-button{width:6em}.toolbar-button:not(.disabled):hover,.toolbar-root button:not(:disabled):hover{box-shadow:0px 2px 4px var(--shadow-color)}.toolbar-root button:disabled{cursor:inherit;opacity:.5}.toolbar-root .toolbar-icon{flex-shrink:1;user-select:none;width:100%;min-width:20px;min-height:20px}.toolbar-toolContainer.selected>.toolbar-button{background-color:var(--selection-background-color);color:var(--selection-foreground-color);--icon-color: var(--selection-foreground-color)}.toolbar-toolContainer:not(.selected):not(.dropdownShowable)>.toolbar-button>.toolbar-showHideDropdownIcon{display:none}.toolbar-toolContainer>.toolbar-button>.toolbar-showHideDropdownIcon{height:15px;transition:transform .25s ease}.toolbar-toolContainer.dropdownVisible>.toolbar-button>.toolbar-showHideDropdownIcon{transform:rotate(180deg)}.toolbar-dropdown.hidden,.toolbar-toolContainer:not(.selected):not(.dropdownShowable)>.toolbar-dropdown:not(.hiding){display:none}.toolbar-dropdown{position:absolute;padding:15px;padding-top:5px;display:flex;flex-wrap:wrap;flex-direction:column;max-height:80vh;max-width:fit-content;z-index:2;background-color:var(--background-color-1);box-shadow:0px 3px 3px var(--shadow-color)}@keyframes dropdown-transition-in{0%{opacity:0;transform:scale(1, 0)}100%{opacity:1;transform:scale(1, 1)}}@keyframes dropdown-transition-out{0%{opacity:1;transform:scale(1, 1)}100%{opacity:0;transform:scale(1, 0)}}.toolbar-dropdown{transform-origin:top left;--dropdown-show-animation: dropdown-transition-in;--dropdown-hide-animation: dropdown-transition-out}@media(prefers-reduced-motion: reduce){.toolbar-dropdown{--dropdown-show-animation: none;--dropdown-hide-animation: none}.toolbar-dropdown.hiding{display:none}.toolbar-toolContainer>.toolbar-button>.toolbar-showHideDropdownIcon{transition:none}:root .toolbar-button,.toolbar-root button{transition:none}}.toolbar-buttonGroup{display:flex;flex-direction:row;justify-content:center}.toolbar-element .toolbar--toggle-button{color:var(--foreground-color-1);font-weight:normal}.toolbar-element .toolbar--toggle-button[aria-checked=true]{background:var(--selection-background-color);color:var(--selection-foreground-color)}.toolbar-element .toolbar--toggle-button>.icon{width:25px;height:25px;margin:0 5px}.toolbar-element .toolbar--toggle-button>*{vertical-align:middle}.toolbar-closeColorPickerOverlay{display:none;position:fixed;top:0;left:0;bottom:0;right:0;touch-action:none;background-color:var(--background-color-1);opacity:.3;z-index:2}.toolbar-spacedList>*{padding-bottom:5px;padding-top:5px}.toolbar-indentedList{padding-left:10px}@media print{.toolbar-element{display:none}}@keyframes rehide-label{0%{opacity:.8}80%{opacity:.8}100%{opacity:.1}}@keyframes show-label-delayed{0%{opacity:0}80%{opacity:0}100%{opacity:.8}}@keyframes show-label-now{0%{opacity:0}5%{opacity:0}100%{opacity:.8}}@keyframes keep-label-hidden{0%{opacity:0}100%{opacity:0}}@keyframes toolbar--edgemenu-transition-in{from{transform:translate(0, 100%)}to{transform:translate(0, 0)}}@keyframes toolbar--edgemenu-transition-in-reduce-motion{from{opacity:0}to{opacity:1}}@keyframes toolbar--edgemenu-transition-out{to{transform:translate(0, 100%)}}@keyframes toolbar--edgemenu-transition-out-reduce-motion{from{opacity:1}to{opacity:0}}@keyframes toolbar--edgemenu-container-transition-in{from{overflow-y:hidden}to{overflow-y:hidden}}@keyframes toolbar--edgemenu-container-transition-out{from{overflow-y:hidden}to{overflow-y:hidden}}.toolbar-edge-toolbar{--toolbar-button-height: min(20vh, 48px);--toolbar-button-size: var(--toolbar-button-height);--label-hover-offset-size: calc(14px + var(--toolbar-button-height));box-sizing:border-box;flex-direction:row;justify-content:space-around;--button-label-hover-offset-y: var(--label-hover-offset-size);--button-label-hover-offset-x: 0}@media screen and (min-width: 540px){.toolbar-edge-toolbar{flex-wrap:nowrap}.toolbar-edge-toolbar>.toolbar-action-row{max-width:50vw;flex-grow:0;flex-shrink:0}}@media screen and (max-width: 700px){.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline{font-size:.9em}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button{width:var(--toolbar-button-size)}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button label{opacity:0;animation:.2s linear hide-initially}@keyframes hide-initially{from{opacity:0}to{opacity:0}}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):hover:not(:focus-visible)>label,.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):active>label{opacity:.8;animation:1s ease show-label-delayed}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button.has-long-press-or-hover>label{opacity:.8}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button:focus-visible>label,.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button.focus-visible>label{animation:1.5s ease rehide-label;opacity:0}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button:has(:focus-visible)>label{animation:1.5s ease rehide-label;opacity:0}.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button>label{opacity:0;position:absolute;margin-top:var(--button-label-hover-offset-y);margin-left:var(--button-label-hover-offset-x);z-index:1;pointer-events:none;background-color:var(--background-color-1);color:var(--foreground-color-1);border-radius:25px;padding:10px;transition:.3s ease opacity,.2s ease margin-top}}@media screen and (max-width: 700px)and (prefers-reduced-motion: reduce){.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button>label{transition:none}}@media screen and (max-width: 700px){.toolbar-edge-toolbar.one-row>*>.toolbar-toolContainer.label-inline>.toolbar-button>.toolbar-icon.toolbar-icon{margin-left:0;margin-right:0}}.toolbar-edge-toolbar>div.toolbar-element{flex-direction:row;display:flex;flex-grow:1;justify-content:center;background-color:var(--background-color-2);color:var(--foreground-color-2);--icon-color: var(--foreground-color-2);--extra-left-right-padding: 0px}.toolbar-edge-toolbar>div.toolbar-element::-webkit-scrollbar{width:3px;height:3px}.toolbar-edge-toolbar>div.toolbar-element::-webkit-scrollbar-thumb{background-color:var(--shadow-color)}.toolbar-edge-toolbar>div.toolbar-element.toolbar-tool-row{overflow-x:auto;overflow-y:hidden;flex-grow:100}.toolbar-edge-toolbar>div.toolbar-element.toolbar-action-row{z-index:2;background-color:var(--background-color-3);color:var(--foreground-color-3);--icon-color: var(--foreground-color-3)}.toolbar-edge-toolbar>div.toolbar-element.has-scroll{justify-content:start;position:relative;--button-label-hover-offset-y: 0;--button-label-hover-offset-x: calc(0px - var(--label-hover-offset-size))}.toolbar-edge-toolbar>div.toolbar-element.has-scroll>:nth-child(1){--button-label-hover-offset-x: var(--label-hover-offset-size)}.toolbar-edge-toolbar .toolbar-toolContainer.selected>.toolbar-button{background-color:var(--selection-background-color);color:var(--selection-foreground-color);--icon-color: var(--selection-foreground-color)}.toolbar-edge-toolbar .toolbar-button{box-sizing:border-box;background-color:rgba(0,0,0,0)}.toolbar-edge-toolbar .toolbar-button .toolbar-showHideDropdownIcon{flex-shrink:.01;height:12px}.toolbar-edge-toolbar .toolbar-toolContainer{order:1}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline{flex-grow:1;display:flex;--button-flex-direction: row}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline.label-left{justify-content:end;--button-flex-direction: row-reverse;order:100}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline.label-left>.toolbar-button>.toolbar-icon{margin-left:7px;margin-right:0}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline.label-right{order:-1}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline>.toolbar-button{width:auto;flex-direction:var(--button-flex-direction)}.toolbar-edge-toolbar .toolbar-toolContainer.label-inline>.toolbar-button>.toolbar-icon{height:100%;margin-right:7px;margin-left:0;width:22px}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button{width:calc(var(--toolbar-button-size) + var(--extra-left-right-padding));height:var(--toolbar-button-size)}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):hover:not(:focus-visible)>label,.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):active>label{opacity:.8;animation:1s ease show-label-delayed}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button.has-long-press-or-hover>label{opacity:.8}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button:focus-visible>label,.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button.focus-visible>label{animation:1.5s ease rehide-label;opacity:0}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button:has(:focus-visible)>label{animation:1.5s ease rehide-label;opacity:0}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button>label{opacity:0;position:absolute;margin-top:var(--button-label-hover-offset-y);margin-left:var(--button-label-hover-offset-x);z-index:1;pointer-events:none;background-color:var(--background-color-1);color:var(--foreground-color-1);border-radius:25px;padding:10px;transition:.3s ease opacity,.2s ease margin-top}@media(prefers-reduced-motion: reduce){.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline) .toolbar-button>label{transition:none}}.toolbar-edge-toolbar .toolbar-toolContainer:not(.no-icon):not(.label-inline).dropdownVisible>.toolbar-button>label{opacity:.8;animation:1.5s ease rehide-label .3s,1s ease keep-label-hidden 1.8s infinite}.toolbar-edge-toolbar>div>.toolbar-toolContainer:not(.selected):not(.dropdownShowable)>.toolbar-button>.toolbar-showHideDropdownIcon{display:block;visibility:hidden}.toolbar-edge-toolbar .toolbar-toolContainer>.toolbar-button{margin:0;border-radius:0;padding:8px;box-shadow:none}.toolbar-edge-toolbar .toolbar-toolContainer>.toolbar-button.has-dropdown{padding-left:8px;padding-right:8px;padding-top:8px;padding-bottom:0px}.imageEditorContainer.pipette--color-selection-in-progress .toolbar-edgemenu-container{height:0;background-color:rgba(0,0,0,0);opacity:.9}.imageEditorContainer.pipette--color-selection-in-progress .toolbar-edgemenu-container .toolbar-edgemenu{position:absolute}.toolbar-edgemenu-container{background-color:var(--background-color-transparent);transition:.15s ease-in-out height,.15s ease-in-out background-color,.2s ease-in-out opacity;position:absolute;width:var(--editor-current-width-px);height:var(--editor-current-height-px);box-sizing:border-box;display:flex;flex-direction:column-reverse;align-items:center;z-index:2}@media(prefers-reduced-motion: reduce){.toolbar-edgemenu-container{transition:.15s ease-in-out background-color,.2s ease-in-out opacity}}.toolbar-edgemenu-container.dropdown-below-edge{overflow-y:hidden}.toolbar-edgemenu-container button{font-size:1.2em;box-shadow:none;border:none;padding:10px;transition:.2s ease box-shadow;font-weight:bold;color:var(--primary-action-foreground-color)}.toolbar-edgemenu-container button:not(:disabled):hover{box-shadow:0 1px 2px var(--shadow-color)}.toolbar-edgemenu-container button:disabled{opacity:.5;font-weight:unset;cursor:unset;color:var(--foreground-color-1)}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button{--button-label-hover-offset-y: var(--button-size)}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):hover:not(:focus-visible)>label>.button-label-text,.toolbar-edgemenu-container .toolbar-grid-selector .choice-button:not(.no-long-press-or-hover):not(.has-long-press-or-hover):active>label>.button-label-text{opacity:.8;animation:1s ease show-label-delayed}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button.has-long-press-or-hover>label>.button-label-text{opacity:.8}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button:focus-visible>label>.button-label-text,.toolbar-edgemenu-container .toolbar-grid-selector .choice-button.focus-visible>label>.button-label-text{animation:1.5s ease rehide-label;opacity:0}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button:has(:focus-visible)>label>.button-label-text{animation:1.5s ease rehide-label;opacity:0}.toolbar-edgemenu-container .toolbar-grid-selector .choice-button>label>.button-label-text{opacity:0;position:absolute;margin-top:var(--button-label-hover-offset-y);margin-left:var(--button-label-hover-offset-x);z-index:1;pointer-events:none;background-color:var(--background-color-1);color:var(--foreground-color-1);border-radius:25px;padding:10px;transition:.3s ease opacity,.2s ease margin-top}@media(prefers-reduced-motion: reduce){.toolbar-edgemenu-container .toolbar-grid-selector .choice-button>label>.button-label-text{transition:none}}.toolbar-edgemenu-container .toolbar-help-overlay-button{align-items:last baseline}.toolbar-edgemenu-container .toolbar-edgemenu{--toolbar-button-height: 48px;touch-action:none;user-select:none;-webkit-user-select:none;background-color:var(--background-color-2);color:var(--foreground-color-2);--icon-color: var(--foreground-color-2);box-shadow:0px 0px 1px var(--shadow-color);padding-left:10px;padding-right:10px;width:min(400px,100vw);box-sizing:border-box;border-top-left-radius:30px;border-top-right-radius:30px;transition:transform .1s ease,padding-bottom .1s ease}.toolbar-edgemenu-container .toolbar-edgemenu input,.toolbar-edgemenu-container .toolbar-edgemenu textarea{user-select:auto;-webkit-user-select:auto}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer{display:inline-block}.toolbar-edgemenu-container .toolbar-edgemenu button{background-color:rgba(0,0,0,0)}.toolbar-edgemenu-container .toolbar-edgemenu>button.drag-elem{height:40px;display:block;cursor:ns-resize;position:relative;margin-top:-15px;margin-bottom:10px;width:100%;border:none;box-shadow:none;background:rgba(0,0,0,0)}.toolbar-edgemenu-container .toolbar-edgemenu>button.drag-elem::before{content:"";background-color:var(--icon-color);opacity:.2;display:block;position:relative;top:10px;height:5px;border-radius:5px;width:min(80%,40px);margin-left:auto;margin-right:auto}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer{display:block}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer .toolbar-button{flex-direction:row;max-width:unset;width:100%;box-sizing:border-box;justify-content:flex-start;box-shadow:none;padding:2px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer .toolbar-button>.toolbar-icon{width:25px;height:25px;padding:13px;margin-right:15px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer .toolbar-button label,.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-toolContainer .toolbar-button>label.long-label{font-size:1em}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-nonbutton-controls-main-list{padding-left:10px;padding-right:10px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList{box-sizing:border-box;--align-items-to-x: 105px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div{display:flex;align-items:center;margin-top:5px;min-height:35px}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div:first-child{margin-top:0}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div>label{padding-right:35px;min-width:var(--align-items-to-x);flex-shrink:1;box-sizing:border-box}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div>input[type=checkbox]{width:20px;height:20px;margin-left:0}.toolbar-edgemenu-container .toolbar-edgemenu .toolbar-spacedList>div>input:not([type=checkbox]){flex-grow:1;min-width:48px;flex-shrink:1}.toolbar-dropdown-toolbar button,.toolbar-dropdown-toolbar .toolbar-button{background-color:var(--background-color-2);color:var(--foreground-color-2);--icon-color: var(--foreground-color-2)}.toolbar-dropdown-toolbar,.toolbar-dropdown-toolbar .toolbar-dropdown{background-color:var(--background-color-3);color:var(--foreground-color-3)}.toolbar-dropdown-toolbar .toolbar-spacedList>div>label{padding-right:10px;min-width:50px}.toolbar-dropdown-toolbar .clr-field button{width:100%;height:100%;top:50%;left:0;border-radius:5px}.toolbar-dropdown-toolbar .toolbar-grid-selector>div{--button-size: 57px}.toolbar-dropdown-toolbar .toolbar-dropdown>div>.toolbar-toolContainer{display:inline-block}.toolbar-help-overlay{width:100%;height:100%;max-width:none;max-height:none;border:none;margin:0;padding:0;z-index:5;touch-action:none;overflow:hidden;color:#fff;--icon-color: white;background-color:rgba(0,0,0,0);display:flex;flex-direction:column;transition:.3s ease transform}.toolbar-help-overlay::backdrop{background-color:rgba(0,0,0,.8);backdrop-filter:blur(1px);-webkit-backdrop-filter:blur(1px)}.toolbar-help-overlay,.toolbar-help-overlay::backdrop{animation:.25s ease transition-in}@keyframes transition-in{0%{opacity:0}100%{opacity:1}}@keyframes transition-out{0%{opacity:1}100%{opacity:0}}.toolbar-help-overlay.-hiding,.toolbar-help-overlay.-hiding::backdrop{animation:.25s ease transition-out;opacity:0}.toolbar-help-overlay.-dragging{transition:none}@media(prefers-reduced-motion: reduce){.toolbar-help-overlay{transition:none}}@media screen and (min-width: 800px){.toolbar-help-overlay>.navigation-buttons{order:1;margin-top:auto}}.toolbar-help-overlay .with-text-shadow,.toolbar-help-overlay .help-page-container>.label,.toolbar-help-overlay button{text-shadow:0 0 3px rgba(20,20,20,.9);filter:drop-shadow(0px 0px 2px rgba(0, 0, 0, 0.5))}.toolbar-help-overlay button:not(:disabled){cursor:pointer}.toolbar-help-overlay button{background:rgba(0,0,0,0);border:none;color:var(--help-overlay-foreground);border-radius:15px}.toolbar-help-overlay .close-button{align-self:flex-start;width:48px;height:48px;z-index:1}.toolbar-help-overlay .close-button>svg{width:100%}.toolbar-help-overlay .navigation-content{flex-grow:1;display:flex}.toolbar-help-overlay .help-page-container{display:flex;align-items:center;flex-grow:1;touch-action:none}.toolbar-help-overlay .help-page-container>.label{flex-grow:1;text-align:center;font-size:18.5pt;margin-left:15px;margin-right:15px;margin-top:0px;z-index:1;transition:.5s ease margin-top}.toolbar-help-overlay .help-page-container>.label.-large-space-below{margin-top:0;margin-bottom:auto}.toolbar-help-overlay .help-page-container>.label.-small-space-above{margin-top:40px;margin-bottom:auto}.toolbar-help-overlay .help-page-container>.label.-large-space-above{margin-top:auto;margin-bottom:10px}@media(prefers-reduced-motion: reduce){.toolbar-help-overlay .help-page-container>.label{transition:none}}.toolbar-help-overlay .help-page-container>.cloned-element-container{position:absolute;z-index:0;user-select:none;-webkit-user-select:none;border-radius:10px;opacity:.01;background-color:rgba(100,100,100,.01);box-shadow:none;transition:.5s ease opacity,.5s ease background-color}.toolbar-help-overlay .help-page-container>.cloned-element-container *{pointer-events:none !important}.toolbar-help-overlay .help-page-container>.cloned-element-container>*{margin:0;opacity:.01 !important;transition:.3s ease opacity !important}.toolbar-help-overlay .help-page-container>.cloned-element-container:not(.-clickable) *{cursor:unset !important}.toolbar-help-overlay .help-page-container>.cloned-element-container.-clickable,.toolbar-help-overlay .help-page-container>.cloned-element-container.-background{z-index:1;touch-action:none}.toolbar-help-overlay .help-page-container>.cloned-element-container.-clickable{cursor:pointer;z-index:2}.toolbar-help-overlay .help-page-container>.cloned-element-container.-clickable.has-long-press-or-hover{opacity:.5 !important}.toolbar-help-overlay .help-page-container>.cloned-element-container.-clickable.has-long-press-or-hover,.toolbar-help-overlay .help-page-container>.cloned-element-container.-active{background-color:var(--background-color-1)}.toolbar-help-overlay .help-page-container>.cloned-element-container.-active{opacity:1;background-color:var(--background-color-1);box-shadow:0 0 3px rgba(100,100,100,.5)}.toolbar-help-overlay .help-page-container>.cloned-element-container.-active>*{opacity:1 !important}.toolbar-help-overlay .navigation-buttons{display:flex;flex-direction:row;justify-content:space-between;direction:ltr}.toolbar-help-overlay .navigation-buttons>button:disabled{opacity:.5}.toolbar-help-overlay .navigation-buttons>.next,.toolbar-help-overlay .navigation-buttons>.previous{font-size:1em;padding:10px;transition:.2s ease font-size;z-index:3}@media(prefers-reduced-motion: reduce){.toolbar-help-overlay .navigation-buttons>.next,.toolbar-help-overlay .navigation-buttons>.previous{transition:none}}.toolbar-help-overlay .navigation-buttons:not(.-has-previous)>.next:not(:disabled){animation:.5s ease highlight-button .5s}@keyframes highlight-button{0%{transform:scale(1)}50%{transform:scale(1.2)}55%{transform:scale(1.2) rotate(2deg)}65%{transform:scale(1.2) rotate(-2deg)}100%{transform:scale(1)}}@media(prefers-reduced-motion: reduce){.toolbar-help-overlay .navigation-buttons:not(.-has-previous)>.next:not(:disabled){animation:none}}.toolbar-help-overlay .navigation-buttons>.next::after{content:"❯";margin-left:3px}.toolbar-help-overlay .navigation-buttons>.previous::before{content:"❮";margin-right:3px}.toolbar-help-overlay .navigation-buttons.-has-next>.next{font-size:1.4em}.toolbar-help-overlay .navigation-buttons.-has-previous>.previous{font-size:1.4em}.toolbar-help-overlay .navigation-buttons.-highlight-next>.next,.toolbar-help-overlay .navigation-buttons.-highlight-previous>.previous{font-weight:bold;background-color:rgba(200,200,200,.1);font-size:1.4em}.toolbar-help-overlay .navigation-help{margin-top:1em;font-size:.7em}.toolbar-element .toolbar-help-overlay-button{height:0;position:relative;display:flex;justify-content:end}.toolbar-element .toolbar-help-overlay-button>.button{margin:0;padding:5px;padding-top:0;padding-bottom:0;box-shadow:none;text-align:center;opacity:.5}.toolbar-element .toolbar-help-overlay-button>.button>.icon{width:1.18em;height:1.18em;transition:.2s ease filter}.toolbar-element .toolbar-help-overlay-button>.button:focus-visible>.icon,.toolbar-element .toolbar-help-overlay-button>.button:hover>.icon{filter:drop-shadow(0px 0px 1px var(--shadow-color))}.ScrollbarTool-overlay{width:0;height:0;overflow:visible;opacity:.2;pointer-events:none;--fade-out-animation: 1s ease 0s fade-out;--scrollbar-size: 3px}@media(prefers-reduced-motion: reduce){.ScrollbarTool-overlay{--fade-out-animation: none !important}}@keyframes fade-out{from{opacity:.2}to{opacity:0}}.ScrollbarTool-overlay:not(.just-updated){animation:var(--fade-out-animation);opacity:0}.ScrollbarTool-overlay .vertical-scrollbar,.ScrollbarTool-overlay .horizontal-scrollbar{width:var(--scrollbar-size);height:var(--scrollbar-size);min-width:var(--scrollbar-size);min-height:var(--scrollbar-size);background-color:var(--foreground-color-1);border-radius:var(--scrollbar-size);position:absolute}.ScrollbarTool-overlay .vertical-scrollbar.represents-no-scroll,.ScrollbarTool-overlay .horizontal-scrollbar.represents-no-scroll{animation:var(--fade-out-animation);opacity:0}.ScrollbarTool-overlay:not(.scrollbar-left) .vertical-scrollbar{margin-left:calc(var(--editor-current-display-width-px) - var(--scrollbar-size))}.ScrollbarTool-overlay:not(.scrollbar-top) .horizontal-scrollbar{margin-top:calc(var(--editor-current-display-height-px) - var(--scrollbar-size))}.clipboard-error-dialog details>summary{cursor:pointer}.clipboard-error-dialog details[open]{margin-bottom:12px}.clipboard-error-dialog textarea{width:100%;box-sizing:border-box}.selection-tool-selection-background{background-color:var(--selection-background-color);opacity:.5;overflow:visible}.selection-tool-handle{position:absolute;box-sizing:border-box;display:flex;align-items:center;justify-content:center;--max-size: 17px}.selection-tool-handle .selection-tool-content{border:1px solid var(--foreground-color-1);background:var(--background-color-1);box-sizing:border-box;max-width:var(--max-size);max-height:var(--max-size);width:100%;height:100%;display:flex;justify-content:center;align-items:center;padding:3px}.selection-tool-handle .selection-tool-content .icon{width:100%;height:100%}.selection-tool-handle.selection-tool-circle .selection-tool-content{border-radius:100%}.selection-tool-handle.selection-tool-rotate{--max-size: 28px;cursor:grab}.selection-tool-handle.selection-tool-resize-x{cursor:ew-resize}.selection-tool-handle.selection-tool-resize-y{cursor:ns-resize}.selection-tool-handle.selection-tool-resize-xy{cursor:nwse-resize}.selection-tool-rotated-near-perpendicular .selection-tool-handle.selection-tool-resize-x{cursor:ns-resize}.selection-tool-rotated-near-perpendicular .selection-tool-handle.selection-tool-resize-y{cursor:ew-resize}.selection-tool-rotated-near-perpendicular .selection-tool-handle.selection-tool-resize-xy{cursor:nesw-resize}.selection-tool-selection-menu>button{max-height:var(--vertical-offset);background-color:var(--background-color-1);font-size:14px;color:var(--foreground-color-1);border:.5px solid var(--foreground-color-1);border-radius:3px;padding:3px;opacity:.8;transition:.2s ease opacity}.selection-tool-selection-menu>button:hover,.selection-tool-selection-menu>button:focus-visible{background-color:var(--background-color-2);color:var(--foreground-color-2);cursor:pointer;opacity:1}.overlay.handleOverlay{touch-action:none;direction:ltr}.overlay.handleOverlay,.overlay.handleOverlay .selection-tool-selection-outer-container{height:0;overflow:visible}.overlay.handleOverlay .selection-tool-selection-inner-container{width:var(--editor-current-display-width-px);height:var(--editor-current-display-height-px);overflow:hidden;pointer-events:none}.overlay.handleOverlay .selection-tool-selection-inner-container>*{pointer-events:all}.overlay.handleOverlay .selection-tool-selection-inner-container.-empty{opacity:0}.overlay.handleOverlay .selection-tool-selection-inner-container.-hide-handles .selection-tool-handle{display:none}@keyframes selection-duplicated-animation{0%{scale:1 1}50%{scale:1.02 1.02}100%{scale:1 1}}@media(prefers-reduced-motion: reduce){@keyframes selection-duplicated-animation{}}.find-tool-overlay{order:-1;position:absolute}.js-draw-sound-ui-toggle{width:0px;height:0px;overflow:hidden;user-select:none;-webkit-user-select:none}.js-draw-sound-ui-toggle button{margin-top:1px}.js-draw-sound-ui-toggle:focus-within,.js-draw-sound-ui-toggle.sound-ui-tool-enabled{overflow:visible;z-index:5}.js-draw-sound-ui-toggle:not(:focus-within):not(:hover).sound-ui-tool-enabled{opacity:.5}@keyframes show-popup-menu-animation{from{opacity:0}to{opacity:1}}.editor-popup-menu{width:100%;height:100%;background-color:rgba(0,0,0,0);border:none;animation:var(--hide-menu-animation-timeout) ease show-popup-menu-animation;opacity:1;transition:var(--hide-menu-animation-timeout) ease opacity;overflow:hidden}.editor-popup-menu.-hide{opacity:0}.editor-popup-menu>.content{position:absolute;left:var(--anchor-x);top:var(--anchor-y);display:flex;flex-direction:column;overflow:clip;border-radius:6px;box-shadow:0px 1px 2px var(--shadow-color)}.editor-popup-menu::backdrop{background:rgba(0,0,0,0)}.editor-popup-menu-option{display:flex;justify-content:start;cursor:pointer;padding:5px;padding-top:6px;padding-bottom:6px;background-color:var(--background-color-1);color:var(--foreground-color-1);--icon-color: currentColor;border:none;font-size:1em}.editor-popup-menu-option:hover,.editor-popup-menu-option:focus-visible{background-color:var(--background-color-2);color:var(--foreground-color-2)}.editor-popup-menu-option>:first-child{width:1em;height:1em;flex-shrink:0;margin-inline-start:0em;margin-inline-end:.25em}.about-dialog-content>.scroll{white-space:pre-wrap;font-family:monospace}.about-dialog-content>.scroll>details>summary{cursor:pointer}.about-dialog-content>.scroll>h2,.about-dialog-content>.scroll>details>summary{margin-top:15px;font-size:1.2em;font-weight:bold}.about-dialog-content>.scroll>h2 a,.about-dialog-content>.scroll>details>summary a{color:var(--foreground-color-1);text-decoration:underline}@keyframes fade-in{from{opacity:0}to{opacity:1}}.message-dialog-container dialog{display:flex}.message-dialog-container dialog.-closing{opacity:0}.message-dialog-container dialog.-closing::backdrop{opacity:0}.message-dialog-container dialog,.message-dialog-container dialog::backdrop{transition:opacity .2s ease;animation:fade-in .2s ease}.message-dialog-content{display:flex;flex-direction:column;flex-grow:1}.message-dialog-content>.close{display:block;margin-left:auto;margin-right:auto}.message-dialog-content>.scroll{flex-grow:1;flex-shrink:1;overflow-y:auto;margin-left:20px;margin-right:20px;padding-bottom:20px}.dialog-container>dialog{background-color:var(--background-color-1);color:var(--foreground-color-1);border:none;outline:none;box-shadow:0 0 2px var(--shadow-color);border-radius:8px;max-height:90vh;width:min(100%,500px);box-sizing:border-box}.dialog-container>dialog::backdrop{backdrop-filter:blur(5px);-webkit-backdrop-filter:blur(5px);background-color:var(--background-color-transparent)}#clr-picker{--clr-slider-size: 30px}#clr-picker #clr-color-area,#clr-picker .clr_hue{touch-action:none}#clr-picker .clr-alpha{margin-top:15px;margin-bottom:15px}#clr-picker.clr-picker input[type=range]::-moz-range-thumb{width:var(--clr-slider-size);height:var(--clr-slider-size)}#clr-picker.clr-picker input[type=range]::-webkit-slider-thumb{width:var(--clr-slider-size);height:var(--clr-slider-size)}#clr-picker.clr-picker input[type=range]::-webkit-slider-runnable-track{height:var(--clr-slider-size)}#clr-picker.clr-picker input[type=range]::-moz-range-track{height:var(--clr-slider-size)}.imageEditorContainer{--background-color-1: white;--foreground-color-1: black;--background-color-2: #f5f5f5;--foreground-color-2: #2c303a;--background-color-3: #e5e5e5;--foreground-color-3: #1c202a;--selection-background-color: #cbdaf1;--selection-foreground-color: #2c303a;--background-color-transparent: rgba(105, 100, 100, 0.5);--shadow-color: rgba(0, 0, 0, 0.5);--primary-action-foreground-color: #15b}@media(prefers-color-scheme: dark){.imageEditorContainer{--background-color-1: #151515;--foreground-color-1: white;--background-color-2: #222;--foreground-color-2: #efefef;--background-color-3: #272627;--foreground-color-3: #eee;--selection-background-color: #607;--selection-foreground-color: white;--shadow-color: rgba(250, 250, 250, 0.5);--background-color-transparent: rgba(50, 50, 50, 0.5);--primary-action-foreground-color: #7ae}}.imageEditorContainer{--icon-color: var(--foreground-color-1)}.imageEditorContainer{color:var(--foreground-color-1);font-family:system-ui,-apple-system,sans-serif;background-color:var(--background-color-1);width:100%;height:400px;min-height:220px;min-width:100px;writing-mode:horizontal-tb;box-sizing:border-box;display:flex;flex-direction:column-reverse}.imageEditorContainer input{accent-color:var(--primary-action-foreground-color)}.imageEditorContainer .imageEditorRenderArea{display:grid;grid-template-columns:1fr;flex-grow:2;flex-shrink:1;min-height:100px;min-width:0;width:100%;height:100%}.imageEditorContainer .imageEditorRenderArea canvas{grid-row:1/1;grid-column:1/1;touch-action:none;box-sizing:border-box;width:100%;height:100%;min-width:0;max-width:inherit;min-height:0px;max-height:inherit;user-select:none;-webkit-user-select:none;-webkit-user-drag:none}.imageEditorContainer .loadingMessage{position:fixed;text-align:center;font-size:2em;text-shadow:0px 0px 1px var(--background-color-1);bottom:0;left:0;right:0}.imageEditorContainer .accessibilityAnnouncement{opacity:0;width:0;height:0;overflow:hidden;pointer-events:none;user-select:none;-webkit-user-select:none}.imageEditorContainer .textRendererOutputContainer{width:.001px;height:.001px;overflow:hidden;-webkit-user-select:none;user-select:none}.imageEditorContainer .textRendererOutputContainer:focus-within{overflow:visible;z-index:5}.imageEditorContainer .anchored-element-overlay{overflow:visible;height:0}.imageEditorContainer .anchored-element-overlay>.content-wrapper{width:var(--editor-current-display-width-px);height:var(--editor-current-display-height-px);overflow:hidden;position:relative;pointer-events:none}.imageEditorContainer .anchored-element-overlay>.content-wrapper>.content{position:absolute;left:var(--position-x);top:var(--position-y);transform:scale(var(--scale)) rotate(var(--rotation));transform-origin:left top;margin:0;pointer-events:all}@media print{.imageEditorContainer .loadingMessage{display:none}.imageEditorContainer .imageEditorRenderArea canvas{width:100%;height:initial}}', ""]); const a = s }, 935: t => { "use strict"; t.exports = function (t) { var e = []; return e.toString = function () { return this.map((function (e) { var o = "", n = void 0 !== e[5]; return e[4] && (o += "@supports (".concat(e[4], ") {")), e[2] && (o += "@media ".concat(e[2], " {")), n && (o += "@layer".concat(e[5].length > 0 ? " ".concat(e[5]) : "", " {")), o += t(e), n && (o += "}"), e[2] && (o += "}"), e[4] && (o += "}"), o })).join("") }, e.i = function (t, o, n, i, r) { "string" == typeof t && (t = [[null, t, void 0]]); var s = {}; if (n) for (var a = 0; a < this.length; a++) { var l = this[a][0]; null != l && (s[l] = !0) } for (var c = 0; c < t.length; c++) { var d = [].concat(t[c]); n && s[d[0]] || (void 0 !== r && (void 0 === d[5] || (d[1] = "@layer".concat(d[5].length > 0 ? " ".concat(d[5]) : "", " {").concat(d[1], "}")), d[5] = r), o && (d[2] ? (d[1] = "@media ".concat(d[2], " {").concat(d[1], "}"), d[2] = o) : d[2] = o), i && (d[4] ? (d[1] = "@supports (".concat(d[4], ") {").concat(d[1], "}"), d[4] = i) : d[4] = "".concat(i)), e.push(d)) } }, e } }, 6758: t => { "use strict"; t.exports = function (t) { return t[1] } }, 2591: t => { "use strict"; var e = []; function o(t) { for (var o = -1, n = 0; n < e.length; n++)if (e[n].identifier === t) { o = n; break } return o } function n(t, n) { for (var r = {}, s = [], a = 0; a < t.length; a++) { var l = t[a], c = n.base ? l[0] + n.base : l[0], d = r[c] || 0, h = "".concat(c, " ").concat(d); r[c] = d + 1; var u = o(h), p = { css: l[1], media: l[2], sourceMap: l[3], supports: l[4], layer: l[5] }; if (-1 !== u) e[u].references++, e[u].updater(p); else { var f = i(p, n); n.byIndex = a, e.splice(a, 0, { identifier: h, updater: f, references: 1 }) } s.push(h) } return s } function i(t, e) { var o = e.domAPI(e); o.update(t); return function (e) { if (e) { if (e.css === t.css && e.media === t.media && e.sourceMap === t.sourceMap && e.supports === t.supports && e.layer === t.layer) return; o.update(t = e) } else o.remove() } } t.exports = function (t, i) { var r = n(t = t || [], i = i || {}); return function (t) { t = t || []; for (var s = 0; s < r.length; s++) { var a = o(r[s]); e[a].references-- } for (var l = n(t, i), c = 0; c < r.length; c++) { var d = o(r[c]); 0 === e[d].references && (e[d].updater(), e.splice(d, 1)) } r = l } } }, 8128: t => { "use strict"; var e = {}; t.exports = function (t, o) { var n = function (t) { if (void 0 === e[t]) { var o = document.querySelector(t); if (window.HTMLIFrameElement && o instanceof window.HTMLIFrameElement) try { o = o.contentDocument.head } catch (t) { o = null } e[t] = o } return e[t] }(t); if (!n) throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."); n.appendChild(o) } }, 3051: t => { "use strict"; t.exports = function (t) { var e = document.createElement("style"); return t.setAttributes(e, t.attributes), t.insert(e, t.options), e } }, 855: (t, e, o) => { "use strict"; t.exports = function (t) { var e = o.nc; e && t.setAttribute("nonce", e) } }, 1740: t => { "use strict"; t.exports = function (t) { if ("undefined" == typeof document) return { update: function () { }, remove: function () { } }; var e = t.insertStyleElement(t); return { update: function (o) { !function (t, e, o) { var n = ""; o.supports && (n += "@supports (".concat(o.supports, ") {")), o.media && (n += "@media ".concat(o.media, " {")); var i = void 0 !== o.layer; i && (n += "@layer".concat(o.layer.length > 0 ? " ".concat(o.layer) : "", " {")), n += o.css, i && (n += "}"), o.media && (n += "}"), o.supports && (n += "}"); var r = o.sourceMap; r && "undefined" != typeof btoa && (n += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(r)))), " */")), e.styleTagTransform(n, t, e.options) }(e, t, o) }, remove: function () { !function (t) { if (null === t.parentNode) return !1; t.parentNode.removeChild(t) }(e) } } } }, 3656: t => { "use strict"; t.exports = function (t, e) { if (e.styleSheet) e.styleSheet.cssText = t; else { for (; e.firstChild;)e.removeChild(e.firstChild); e.appendChild(document.createTextNode(t)) } } }, 3954: function (t, e, o) { "use strict"; var n, i = this && this.__createBinding || (Object.create ? function (t, e, o, n) { void 0 === n && (n = o); var i = Object.getOwnPropertyDescriptor(e, o); i && !("get" in i ? !e.__esModule : i.writable || i.configurable) || (i = { enumerable: !0, get: function () { return e[o] } }), Object.defineProperty(t, n, i) } : function (t, e, o, n) { void 0 === n && (n = o), t[n] = e[o] }), r = this && this.__setModuleDefault || (Object.create ? function (t, e) { Object.defineProperty(t, "default", { enumerable: !0, value: e }) } : function (t, e) { t.default = e }), s = this && this.__importStar || (n = function (t) { return n = Object.getOwnPropertyNames || function (t) { var e = []; for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[e.length] = o); return e }, n(t) }, function (t) { if (t && t.__esModule) return t; var e = {}; if (null != t) for (var o = n(t), s = 0; s < o.length; s++)"default" !== o[s] && i(e, t, o[s]); return r(e, t), e }), a = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.Editor = void 0; const l = a(o(7)), c = a(o(4641)), d = o(2018), h = o(7394), u = a(o(1721)), p = a(o(4093)), f = a(o(9118)), m = o(5379), g = s(o(1606)), b = a(o(3604)), y = a(o(578)), v = a(o(2543)), x = a(o(6975)), w = a(o(8748)), S = a(o(6398)), T = a(o(2717)), C = a(o(1172)), P = a(o(6188)), k = s(o(2115)), E = a(o(4433)), z = a(o(5577)), M = a(o(1083)), _ = a(o(4212)), I = a(o(2832)), R = a(o(4690)), B = a(o(5711)), O = o(9261), L = s(o(7988)), D = a(o(410)), A = a(o(3718)), j = a(o(9988)), V = a(o(272)); class F { constructor(t, e = {}) { if (this.eventListenerTargets = [], this.previousAccessibilityAnnouncement = "", this.pointers = {}, this.announceUndoCallback = t => { this.announceForAccessibility(this.localization.undoAnnouncement(t.description(this, this.localization))) }, this.announceRedoCallback = t => { this.announceForAccessibility(this.localization.redoAnnouncement(t.description(this, this.localization))) }, this.nextRerenderListeners = [], this.rerenderQueued = !1, this.closeAboutDialog = null, this.localization = { ...(0, v.default)(), ...e.localization }, this.settings = { wheelEventsEnabled: e.wheelEventsEnabled ?? !0, renderingMode: e.renderingMode ?? g.RenderingMode.CanvasRenderer, localization: this.localization, minZoom: e.minZoom ?? 2e-10, maxZoom: e.maxZoom ?? 1e12, keyboardShortcutOverrides: e.keyboardShortcutOverrides ?? {}, iconProvider: e.iconProvider ?? new x.default, notices: e.notices ?? [], appInfo: e.appInfo ? { ...e.appInfo } : null, pens: { additionalPenTypes: e.pens?.additionalPenTypes ?? [], filterPenTypes: e.pens?.filterPenTypes ?? (() => !0) }, text: { fonts: e.text?.fonts ?? ["sans-serif", "serif", "monospace"] }, image: { showImagePicker: e.image?.showImagePicker ?? void 0 } }, this.settings.minZoom > this.settings.maxZoom) throw new Error("Minimum zoom must be lesser than maximum zoom!"); this.readOnly = L.MutableReactiveValue.fromInitialValue(!1), this.icons = this.settings.iconProvider, this.shortcuts = new z.default(this.settings.keyboardShortcutOverrides), this.container = document.createElement("div"), this.renderingRegion = document.createElement("div"), this.container.appendChild(this.renderingRegion), this.container.classList.add("imageEditorContainer", "js-draw"), this.loadingWarning = document.createElement("div"), this.loadingWarning.classList.add("loadingMessage"), this.loadingWarning.ariaLive = "polite", this.container.appendChild(this.loadingWarning), this.accessibilityControlArea = document.createElement("textarea"), this.accessibilityControlArea.setAttribute("placeholder", this.localization.accessibilityInputInstructions), this.accessibilityControlArea.style.opacity = "0", this.accessibilityControlArea.style.width = "0", this.accessibilityControlArea.style.height = "0", this.accessibilityControlArea.style.position = "absolute", this.accessibilityAnnounceArea = document.createElement("div"), this.accessibilityAnnounceArea.setAttribute("aria-live", "assertive"), this.accessibilityAnnounceArea.className = "accessibilityAnnouncement", this.container.appendChild(this.accessibilityAnnounceArea), this.renderingRegion.style.touchAction = "none", this.renderingRegion.className = "imageEditorRenderArea", this.renderingRegion.appendChild(this.accessibilityControlArea), this.renderingRegion.setAttribute("tabIndex", "0"), this.renderingRegion.setAttribute("alt", ""), this.notifier = new f.default, this.viewport = new p.default(((t, e) => { this.notifier.dispatch(d.EditorEventType.ViewportChanged, { kind: d.EditorEventType.ViewportChanged, newTransform: e, oldTransform: t }) })), this.display = new g.default(this, this.settings.renderingMode, this.renderingRegion), this.image = new l.default, this.history = new u.default(this, this.announceRedoCallback, this.announceUndoCallback), this.toolController = new c.default(this, this.localization), this.toolController.addInputMapper(_.default.fromEditor(this)), this.toolController.addInputMapper(new V.default), t.appendChild(this.container), this.viewport.updateScreenSize(m.Vec2.of(this.display.width, this.display.height)), this.registerListeners(), this.queueRerender(), this.hideLoadingWarning(), this.notifier.on(d.EditorEventType.ViewportChanged, (t => { if (t.kind !== d.EditorEventType.ViewportChanged) return; const e = t => t.transformVec3(m.Vec2.unitX).length(), o = e(t.newTransform); if (o > this.settings.maxZoom || o < this.settings.minZoom) { const o = e(t.oldTransform); let n = m.Mat33.identity; n = o <= this.settings.maxZoom && o >= this.settings.minZoom ? t.oldTransform : m.Mat33.scaling2D((this.settings.minZoom + this.settings.maxZoom) / 2), this.viewport.resetTransform(n) } else isFinite(o) || (console.warn(`Non-finite zoom (${o}) detected. Resetting the viewport. This was likely caused by division by zero.`), isFinite(e(t.oldTransform)) ? this.viewport.resetTransform(t.oldTransform) : this.viewport.resetTransform()) })) } getCurrentSettings() { return { ...this.settings } } getRootElement() { return this.container } getOutputBBoxInDOM() { return m.Rect2.of(this.renderingRegion.getBoundingClientRect()) } showLoadingWarning(t) { const e = Math.round(100 * t); this.loadingWarning.innerText = this.localization.loading(e), this.loadingWarning.style.display = "block" } hideLoadingWarning() { this.loadingWarning.style.display = "none", this.announceForAccessibility(this.localization.doneLoading) } announceForAccessibility(t) { t === this.previousAccessibilityAnnouncement && (t += ". "), this.accessibilityAnnounceArea.innerText = t, this.previousAccessibilityAnnouncement = t } addToolbar(t = !0) { const e = new M.default(this, this.container, this.localization); return t && e.addDefaults(), e } registerListeners() { this.handlePointerEventsFrom(this.renderingRegion), this.handleKeyEventsFrom(this.renderingRegion), this.handlePointerEventsFrom(this.accessibilityAnnounceArea); const t = [this.renderingRegion, this.accessibilityAnnounceArea, this.accessibilityControlArea, this.loadingWarning]; for (const e of t) e.addEventListener("drag", (t => (t.preventDefault(), !1))), e.addEventListener("dragstart", (t => (t.preventDefault(), !1))); this.container.addEventListener("wheel", (t => { this.handleHTMLWheelEvent(t) })); const e = () => { this.viewport.updateScreenSize(m.Vec2.of(this.display.width, this.display.height)), this.rerender(), this.updateEditorSizeVariables() }; if ("ResizeObserver" in window) { const t = new ResizeObserver(e); t.observe(this.renderingRegion), t.observe(this.container) } else addEventListener("resize", e); this.accessibilityControlArea.addEventListener("input", (() => { this.accessibilityControlArea.value = "" })); const o = new j.default(this); document.addEventListener("copy", (async t => { this.isEventSink(document.querySelector(":focus")) && o.copy(t) })), document.addEventListener("paste", (t => { this.handlePaste(t) })) } updateEditorSizeVariables() { this.container.style.setProperty("--editor-current-width-px", `${this.container.clientWidth}px`), this.container.style.setProperty("--editor-current-height-px", `${this.container.clientHeight}px`), this.container.style.setProperty("--editor-current-display-width-px", `${this.renderingRegion.clientWidth}px`), this.container.style.setProperty("--editor-current-display-height-px", `${this.renderingRegion.clientHeight}px`) } handleHTMLWheelEvent(t) { let e = m.Vec3.of(t.deltaX, t.deltaY, t.deltaZ); if (!t.ctrlKey && !t.metaKey) { if (!this.settings.wheelEventsEnabled) return; if ("only-if-focused" === this.settings.wheelEventsEnabled) { if (!this.container.querySelector(":focus")) return } } t.deltaMode === WheelEvent.DOM_DELTA_LINE ? e = e.times(15) : t.deltaMode === WheelEvent.DOM_DELTA_PAGE && (e = e.times(100)), (t.ctrlKey || t.metaKey) && (e = m.Vec3.of(0, 0, t.deltaY)); const o = this.getOutputBBoxInDOM(), n = m.Vec2.of(t.clientX, t.clientY).minus(o.topLeft); return !!this.toolController.dispatchInputEvent({ kind: h.InputEvtType.WheelEvt, delta: e, screenPos: n }) && (t.preventDefault(), !0) } getPointerList() { const t = performance.now(), e = []; for (const o in this.pointers) { const n = 2e3; this.pointers[o] && t - this.pointers[o].timeStamp < n && e.push(this.pointers[o]) } return e } setPointerCapture(t, e) { try { t.setPointerCapture(e) } catch (t) { console.warn("Failed to setPointerCapture", t) } } releasePointerCapture(t, e) { try { t.releasePointerCapture(e) } catch (t) { console.warn("Failed to releasePointerCapture", t) } } handleHTMLPointerEvent(t, e) { const o = this.renderingRegion, n = e.target ?? this.renderingRegion; if ("pointerdown" === t) { const t = y.default.ofEvent(e, !0, this.viewport, o); this.pointers[t.id] = t, this.setPointerCapture(n, t.id); const i = { kind: h.InputEvtType.PointerDownEvt, current: t, allPointers: this.getPointerList() }; return this.toolController.dispatchInputEvent(i), !0 } if ("pointermove" === t) { const t = y.default.ofEvent(e, this.pointers[e.pointerId]?.down ?? !1, this.viewport, o); if (t.down) { const o = this.pointers[t.id]; if (o) { if (t.screenPos.distanceTo(o.screenPos) < 2) return !1 } this.pointers[t.id] = t, this.toolController.dispatchInputEvent({ kind: h.InputEvtType.PointerMoveEvt, current: t, allPointers: this.getPointerList() }) && e.preventDefault() } return !0 } if ("pointercancel" === t || "pointerup" === t) { const t = y.default.ofEvent(e, !1, this.viewport, o); return !!this.pointers[t.id] && (this.pointers[t.id] = t, this.releasePointerCapture(n, t.id), this.toolController.dispatchInputEvent({ kind: h.InputEvtType.PointerUpEvt, current: t, allPointers: this.getPointerList() }) && e.preventDefault(), delete this.pointers[t.id], !0) } return t } isEventSink(t) { let e = t; for (; null !== e;) { for (const t of this.eventListenerTargets) if (t === e) return !0; e = e.parentElement } return !1 } async handleDrop(t) { t.preventDefault(), await this.handlePaste(t) } async handlePaste(t) { const e = document.querySelector(":focus") ?? t.target; if (this.isEventSink(e)) return await new j.default(this).paste(t) } handlePointerEventsFrom(t, e, o) { const n = { touchstart: t => { o && !o("touchstart", t) || t.preventDefault() }, contextmenu: t => { o && !o("contextmenu", t) || t.preventDefault() } }, i = ["pointerdown", "pointermove", "pointerup", "pointercancel"]; for (const t of i) n[t] = o => { const n = o; if (!e || e(t, n)) return this.handleHTMLPointerEvent(t, n) }; for (const e in n) t.addEventListener(e, n[e]); return { remove: () => { for (const e in n) t.removeEventListener(e, n[e]) } } } handlePointerEventsExceptClicksFrom(t, e, o) { const n = Object.create(null); return this.handlePointerEventsFrom(t, ((o, i) => { if (e && !e(o, i)) return !1; const r = m.Vec2.of(i.pageX ?? i.clientX, i.pageY ?? i.clientY), s = i.pointerId ?? 0; let a = !0; if ("pointerdown" === o) n[s] = { eventBuffer: [[o, i]], startPoint: r, hasMovedSignificantly: !1 }, this.setPointerCapture(t, i.pointerId), a = !1; else if ("pointermove" === o && n[s]) { const t = n[s].startPoint, e = n[s].eventBuffer, l = 10; if (t && r.distanceTo(t) < l && !n[s].hasMovedSignificantly) e.push([o, i]), a = !1; else { for (const [t, o] of e) this.handleHTMLPointerEvent(t, o); n[s].eventBuffer = [], n[s].hasMovedSignificantly = !0, a = !0 } } else "pointermove" === o ? a = !0 : ("pointerup" === o || "pointercancel" === o) && n[s] && n[s].eventBuffer.length > 0 && (this.releasePointerCapture(t, i.pointerId), a = !1, delete n[s]); return a }), o) } handleHTMLKeyDownEvent(t) { console.assert("keydown" === t.type, `handling a keydown event with type ${t.type}`); const e = (0, h.keyPressEventFromHTMLEvent)(t); return this.toolController.dispatchInputEvent(e) ? (t.preventDefault(), !0) : "t" === e.key || "T" === e.key ? (t.preventDefault(), this.display.rerenderAsText(), !0) : "Escape" === e.key && (this.renderingRegion.blur(), !0) } handleHTMLKeyUpEvent(t) { console.assert("keyup" === t.type, `Handling a keyup event with type ${t.type}`); const e = (0, h.keyUpEventFromHTMLEvent)(t); return !!this.toolController.dispatchInputEvent(e) && (t.preventDefault(), !0) } handleKeyEventsFrom(t, e = (() => !0)) { (0, D.default)(t, { filter: e, handleKeyDown: t => { this.handleHTMLKeyDownEvent(t) }, handleKeyUp: t => { this.handleHTMLKeyUpEvent(t) }, getHandlesKeyEventsFrom: t => this.eventListenerTargets.includes(t) }), t.ondragover = t => { t.preventDefault() }, t.ondrop = t => { this.handleDrop(t) }, this.eventListenerTargets.push(t) } setReadOnly(t) { t !== this.readOnly.get() && (this.readOnly.set(t), this.notifier.dispatch(d.EditorEventType.ReadOnlyModeToggled, { kind: d.EditorEventType.ReadOnlyModeToggled, editorIsReadOnly: t })) } isReadOnlyReactiveValue() { return this.readOnly } isReadOnly() { return this.readOnly } dispatch(t, e = !0) { const o = this.dispatchNoAnnounce(t, e), n = t.description(this, this.localization); return this.announceForAccessibility(n), o } dispatchNoAnnounce(t, e = !1) { const o = t.apply(this); if (e) { const e = !1; this.history.push(t, e) } return o } async asyncApplyOrUnapplyCommands(t, e, o) { console.assert(o > 0), this.display.setDraftMode(!0); for (let n = 0; n < t.length; n += o) { this.showLoadingWarning(n / t.length); for (let i = n; i < t.length && i < n + o; i++) { const o = t[i]; e ? o.apply(this) : o.unapply(this) } n + o < t.length && await new Promise((t => { this.rerender(), requestAnimationFrame(t) })) } this.display.setDraftMode(!1), this.hideLoadingWarning() } asyncApplyCommands(t, e) { return this.asyncApplyOrUnapplyCommands(t, !0, e) } asyncUnapplyCommands(t, e, o = !1) { return o && (t = [...t]).reverse(), this.asyncApplyOrUnapplyCommands(t, !1, e) } queueRerender() { return this.rerenderQueued || (this.rerenderQueued = !0, requestAnimationFrame((() => { this.rerenderQueued && (this.rerender(), this.rerenderQueued = !1) }))), new Promise((t => { this.nextRerenderListeners.push((() => t())) })) } isRerenderQueued() { return this.rerenderQueued } rerender(t = !0) { if (this.display.startRerender(), 0 === this.display.width || 0 === this.display.height) return; const e = this.display.getDryInkRenderer(); if (this.image.renderWithCache(e, this.display.getCache(), this.viewport), t && !this.image.getAutoresizeEnabled()) { const t = { fill: m.Color4.fromHex("#44444455") }, o = 5 * this.viewport.getSizeOfPixelOnCanvas(); e.drawRect(this.getImportExportRect(), o, t) } this.rerenderQueued = !1, this.nextRerenderListeners.forEach((t => t())), this.nextRerenderListeners = [] } drawWetInk(...t) { for (const e of t) this.display.getWetInkRenderer().drawPath(e) } clearWetInk() { this.display.getWetInkRenderer().clear() } focus() { this.renderingRegion.focus() } createHTMLOverlay(t) { return t.classList.add("overlay", "js-draw-editor-overlay"), this.container.appendChild(t), { remove: () => t.remove() } } anchorElementToCanvas(t, e) { e instanceof m.Mat33 && (e = L.default.fromImmutable(e)); const o = document.createElement("div"); o.classList.add("anchored-element-overlay"); const n = document.createElement("div"); n.classList.add("content-wrapper"), t.classList.add("content"); const i = () => { const t = e.get().transformVec3(m.Vec2.unitX).angle() + this.viewport.getRotationAngle(), n = this.viewport.canvasToScreenTransform.rightMul(e.get()); o.style.setProperty("--full-transform", n.toCSSMatrix()); const i = n.transformVec2(m.Vec2.zero); o.style.setProperty("--position-x", `${i.x}px`), o.style.setProperty("--position-y", `${i.y}px`), o.style.setProperty("--rotation", 180 * t / Math.PI + "deg"), o.style.setProperty("--scale", `${n.getScaleFactor()}`) }; i(); const r = e.onUpdate(i), s = this.notifier.on(d.EditorEventType.ViewportChanged, i); return n.appendChild(t), o.appendChild(n), o.classList.add("overlay", "js-draw-editor-overlay"), this.renderingRegion.insertAdjacentElement("afterend", o), { remove: () => { o.remove(), r.remove(), s.remove() } } } addStyleSheet(t) { const e = document.createElement("style"); return e.innerText = t, this.container.appendChild(e), e } sendKeyboardEvent(t, e, o = !1, n = !1, i = void 0) { i ??= e.toUpperCase() === e && e.toLowerCase() !== e, this.toolController.dispatchInputEvent({ kind: t, key: e, code: (0, I.default)(e), ctrlKey: o, altKey: n, shiftKey: i }) } sendPenEvent(t, e, o) { (0, E.default)(this, t, e, o) } async addAndCenterComponents(t, e = !0, o) { let n = null; for (const e of t) n = n ? n.union(e.getBBox()) : e.getBBox(); if (!n) return; const i = this.viewport.visibleRect, r = i.width / n.width, s = i.height / n.height; let a = r; (n.width * a > i.width || n.height * a > i.height) && (a = s), a *= 2 / 3, a = p.default.roundScaleRatio(a); const c = m.Mat33.translation(i.center.minus(n.center)).rightMul(m.Mat33.scaling2D(a, n.center)), d = []; for (const e of t) d.push(l.default.addElement(e)), d.push(e.transformBy(c)); if (await this.dispatch((0, T.default)(d, { applyChunkSize: 100, description: o }), !0), e) for (const e of this.toolController.getMatchingTools(C.default)) e.setEnabled(!0), e.setSelection(t) } toDataURL(t = "image/png", e) { const { element: o, renderer: n } = w.default.fromViewport(this.image.getImportExportViewport(), { canvasSize: e }); this.image.renderAll(n); return o.toDataURL(t) } toSVG(t) { return (0, O.editorImageToSVGSync)(this.image, t ?? {}) } async toSVGAsync(t = {}) { const e = t.pauseAfterCount ?? 100; return await (0, O.editorImageToSVGAsync)(this.image, (async (o, n, i) => { if (t.onProgress) { if (!1 === await t.onProgress(n, i)) return !1 } return n % e == 0 && await (0, S.default)(), !0 }), { minDimension: t.minDimension }) } async loadFrom(t) { this.showLoadingWarning(0), this.display.setDraftMode(!0); const e = this.image.getBackgroundComponents(), o = new P.default(e); await t.start((async t => { await this.dispatchNoAnnounce(l.default.addElement(t)) }), ((t, e) => t % 500 == 0 ? (this.showLoadingWarning(t / e), this.rerender(), (0, S.default)()) : null), ((t, e) => { this.dispatchNoAnnounce(this.setImportExportRect(t), !1), this.dispatchNoAnnounce(this.viewport.zoomTo(t), !1), e && this.dispatchNoAnnounce(this.image.setAutoresizeEnabled(e.autoresize), !1) })), this.image.getBackgroundComponents().length !== e.length && await this.dispatchNoAnnounce(o), this.hideLoadingWarning(), this.display.setDraftMode(!1), this.queueRerender() } getTopmostBackgroundComponent() { let t = null; for (const e of this.image.getBackgroundComponents()) e instanceof k.default && (t = e); return t } setBackgroundStyle(t) { const e = this.getTopmostBackgroundComponent(), o = []; e && o.push(new P.default([e])); const n = e?.getBackgroundType?.() ?? k.BackgroundType.None, i = e?.getStyle?.().color ?? m.Color4.transparent, r = this.image.getAutoresizeEnabled(), s = t.color && n === k.BackgroundType.None ? k.BackgroundType.SolidColor : n, a = t.type ?? s, c = t.color ?? i, d = t.autoresize ?? r; if (a !== k.BackgroundType.None) { const t = new k.default(a, c); o.push(l.default.addElement(t)) } return d !== r && (o.push(this.image.setAutoresizeEnabled(d)), d || 0 !== this.image.getImportExportRect().maxDimension || o.push(this.image.setImportExportRect(this.image.getImportExportRect().resizedTo(m.Vec2.of(500, 500))))), (0, T.default)(o) } setBackgroundColor(t) { let e = this.getTopmostBackgroundComponent(); if (e) return e.updateStyle({ color: t }); { const o = t.eq(m.Color4.transparent) ? k.BackgroundType.None : k.BackgroundType.SolidColor; return e = new k.default(o, t), this.image.addElement(e) } } estimateBackgroundColor() { const t = []; for (const e of this.image.getBackgroundComponents()) e instanceof k.default && t.push(e.getStyle().color ?? m.Color4.transparent); return m.Color4.average(t) } getImportExportRect() { return this.image.getImportExportViewport().visibleRect } setImportExportRect(t) { return this.image.setImportExportRect(t) } async loadFromSVG(t, e = !1) { const o = b.default.fromString(t, e); await this.loadFrom(o) } showAboutDialog() { const t = this.icons.licenseInfo(), e = []; if (this.settings.appInfo) { const t = []; this.settings.appInfo.version && t.push(`v${this.settings.appInfo.version}`, ""), this.settings.appInfo.description ? t.push(this.settings.appInfo.description + "\n") : t.push(`js-draw v${B.default.number}`), e.push({ heading: `${this.settings.appInfo.name}`, text: t.join("\n") }) } else e.push({ heading: "js-draw", text: `v${B.default.number}` }); const o = this.viewport.getScreenRectSize(); e.push({ heading: this.localization.developerInformation, text: ["Image debug information (from when this dialog was opened):", `    ${this.viewport.getScaleFactor()}x zoom, ${180 / Math.PI * this.viewport.getRotationAngle()}° rotation`, `    ${this.image.estimateNumElements()} components`, "    auto-resize: " + (this.image.getAutoresizeEnabled() ? "enabled" : "disabled"), `    image size: ${this.getImportExportRect().w}x${this.getImportExportRect().h}`, `    screen size: ${o.x}x${o.y}`, `    device pixel ratio: ${this.display.getDevicePixelRatio()}`, "    cache:", `        ${this.display.getCache().getDebugInfo().replace(/([\n])/g, "\n        ")}`].join("\n"), minimized: !0 }), e.push({ heading: this.localization.softwareLibraries, text: [`This image editor is powered by js-draw v${B.default.number}.`, "", "At runtime, js-draw uses", " - The Coloris color picker: https://github.com/mdbassit/Coloris", " - The bezier.js Bézier curve library: https://github.com/Pomax/bezierjs", "", "Both are licensed under the MIT license:", "", "", "== Coloris ==", (0, A.default)("2021 Mohammed Bassit"), "", "", "== Bezier.js ==", (0, A.default)('2023 Mike "Pomax" Kamermans'), "", "", "== js-draw ==", (0, A.default)("2023-2024 Henry Heino"), ""].join("\n"), minimized: !0 }), t && e.push({ heading: "Icon Pack", text: t, minimized: !0 }), e.push(...this.settings.notices), this.closeAboutDialog?.(), this.closeAboutDialog = (0, R.default)(this, e).close } remove() { this.container.remove(), this.toolController.onEditorDestroyed() } } e.Editor = F, e.default = F }, 9118: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); e.default = class { constructor() { this.listeners = {} } dispatch(t, e) { const o = this.listeners[t]; if (o) for (let t = 0; t < o.length; t++)o[t](e) } on(t, e) { return this.listeners[t] || (this.listeners[t] = []), this.listeners[t].push(e), { remove: () => { const o = this.listeners[t]; return this.off(t, e), o.length !== this.listeners[t].length } } } off(t, e) { const o = this.listeners[t]; o && (this.listeners[t] = o.filter((t => t !== e))) } } }, 578: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.PointerDevice = void 0; const n = o(5379); var i; !function (t) { t[t.Pen = 0] = "Pen", t[t.Eraser = 1] = "Eraser", t[t.Touch = 2] = "Touch", t[t.PrimaryButtonMouse = 3] = "PrimaryButtonMouse", t[t.RightButtonMouse = 4] = "RightButtonMouse", t[t.Other = 5] = "Other" }(i || (e.PointerDevice = i = {})); class r { constructor(t, e, o, n, i, r, s, a) { this.screenPos = t, this.canvasPos = e, this.pressure = o, this.isPrimary = n, this.down = i, this.device = r, this.id = s, this.timeStamp = a } snappedToGrid(t) { const e = t.snapToGrid(this.canvasPos); return this.withCanvasPosition(e, t) } lockedToXYAxesScreen(t, e) { const o = this.screenPos.minus(t), i = n.Vec2.unitX.times(o.x), r = n.Vec2.unitY.times(o.y); let s; return s = o.dot(i) > o.dot(r) ? i : r, s = s.plus(t), this.withScreenPosition(s, e) } withScreenPosition(t, e) { const o = e.screenToCanvas(t); return this.withCanvasPosition(o, e) } withTimestamp(t) { return new r(this.screenPos, this.canvasPos, this.pressure, this.isPrimary, this.down, this.device, this.id, t) } withCanvasPosition(t, e) { const o = e.canvasToScreen(t); return new r(o, t, this.pressure, this.isPrimary, this.down, this.device, this.id, this.timeStamp) } static ofEvent(t, e, o, s) { let a = n.Vec2.of(t.clientX, t.clientY); if (s) { const t = s.getBoundingClientRect(); a = a.minus(n.Vec2.of(t.left, t.top)) } let l = { mouse: i.PrimaryButtonMouse, pen: i.Pen, touch: i.Touch }[t.pointerType] ?? i.Other; l === i.Pen && 32 & t.buttons && (l = i.Eraser); const c = t.timeStamp, d = o.roundPoint(o.screenToCanvas(a)); return l === i.PrimaryButtonMouse && 2 & t.buttons && (l = i.RightButtonMouse), new r(a, d, t.pressure ?? null, t.isPrimary, e, l, t.pointerId, c) } static ofCanvasPoint(t, e, o, n = 0, s = i.Pen, a = !0, l = null, c = null) { const d = o.canvasToScreen(t); return c ??= performance.now(), new r(d, t, l, a, e, s, n, c) } static ofScreenPoint(t, e, o, n = 0, s = i.Pen, a = !0, l = null, c = null) { const d = o.screenToCanvas(t); return c ??= performance.now(), new r(t, d, l, a, e, s, n, c) } } e.default = r }, 3604: function (t, e, o) { "use strict"; var n, i = this && this.__createBinding || (Object.create ? function (t, e, o, n) { void 0 === n && (n = o); var i = Object.getOwnPropertyDescriptor(e, o); i && !("get" in i ? !e.__esModule : i.writable || i.configurable) || (i = { enumerable: !0, get: function () { return e[o] } }), Object.defineProperty(t, n, i) } : function (t, e, o, n) { void 0 === n && (n = o), t[n] = e[o] }), r = this && this.__setModuleDefault || (Object.create ? function (t, e) { Object.defineProperty(t, "default", { enumerable: !0, value: e }) } : function (t, e) { t.default = e }), s = this && this.__importStar || (n = function (t) { return n = Object.getOwnPropertyNames || function (t) { var e = []; for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[e.length] = o); return e }, n(t) }, function (t) { if (t && t.__esModule) return t; var e = {}; if (null != t) for (var o = n(t), s = 0; s < o.length; s++)"default" !== o[s] && i(e, t, o[s]); return r(e, t), e }), a = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.SVGLoaderLoadMethod = e.svgLoaderAutoresizeClassName = e.svgLoaderAttributeContainerID = e.svgStyleAttributesDataKey = e.svgAttributesDataKey = e.defaultSVGViewRect = void 0; const l = o(5379), c = s(o(2115)), d = a(o(4686)), h = a(o(2066)), u = a(o(67)), p = s(o(2170)), f = a(o(3405)), m = o(8258), g = o(1598), b = a(o(4482)); var y; e.defaultSVGViewRect = new l.Rect2(0, 0, 500, 500), e.svgAttributesDataKey = "svgAttrs", e.svgStyleAttributesDataKey = "svgStyleAttrs", e.svgLoaderAttributeContainerID = "svgContainerID", e.svgLoaderAutoresizeClassName = "js-draw--autoresize", function (t) { t.IFrame = "iframe", t.DOMParser = "domparser" }(y || (e.SVGLoaderLoadMethod = y = {})); const v = ["stroke", "fill", "stroke-width"]; class x { constructor(t, e, o) { this.source = t, this.onFinish = e, this.onAddComponent = null, this.onProgress = null, this.onDetermineExportRect = null, this.processedCount = 0, this.totalToProcess = 0, this.containerGroupIDs = [], this.encounteredIDs = [], this.storeUnknown = !o.sanitize, this.disableUnknownObjectWarnings = !!o.disableUnknownObjectWarnings } getStyle(t, e) { let o, n = l.Color4.transparent; const i = t.getAttribute("fill") ?? (e?.fill || t.style?.fill); if (i) try { n = l.Color4.fromString(i) } catch { console.error("Unknown fill color,", i) } const r = t.getAttribute("stroke") ?? e?.stroke ?? t.style?.stroke ?? "", s = t.getAttribute("stroke-width") ?? e?.strokeWidth ?? t.style?.strokeWidth ?? ""; if (r && s) try { let t = parseFloat(s ?? "1"); isFinite(t) || (t = 0); const e = l.Color4.fromString(r); e.a > 0 && (o = { width: t, color: e }) } catch (t) { console.error("Error parsing stroke data:", t) } return { fill: n, stroke: o } } strokeDataFromElem(t) { const e = [], o = t.getAttribute("d") ?? "", n = this.getStyle(t), i = o.split("M"); let r = !0; for (const t of i) { const o = /^[0-9., \t\n]+$/.exec(t); if ("" !== t && !o) { const o = r ? t : `M${t}`, i = l.Path.fromString(o), s = (0, m.pathToRenderable)(i, n); e.push(s) } r = !1 } return e } attachUnrecognisedAttrs(t, o, n, i) { if (this.storeUnknown) { for (const r of o.getAttributeNames()) n.has(r) || "style" === r && i || t.attachLoadSaveData(e.svgAttributesDataKey, [r, o.getAttribute(r)]); if (i && o.style) for (let n = 0; n < o.style.length; n++) { const r = o.style[n]; "" !== r && r && (i.has(r) || t.attachLoadSaveData(e.svgStyleAttributesDataKey, { key: r, value: o.style.getPropertyValue(r), priority: o.style.getPropertyPriority(r) })) } } } async addPath(t) { let e; try { const o = this.strokeDataFromElem(t); e = new h.default(o), this.attachUnrecognisedAttrs(e, t, new Set([...v, "d"]), new Set(v)) } catch (o) { if (console.error("Invalid path in node", t, "\nError:", o, "\nAdding as an unknown object."), !this.storeUnknown) return; e = new f.default(t) } await this.addComponent(e) } async addBackground(t) { if (t.classList.contains(c.backgroundTypeToClassNameMap[c.BackgroundType.Grid])) { let e, o, n, i, r; if ("g" === t.tagName.toLowerCase()) { if (2 !== t.children.length) return void await this.addUnknownNode(t); const i = t.children[0], r = t.children[1]; o = i.getAttribute("fill"), e = r.getAttribute("stroke"), n = r.getAttribute("stroke-width") } else o = t.getAttribute("fill"), e = t.getAttribute("stroke"), n = t.getAttribute("stroke-width"); if (o ??= l.Color4.transparent.toHexString(), !e) return void await this.addUnknownNode(t); for (const e of t.classList) if (e.startsWith(c.imageBackgroundGridSizeCSSPrefix)) { const t = e.substring(c.imageBackgroundGridSizeCSSPrefix.length); i = parseFloat(t.replace(/p/g, ".")) } n && (r = parseFloat(n)); const s = l.Color4.fromString(o); let a = l.Color4.fromString(e); t.classList.contains(c.imageBackgroundNonAutomaticSecondaryColorCSSClassName) || (a = void 0); const d = c.default.ofGrid(s, i, a, r); await this.addComponent(d) } else if ("path" === t.tagName.toLowerCase()) { const e = l.Color4.fromString(t.getAttribute("fill") ?? t.style.fill ?? "black"), o = new c.default(c.BackgroundType.SolidColor, e); await this.addComponent(o) } else await this.addUnknownNode(t) } getComputedStyle(t) { try { return window.getComputedStyle(t) } catch (t) { return void console.warn("Error computing style", t) } } getTransform(t, e, o) { const n = "data-highp-transform", i = t.getAttribute(n); let r; if (i) try { r = l.Mat33.fromCSSMatrix(i), e?.push(n) } catch (t) { console.warn(`Unable to parse raw transform data, ${i}. Falling back to CSS data. Error:`, t) } if (!r) { o ??= this.getComputedStyle(t); let n = o?.transform; n && "none" !== n || (n = t.style?.transform || "none"); try { r = l.Mat33.fromCSSMatrix(t.style.transform) } catch (t) { console.warn("matrix parse error", t), r = l.Mat33.fromCSSMatrix(n) } const i = t.getAttribute("x"), s = t.getAttribute("y"); if (i || s) { const t = parseFloat(i ?? "0"), o = parseFloat(s ?? "0"); isNaN(t) || isNaN(o) || (e?.push("x", "y"), r = r.rightMul(l.Mat33.translation(l.Vec2.of(t, o)))) } } return r } makeText(t) { const e = []; for (const o of t.childNodes) if (o.nodeType === Node.TEXT_NODE) e.push(o.nodeValue ?? ""); else { if (o.nodeType !== Node.ELEMENT_NODE) throw new Error(`Unrecognized text child node: ${o}.`); { const t = o; if ("tspan" !== t.tagName.toLowerCase()) throw new Error(`Unrecognized text child element: ${t}`); e.push(this.makeText(t)) } } 0 === e.length && e.push(""); const o = this.getComputedStyle(t), n = new Set(["fontFamily", "transform", ...v]), i = { size: (0, b.default)(t, o, n), fontFamily: o?.fontFamily || t.style?.fontFamily || "sans-serif", fontWeight: o?.fontWeight || t.style?.fontWeight || void 0, fontStyle: o?.fontStyle || t.style?.fontStyle || void 0, renderingStyle: this.getStyle(t, o) }, r = []; let s = this.getTransform(t, r, o), a = p.TextTransformMode.ABSOLUTE_XY; const c = t.getAttribute("dx"); c && (a = p.TextTransformMode.RELATIVE_X_ABSOLUTE_Y, s = s.rightMul(l.Mat33.translation(l.Vec2.of(parseFloat(c), 0))), r.push("dx")); const d = t.getAttribute("dy"); d && (a = a === p.TextTransformMode.RELATIVE_X_ABSOLUTE_Y ? p.TextTransformMode.RELATIVE_XY : p.TextTransformMode.RELATIVE_Y_ABSOLUTE_X, s = s.rightMul(l.Mat33.translation(l.Vec2.of(0, parseFloat(d)))), r.push("dy")); const h = new p.default(e, s, i, a); return this.attachUnrecognisedAttrs(h, t, new Set(r), new Set(n)), h } async addText(t) { try { const e = this.makeText(t); await this.addComponent(e) } catch (e) { console.error("Invalid text object in node", t, ". Continuing.... Error:", e), this.addUnknownNode(t) } } async addImage(t) { const e = new Image; e.src = t.getAttribute("xlink:href") ?? t.href.baseVal, e.setAttribute("alt", t.getAttribute("aria-label") ?? ""); try { const o = [], n = this.getTransform(t, o), i = await d.default.fromImage(e, n); this.attachUnrecognisedAttrs(i, t, new Set(o), new Set(["transform"])), await this.addComponent(i) } catch (e) { console.error("Error loading image:", e, ". Element: ", t, ". Continuing..."), await this.addUnknownNode(t) } } async addUnknownNode(t) { if (this.storeUnknown) { const e = new f.default(t); await this.addComponent(e) } } async startGroup(t) { let e = (t = t.cloneNode(!1)).id || `id-${this.encounteredIDs.length}`, o = 0, n = ""; for (; this.encounteredIDs.includes(e + n);)o++, n = "--" + o; e += n, t.replaceChildren(), t.id = e; const i = new f.default(t); this.addComponent(i), this.containerGroupIDs.push(t.id), this.encounteredIDs.push(t.id) } async endGroup() { this.containerGroupIDs.pop() } async addComponent(t) { this.containerGroupIDs.length > 0 && t.attachLoadSaveData(e.svgLoaderAttributeContainerID, [...this.containerGroupIDs]), await (this.onAddComponent?.(t)) } updateViewBox(t) { const o = t.getAttribute("viewBox"); if (this.rootViewBox || !o) return; const n = o.split(/[ \t\n,]+/), i = parseFloat(n[0]), r = parseFloat(n[1]), s = parseFloat(n[2]), a = parseFloat(n[3]); if (isNaN(i) || isNaN(r) || isNaN(s) || isNaN(a)) return void console.warn(`node ${t} has an unparsable viewbox. Viewbox: ${o}. Match: ${n}.`); const c = t.classList.contains(e.svgLoaderAutoresizeClassName); this.rootViewBox = new l.Rect2(i, r, s, a), this.onDetermineExportRect?.(this.rootViewBox, { autoresize: c }) } async updateSVGAttrs(t) { this.storeUnknown && await (this.onAddComponent?.(new u.default(this.getSourceAttrs(t)))) } async visit(t) { this.totalToProcess += t.childElementCount; let e = !0; switch (t.tagName.toLowerCase()) { case "g": t.classList.contains(c.imageBackgroundCSSClassName) ? (await this.addBackground(t), e = !1) : await this.startGroup(t); break; case "path": t.classList.contains(c.imageBackgroundCSSClassName) ? await this.addBackground(t) : await this.addPath(t); break; case "text": await this.addText(t), e = !1; break; case "image": await this.addImage(t), e = !1; break; case "svg": this.updateViewBox(t), this.updateSVGAttrs(t); break; case "style": t.getAttribute("id") !== g.renderedStylesheetId && await this.addUnknownNode(t); break; default: return this.disableUnknownObjectWarnings || (console.warn("Unknown SVG element,", t, t.tagName), t instanceof SVGElement || console.warn("Element", t, "is not an SVGElement!", this.storeUnknown ? "Continuing anyway." : "Skipping.")), void await this.addUnknownNode(t) }if (e) { for (const e of t.children) await this.visit(e); "g" === t.tagName.toLowerCase() && await this.endGroup() } this.processedCount++, await (this.onProgress?.(this.processedCount, this.totalToProcess)) } getSourceAttrs(t) { return t.getAttributeNames().map((e => [e, t.getAttribute(e)])) } async start(t, o, n = null) { this.onAddComponent = t, this.onProgress = o, this.onDetermineExportRect = n, this.totalToProcess = this.source.childElementCount, this.processedCount = 0, this.rootViewBox = null, await this.visit(this.source); this.rootViewBox || this.onDetermineExportRect?.(e.defaultSVGViewRect), this.onFinish?.(), this.onFinish = null } static fromString(t, e = !1) { const o = "boolean" != typeof e && e?.loadMethod === y.DOMParser, { svgElem: n, cleanUp: i } = (() => { if (!o) try { const e = document.createElement("iframe"); if (e.src = "about:blank", e.setAttribute("sandbox", "allow-same-origin"), e.setAttribute("csp", "default-src 'about:blank'"), e.style.display = "none", document.body.appendChild(e), !e.hasAttribute("sandbox")) throw e.remove(), new Error("SVG loading iframe is not sandboxed."); const o = e.contentWindow?.document ?? e.contentDocument; if (null == o) throw new Error("Unable to open a sandboxed iframe!"); o.open(), o.write("\n\t\t\t\t\t\t<!DOCTYPE html>\n\t\t\t\t\t\t<html>\n\t\t\t\t\t\t\t<head>\n\t\t\t\t\t\t\t\t<title>SVG Loading Sandbox</title>\n\t\t\t\t\t\t\t\t<meta name='viewport' conent='width=device-width,initial-scale=1.0'/>\n\t\t\t\t\t\t\t\t<meta charset='utf-8'/>\n\t\t\t\t\t\t\t</head>\n\t\t\t\t\t\t\t<body style='font-size: 12px;'>\n\t\t\t\t\t\t\t\t<script>\n\t\t\t\t\t\t\t\t\tconsole.error('JavaScript should not be able to run here!');\n\t\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\t'The SVG sandbox is broken! Please double-check the sandboxing setting.'\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t<\/script>\n\t\t\t\t\t\t\t</body>\n\t\t\t\t\t\t</html>\n\t\t\t\t\t"), o.close(); const n = o.createElementNS("http://www.w3.org/2000/svg", "svg"); n.innerHTML = t, o.body.appendChild(n); const i = () => { n.remove(), e.remove(), e.src = "" }; return { svgElem: n, cleanUp: i } } catch (t) { console.warn("Failed loading SVG via a sandboxed iframe. Some styles may not be loaded correctly. Error: ", t) } const e = (new DOMParser).parseFromString(`<svg xmlns="http://www.w3.org/2000/svg">${t}</svg>`, "text/html"), n = e.querySelector("svg"), i = e.querySelector("parsererror"); if (i) throw new Error("Parse error: " + i.textContent); return { svgElem: n, cleanUp: () => { } } })(); let r, s; return "boolean" == typeof e ? (r = e, s = !1) : (r = e.sanitize ?? !1, s = e.disableUnknownObjectWarnings ?? !1), new x(n, i, { sanitize: r, disableUnknownObjectWarnings: s }) } } e.default = x }, 4482: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); e.default = (t, e, o) => { const n = /^([-0-9.e]+)px/i; let i = n.exec(t.style?.fontSize ?? ""); !i && "tspan" === t.tagName.toLowerCase() && t.parentElement && (i = n.exec(t.parentElement.style?.fontSize ?? "")), !i && e && (i = n.exec(e.fontSize)); let r = 12; return i && (o.add("fontSize"), r = parseFloat(i[1])), r } }, 1721: function (t, e, o) { "use strict"; var n, i, r = this && this.__classPrivateFieldSet || function (t, e, o, n, i) { if ("m" === n) throw new TypeError("Private method is not writable"); if ("a" === n && !i) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof e ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === n ? i.call(t, o) : i ? i.value = o : e.set(t, o), o }, s = this && this.__classPrivateFieldGet || function (t, e, o, n) { if ("a" === o && !n) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === o ? n : "a" === o ? n.call(t) : n ? n.value : e.get(t) }; Object.defineProperty(e, "__esModule", { value: !0 }); const a = o(2018); n = new WeakMap, i = new WeakMap, e.default = class { constructor(t, e, o) { this.editor = t, this.announceRedoCallback = e, this.announceUndoCallback = o, n.set(this, void 0), i.set(this, void 0), this.maxUndoRedoStackSize = 700, r(this, n, [], "f"), r(this, i, [], "f") } fireUpdateEvent(t, e) { this.editor.notifier.dispatch(a.EditorEventType.UndoRedoStackUpdated, { kind: a.EditorEventType.UndoRedoStackUpdated, undoStackSize: s(this, n, "f").length, redoStackSize: s(this, i, "f").length, command: e, stackUpdateType: t }) } push(t, e = !0) { e && t.apply(this.editor), s(this, n, "f").push(t); for (const t of s(this, i, "f")) t.onDrop(this.editor); if (r(this, i, [], "f"), s(this, n, "f").length > this.maxUndoRedoStackSize) { const t = Math.ceil(this.maxUndoRedoStackSize / 100); s(this, n, "f").splice(0, t).forEach((t => t.onDrop(this.editor))) } this.fireUpdateEvent(a.UndoEventType.CommandDone, t), this.editor.notifier.dispatch(a.EditorEventType.CommandDone, { kind: a.EditorEventType.CommandDone, command: t }) } undo() { const t = s(this, n, "f").pop(); if (t) { s(this, i, "f").push(t); const e = t.unapply(this.editor); return this.announceUndoCallback(t), this.fireUpdateEvent(a.UndoEventType.CommandUndone, t), this.editor.notifier.dispatch(a.EditorEventType.CommandUndone, { kind: a.EditorEventType.CommandUndone, command: t }), e } } redo() { const t = s(this, i, "f").pop(); if (t) { s(this, n, "f").push(t); const e = t.apply(this.editor); return this.announceRedoCallback(t), this.fireUpdateEvent(a.UndoEventType.CommandRedone, t), this.editor.notifier.dispatch(a.EditorEventType.CommandDone, { kind: a.EditorEventType.CommandDone, command: t }), e } } get undoStackSize() { return s(this, n, "f").length } get redoStackSize() { return s(this, i, "f").length } } }, 4093: function (t, e, o) { "use strict"; var n, i, r = this && this.__classPrivateFieldSet || function (t, e, o, n, i) { if ("m" === n) throw new TypeError("Private method is not writable"); if ("a" === n && !i) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof e ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === n ? i.call(t, o) : i ? i.value = o : e.set(t, o), o }, s = this && this.__classPrivateFieldGet || function (t, e, o, n) { if ("a" === o && !n) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === o ? n : "a" === o ? n.call(t) : n ? n.value : e.get(t) }, a = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.Viewport = e.ViewportTransform = void 0; const l = a(o(1403)), c = o(5379); class d extends l.default { } e.ViewportTransform = d; class h { constructor(t) { this.onTransformChangeCallback = t, this.resetTransform(c.Mat33.identity), this.screenRect = c.Rect2.empty } getTemporaryClone() { const t = new h((() => { })); return t.transform = this.transform, t.inverseTransform = this.inverseTransform, t.screenRect = this.screenRect, t } updateScreenSize(t) { this.screenRect = this.screenRect.resizedTo(t) } get visibleRect() { return this.screenRect.transformedBoundingBox(this.inverseTransform) } screenToCanvas(t) { return this.inverseTransform.transformVec2(t) } canvasToScreen(t) { return this.transform.transformVec2(t) } static transformBy(t) { return new h.ViewportTransform(t) } resetTransform(t = c.Mat33.identity) { const e = this.transform; this.transform = t, this.inverseTransform = t.inverse(), this.onTransformChangeCallback?.(e, t) } get screenToCanvasTransform() { return this.inverseTransform } get canvasToScreenTransform() { return this.transform } getScreenRectSize() { return this.screenRect.size } getResolution() { return this.getScreenRectSize() } getScaleFactor() { return this.transform.transformVec3(c.Vec3.unitX).magnitude() } getScaleFactorToNearestPowerOfTen() { return this.getScaleFactorToNearestPowerOf(10) } getScaleFactorToNearestPowerOf(t) { const e = this.getScaleFactor(); return Math.pow(t, Math.round(Math.log(e) / Math.log(t))) } static getGridSize(t) { return 50 / t } snapToGrid(t) { const e = this.getScaleFactorToNearestPowerOf(2), o = t => { const o = 1 / h.getGridSize(e); return Math.round(t * o) / o }; return c.Vec2.of(o(t.x), o(t.y)) } getSizeOfPixelOnCanvas() { return 1 / this.getScaleFactor() } getRotationAngle() { return this.transform.transformVec3(c.Vec3.unitX).angle() } static roundPoint(t, e) { const o = 10 ** Math.floor(Math.log10(e)), n = t => Math.round(t / o) * o; return "number" == typeof t ? n(t) : t.map(n) } roundPoint(t) { return h.roundPoint(t, 1 / this.getScaleFactor()) } static roundScaleRatio(t, e = 1) { if (Math.abs(t) <= 1e-12) return 0; const o = 10 ** Math.floor(Math.log10(Math.abs(t))), n = 2 ** e; return t = Math.round(t / o * n) / n * o } computeZoomToTransform(t, e = !0, o = !0) { let n = c.Mat33.identity; if (0 === t.w || 0 === t.h) { let n = Math.max(t.w, t.h); 0 === n && (n = 50, e = !1, o = !1), t = new c.Rect2(t.x, t.y, n, n) } if (isNaN(t.size.magnitude())) throw new Error(`${t.toString()} rectangle has NaN size! Cannot zoom to!`); const i = () => { const t = this.visibleRect.transformedBoundingBox(n.inverse()); return t.transformedBoundingBox(c.Mat33.scaling2D(.8, t.center)) }; let r = i(); const s = r.w < t.w || r.h < t.h, a = t.maxDimension / r.maxDimension < 1 / 3; if (s && o || a && e) { const e = Math.max(t.w / r.w, t.h / r.h), o = c.Mat33.scaling2D(e, r.topLeft).inverse(); n = n.rightMul(o) } if (r = i(), !r.containsRect(t)) { const e = t.center.minus(r.center), o = c.Mat33.translation(e).inverse(); n = n.rightMul(o) } return n.invertable() || (console.warn("Unable to zoom to ", t, "! Computed transform", n, "is singular."), n = c.Mat33.identity), n } zoomTo(t, e = !0, o = !0) { const n = this.computeZoomToTransform(t, e, o); return new h.ViewportTransform(n) } } e.Viewport = h, h.ViewportTransform = (i = class extends d { constructor(t) { super(), this.transform = t, n.set(this, void 0), r(this, n, t.inverse(), "f") } apply(t) { const e = t.viewport; e.resetTransform(e.transform.rightMul(this.transform)), t.queueRerender() } unapply(t) { const e = t.viewport; e.resetTransform(e.transform.rightMul(s(this, n, "f"))), t.queueRerender() } description(t, e) { const o = [], n = t.viewport.visibleRect.center, i = this.transform.transformVec3(c.Vec2.unitX), r = this.transform.transformVec2(n), s = i.magnitude(), a = 180 / Math.PI * i.angle(), l = r.minus(n); s > 1.2 ? o.push(e.zoomedIn) : s < .8 && o.push(e.zoomedOut), Math.floor(Math.abs(a)) > 0 && o.push(e.rotatedBy(Math.round(a))); const d = 1e-4; return l.x > d ? o.push(e.movedLeft) : l.x < -1e-4 && o.push(e.movedRight), l.y < -1e-4 ? o.push(e.movedDown) : l.y > d && o.push(e.movedUp), o.join("; ") } }, n = new WeakMap, i), e.default = h }, 2728: function (t, e, o) { "use strict"; var n = this && this.__createBinding || (Object.create ? function (t, e, o, n) { void 0 === n && (n = o); var i = Object.getOwnPropertyDescriptor(e, o); i && !("get" in i ? !e.__esModule : i.writable || i.configurable) || (i = { enumerable: !0, get: function () { return e[o] } }), Object.defineProperty(t, n, i) } : function (t, e, o, n) { void 0 === n && (n = o), t[n] = e[o] }), i = this && this.__exportStar || function (t, e) { for (var o in t) "default" === o || Object.prototype.hasOwnProperty.call(e, o) || n(e, t, o) }, r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), o(9435); const s = r(o(3954)); i(o(6592), e), e.default = s.default }, 1403: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.Command = void 0; class o { onDrop(t) { } static union(t, e) { return new class extends o { apply(o) { t.apply(o), e.apply(o) } unapply(o) { e.unapply(o), t.unapply(o) } description(o, n) { const i = t.description(o, n), r = e.description(o, n); return i === r ? i : `${i}, ${r}` } } } } e.Command = o, o.empty = new class extends o { description(t, e) { return "" } apply(t) { } unapply(t) { } }, e.default = o }, 1247: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(3925)), r = n(o(6188)), s = n(o(1434)); class a extends s.default { constructor(t) { super("duplicate"), this.toDuplicate = t, this.duplicates = t.map((t => t.clone())), this.reverse = new r.default(this.duplicates) } apply(t) { this.reverse.unapply(t) } unapply(t) { this.reverse.apply(t) } onDrop(t) { this.reverse.onDrop(t) } description(t, e) { return 0 === this.duplicates.length ? e.duplicatedNoElements : e.duplicateAction((0, i.default)(e, this.duplicates) ?? e.elements, this.duplicates.length) } serializeToJSON() { return this.toDuplicate.map((t => t.getId())) } } s.default.register("duplicate", ((t, e) => { const o = t.map((t => e.image.lookupElement(t))); return new a(o) })), e.default = a }, 6188: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(3029)), r = n(o(3925)), s = n(o(7)), a = n(o(1434)); class l extends a.default { constructor(t) { super("erase"), this.toRemove = t.map((t => t)), this.applied = !1 } apply(t) { for (const e of this.toRemove) { const o = t.image.findParent(e); o && (o.remove(), t.image.onDestroyElement(e)) } this.applied = !0, t.queueRerender() } unapply(t) { for (const e of this.toRemove) t.image.findParent(e) || s.default.addElement(e).apply(t); this.applied = !1, t.queueRerender() } onDrop(t) { if (this.applied) for (const e of this.toRemove) t.image.onDestroyElement(e) } description(t, e) { if (0 === this.toRemove.length) return e.erasedNoElements; const o = (0, r.default)(e, this.toRemove) ?? e.elements; return e.eraseAction(o, this.toRemove.length) } serializeToJSON() { return this.toRemove.map((t => t.serialize())) } } a.default.register("erase", ((t, e) => { if (!Array.isArray(t)) throw new Error("seralized erase data must be an array"); const o = t.map((t => { const o = "string" == typeof t ? t : `${t.id}`; return e.image.lookupElement(o) ?? i.default.deserialize(t) })); return new l(o) })), e.default = l }, 1434: function (t, e, o) { "use strict"; var n, i = this && this.__classPrivateFieldSet || function (t, e, o, n, i) { if ("m" === n) throw new TypeError("Private method is not writable"); if ("a" === n && !i) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof e ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === n ? i.call(t, o) : i ? i.value = o : e.set(t, o), o }, r = this && this.__classPrivateFieldGet || function (t, e, o, n) { if ("a" === o && !n) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === o ? n : "a" === o ? n.call(t) : n ? n.value : e.get(t) }, s = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const a = s(o(1403)); class l extends a.default { constructor(t) { if (super(), n.set(this, void 0), !(t in l.deserializationCallbacks)) throw new Error(`Command ${t} must have a registered deserialization callback. To do this, call SerializableCommand.register.`); i(this, n, t, "f") } serialize() { return { data: this.serializeToJSON(), commandType: r(this, n, "f") } } static deserialize(t, e) { const o = "string" == typeof t ? JSON.parse(t) : t, n = o.commandType; if (!(n in l.deserializationCallbacks)) throw new Error(`Unrecognised command type ${n}!`); return l.deserializationCallbacks[n](o.data, e) } static register(t, e) { l.deserializationCallbacks[t] = e } } n = new WeakMap, l.deserializationCallbacks = {}, e.default = l }, 5922: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(1434)); class r extends i.default { constructor(t, e, o) { super(t), this.component = o ?? null, this.componentID = e } resolveComponent(t) { if (this.component) return; const e = t.lookupElement(this.componentID); if (!e) throw new Error(`Unable to resolve component with ID ${this.componentID}`); this.component = e } } e.default = r }, 8567: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(1403)), r = n(o(1434)), s = t => { if (t instanceof r.default) return new class extends r.default { constructor() { super(...arguments), this._command = t } serializeToJSON() { return t.serialize() } apply(e) { t.unapply(e) } unapply(e) { t.apply(e) } onDrop(e) { t.onDrop(e) } description(e, o) { return o.inverseOf(t.description(e, o)) } }("inverse"); return new class extends i.default { apply(e) { t.unapply(e) } unapply(e) { t.apply(e) } onDrop(e) { t.onDrop(e) } description(e, o) { return o.inverseOf(t.description(e, o)) } } }; r.default.register("inverse", ((t, e) => s(r.default.deserialize(t, e)))), e.default = s }, 525: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.uniteCommands = e.invertCommand = e.SerializableCommand = e.Erase = e.Duplicate = e.Command = void 0; const i = n(o(1403)); e.Command = i.default; const r = n(o(1247)); e.Duplicate = r.default; const s = n(o(6188)); e.Erase = s.default; const a = n(o(8567)); e.invertCommand = a.default; const l = n(o(1434)); e.SerializableCommand = l.default; const c = n(o(2717)); e.uniteCommands = c.default }, 9985: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.defaultCommandLocalization = void 0, e.defaultCommandLocalization = { updatedViewport: "Transformed Viewport", transformedElements: t => `Transformed ${t} element${1 === t ? "" : "s"}`, resizeOutputCommand: t => `Resized image to ${t.w}x${t.h}`, enabledAutoresizeOutputCommand: "Enabled output autoresize", disabledAutoresizeOutputCommand: "Disabled output autoresize", addElementAction: t => `Added ${t}`, eraseAction: (t, e) => `Erased ${e} ${t}`, duplicateAction: (t, e) => `Duplicated ${e} ${t}`, unionOf: (t, e) => `Union: ${e} ${t}`, inverseOf: t => `Inverse of ${t}`, elements: "Elements", erasedNoElements: "Erased nothing", duplicatedNoElements: "Duplicated nothing", rotatedBy: t => `Rotated by ${Math.abs(t)} degrees ${t < 0 ? "clockwise" : "counter-clockwise"}`, movedLeft: "Moved left", movedUp: "Moved up", movedDown: "Moved down", movedRight: "Moved right", zoomedOut: "Zoomed out", zoomedIn: "Zoomed in", andNMoreCommands: t => `And ${t} more commands.`, selectedElements: t => `Selected ${t} element${1 === t ? "" : "s"}` } }, 2717: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(9713)), r = n(o(1403)), s = n(o(1434)); class a extends r.default { constructor(t, e, o) { super(), this.commands = t, this.applyChunkSize = e, this.descriptionOverride = o } apply(t) { if (void 0 === this.applyChunkSize) { const e = this.commands.map((e => e.apply(t))); return (0, i.default)(e) } return t.asyncApplyCommands(this.commands, this.applyChunkSize) } unapply(t) { const e = [...this.commands]; if (e.reverse(), void 0 === this.applyChunkSize) { const o = e.map((e => e.unapply(t))); return (0, i.default)(o) } return t.asyncUnapplyCommands(e, this.applyChunkSize, !1) } onDrop(t) { this.commands.forEach((e => e.onDrop(t))) } description(t, e) { if (this.descriptionOverride) return this.descriptionOverride; const o = []; let n = null, i = 0, r = 0; for (const s of this.commands) { const a = s.description(t, e); a !== n && null !== n && (o.push(e.unionOf(n, i)), n = null, i = 0), i++, r++, n ??= a; const l = 12; if (o.length > l) break } return i > 1 ? o.push(e.unionOf(n, i)) : 1 === i && o.push(n), r < this.commands.length && o.push(e.andNMoreCommands(this.commands.length - r)), o.join(", ") } } class l extends s.default { constructor(t, e, o) { super("union"), this.commands = t, this.applyChunkSize = e, this.descriptionOverride = o, this.nonserializableCommand = new a(t, e, o) } serializeToJSON() { return this.serializedData ? this.serializedData : { applyChunkSize: this.applyChunkSize, data: this.commands.map((t => t.serialize())), description: this.descriptionOverride } } apply(t) { return this.serializedData = this.serializeToJSON(), this.nonserializableCommand.apply(t) } unapply(t) { return this.nonserializableCommand.unapply(t) } onDrop(t) { this.nonserializableCommand.onDrop(t) } description(t, e) { return this.nonserializableCommand.description(t, e) } } const c = (t, e) => { let o, n, i = !0; for (const e of t) if (!(e instanceof s.default)) { i = !1; break } if ("number" == typeof e ? o = e : (o = e?.applyChunkSize, n = e?.description), i) { return new l(t, o, n) } return new a(t, o, n) }; s.default.register("union", ((t, e) => { if ("number" != typeof t.data.length) throw new Error("Unions of commands must serialize to lists of serialization data."); const o = t.applyChunkSize; if ("number" != typeof o && void 0 !== o) throw new Error("serialized applyChunkSize is neither undefined nor a number."); const n = "string" == typeof t.description ? t.description : void 0, i = []; for (const o of t.data) i.push(s.default.deserialize(o, e)); return c(i, { applyChunkSize: o, description: n }) })), e.default = c }, 3029: function (t, e, o) { "use strict"; var n, i = this && this.__setFunctionName || function (t, e, o) { return "symbol" == typeof e && (e = e.description ? "[".concat(e.description, "]") : ""), Object.defineProperty(t, "name", { configurable: !0, value: o ? "".concat(o, " ", e) : e }) }, r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.ComponentSizingMode = void 0; const s = r(o(1434)), a = r(o(7)), l = o(5379), c = r(o(5922)); var d; !function (t) { t[t.BoundingBox = 0] = "BoundingBox", t[t.FillScreen = 1] = "FillScreen", t[t.Anywhere = 2] = "Anywhere" }(d || (e.ComponentSizingMode = d = {})); class h { constructor(t, e) { if (this.componentKind = t, this.loadSaveData = {}, this.lastChangedTime = (new Date).getTime(), this.zIndex = void 0 !== e ? e : h.zIndexCounter++, this.id = `${(new Date).getTime()}-${Math.random()}`, void 0 === h.deserializationCallbacks[t]) throw new Error(`Component ${t} has not been registered using AbstractComponent.registerComponent`) } getId() { return this.id } static registerComponent(t, e) { this.deserializationCallbacks[t] = e ?? null } attachLoadSaveData(t, e) { this.loadSaveData[t] || (this.loadSaveData[t] = []), this.loadSaveData[t].push(e) } getLoadSaveData() { return this.loadSaveData } getZIndex() { return this.zIndex } getBBox() { return this.contentBBox } getExactBBox() { return this.getBBox() } getSizingMode() { return d.BoundingBox } occludesEverythingBelowWhenRenderedInRect(t) { return !1 } onAddToImage(t) { } onRemoveFromImage() { } intersectsRect(t) { if (t.containsRect(this.getExactBBox())) return !0; return t.getEdges().some((t => this.intersects(t))) } isSelectable() { return !0 } isBackground() { return !1 } getProportionalRenderingTime() { return 1 } transformBy(t) { return new h.TransformElementCommand(t, this.getId(), this) } setZIndex(t) { return new h.TransformElementCommand(l.Mat33.identity, this.getId(), this, t) } setZIndexAndTransformBy(t, e, o) { return new h.TransformElementCommand(t, this.getId(), this, e, o) } clone() { const t = this.createClone(); for (const e in this.loadSaveData) for (const o of this.loadSaveData[e]) t.attachLoadSaveData(e, o); return t } serialize() { const t = this.serializeToJSON(); if (null === t) throw new Error(`${this} cannot be serialized.`); return { name: this.componentKind, zIndex: this.zIndex, id: this.id, loadSaveData: this.loadSaveData, data: t } } static isNotDeserializable(t) { return "string" == typeof t && (t = JSON.parse(t)), "object" != typeof t || (!this.deserializationCallbacks[t?.name] || !t.data) } static deserialize(t) { if ("string" == typeof t && (t = JSON.parse(t)), h.isNotDeserializable(t)) throw new Error(`Element with data ${t} cannot be deserialized.`); const e = this.deserializationCallbacks[t.name](t.data); return e.id = t.id, isFinite(t.zIndex) && (e.zIndex = t.zIndex, h.zIndexCounter = Math.max(h.zIndexCounter, e.zIndex + 1)), e } } h.zIndexCounter = 0, h.deserializationCallbacks = {}, h.transformElementCommandId = "transform-element", h.TransformElementCommand = (i(n = class extends c.default { constructor(t, e, o, n, i) { super(h.transformElementCommandId, e, o), this.affineTransfm = t, this.origZIndex = i, this.targetZIndex = n ?? h.zIndexCounter++, this.targetZIndex >= h.zIndexCounter && (h.zIndexCounter = this.targetZIndex + 1), o && void 0 === i && (this.origZIndex = o.getZIndex()) } resolveComponent(t) { this.component || (super.resolveComponent(t), this.origZIndex ??= this.component.getZIndex()) } updateTransform(t, e, o) { if (!this.component) throw new Error("this.component is undefined or null!"); const n = t.image.findParent(this.component); let i = !1; n && (n.remove(), i = !0), this.component.applyTransformation(e), this.component.zIndex = o, this.component.lastChangedTime = (new Date).getTime(), o >= h.zIndexCounter && (h.zIndexCounter = o + 1), i && a.default.addElement(this.component).apply(t) } apply(t) { this.resolveComponent(t.image), this.updateTransform(t, this.affineTransfm, this.targetZIndex), t.queueRerender() } unapply(t) { this.resolveComponent(t.image), this.updateTransform(t, this.affineTransfm.inverse(), this.origZIndex), t.queueRerender() } description(t, e) { return e.transformedElements(1) } serializeToJSON() { return { id: this.componentID, transfm: this.affineTransfm.toArray(), targetZIndex: this.targetZIndex, origZIndex: this.origZIndex } } }, "TransformElementCommand"), s.default.register(h.transformElementCommandId, ((t, e) => { const o = e.image.lookupElement(t.id) ?? void 0, n = new l.Mat33(...t.transfm), i = t.targetZIndex, r = t.origZIndex ?? void 0; return new h.TransformElementCommand(n, t.id, o, i, r) })), n), e.default = h }, 2115: function (t, e, o) { "use strict"; var n, i = this && this.__createBinding || (Object.create ? function (t, e, o, n) { void 0 === n && (n = o); var i = Object.getOwnPropertyDescriptor(e, o); i && !("get" in i ? !e.__esModule : i.writable || i.configurable) || (i = { enumerable: !0, get: function () { return e[o] } }), Object.defineProperty(t, n, i) } : function (t, e, o, n) { void 0 === n && (n = o), t[n] = e[o] }), r = this && this.__setModuleDefault || (Object.create ? function (t, e) { Object.defineProperty(t, "default", { enumerable: !0, value: e }) } : function (t, e) { t.default = e }), s = this && this.__importStar || (n = function (t) { return n = Object.getOwnPropertyNames || function (t) { var e = []; for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[e.length] = o); return e }, n(t) }, function (t) { if (t && t.__esModule) return t; var e = {}; if (null != t) for (var o = n(t), s = 0; s < o.length; s++)"default" !== o[s] && i(e, t, o[s]); return r(e, t), e }), a = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.backgroundTypeToClassNameMap = e.imageBackgroundNonAutomaticSecondaryColorCSSClassName = e.imageBackgroundGridSizeCSSPrefix = e.imageBackgroundCSSClassName = e.BackgroundType = void 0; const l = o(7), c = o(5379), d = s(o(3029)), h = o(486), u = a(o(4093)), p = o(8258); var f; !function (t) { t[t.SolidColor = 0] = "SolidColor", t[t.Grid = 1] = "Grid", t[t.None = 2] = "None" }(f || (e.BackgroundType = f = {})), e.imageBackgroundCSSClassName = "js-draw-image-background", e.imageBackgroundGridSizeCSSPrefix = "js-draw-image-background-grid-", e.imageBackgroundNonAutomaticSecondaryColorCSSClassName = "js-draw-image-background-non-automatic-secondary-color", e.backgroundTypeToClassNameMap = { [f.Grid]: "js-draw-image-background-grid", [f.SolidColor]: e.imageBackgroundCSSClassName, [f.None]: "" }; class m extends d.default { constructor(t, e) { super("image-background", 0), this.backgroundType = t, this.mainColor = e, this.viewportSizeChangeListener = null, this.autoresizeChangedListener = null, this.fillsScreen = !1, this.gridSize = u.default.getGridSize(2), this.gridStrokeWidth = .7, this.secondaryColor = null, this.isRestylableComponent = !0, this.contentBBox = c.Rect2.empty } static ofGrid(t, e, o, n) { const i = new m(f.Grid, t); return void 0 !== e && (i.gridSize = e), void 0 !== o && (i.secondaryColor = o), void 0 !== n && (i.gridStrokeWidth = n), i } getBackgroundType() { return this.backgroundType } getMainColor() { return this.mainColor } getSecondaryColor() { return this.secondaryColor } getGridSize() { return this.gridSize } getStyle() { let t = this.mainColor; return this.backgroundType === f.None && (t = void 0), { color: t } } updateStyle(t) { return (0, h.createRestyleComponentCommand)(this.getStyle(), t, this) } forceStyle(t, e) { const o = t.color; o && (this.mainColor = o, o.eq(c.Color4.transparent) && this.backgroundType === f.SolidColor ? this.backgroundType = f.None : this.backgroundType === f.None && (this.backgroundType = f.SolidColor), e && (e.image.queueRerenderOf(this), e.queueRerender())) } onAddToImage(t) { this.viewportSizeChangeListener && (console.warn("onAddToImage called when background is already in an image"), this.onRemoveFromImage()), this.viewportSizeChangeListener = t.notifier.on(l.EditorImageEventType.ExportViewportChanged, (() => { this.recomputeBBox(t) })), this.autoresizeChangedListener = t.notifier.on(l.EditorImageEventType.AutoresizeModeChanged, (() => { this.recomputeBBox(t) })), this.recomputeBBox(t) } onRemoveFromImage() { this.viewportSizeChangeListener?.remove(), this.autoresizeChangedListener?.remove(), this.viewportSizeChangeListener = null, this.autoresizeChangedListener = null } recomputeBBox(t) { const e = t.getImportExportViewport().visibleRect; let o = !1; this.contentBBox.eq(e) || (this.contentBBox = e, o ||= !this.fillsScreen); const n = t.getAutoresizeEnabled(); n !== this.fillsScreen && (this.fillsScreen = n, o = !0), o && t.queueRerenderOf(this) } generateGridPath(t) { const e = this.getFullBoundingBox(t), o = (t?.intersection(e) ?? e).grownBy(this.gridStrokeWidth / 2), n = t => Math.floor(t / this.gridSize) * this.gridSize, i = t => Math.ceil(t / this.gridSize) * this.gridSize, r = i(o.y), s = n(o.y + o.h), a = i(o.x), l = n(o.x + o.w), d = [], h = (s - r) / this.gridSize, u = (l - a) / this.gridSize; if (h > 1e3 || u > 1e3) return c.Path.empty; const p = c.Vec2.of(o.x, r); for (let t = r; t <= s; t += this.gridSize)d.push({ kind: c.PathCommandType.MoveTo, point: c.Vec2.of(o.x, t) }), d.push({ kind: c.PathCommandType.LineTo, point: c.Vec2.of(o.x + o.w, t) }); for (let t = a; t <= l; t += this.gridSize)d.push({ kind: c.PathCommandType.MoveTo, point: c.Vec2.of(t, o.y) }), d.push({ kind: c.PathCommandType.LineTo, point: c.Vec2.of(t, o.y + o.h) }); return new c.Path(p, d) } getFullBoundingBox(t) { return (this.fillsScreen ? t : this.contentBBox) ?? this.contentBBox } render(t, o) { if (this.backgroundType === f.None) return; const n = !o; this.fillsScreen && (o ??= t.getVisibleRect()); const i = this.backgroundType === f.Grid, r = this.getFullBoundingBox(o); if (t.startObject(r, i), this.backgroundType === f.SolidColor || this.backgroundType === f.Grid) { const e = o?.intersection(r); e ? t.fillRect(e, this.mainColor) : n && t.fillRect(r, this.mainColor) } if (this.backgroundType === f.Grid) { let e = this.secondaryColor; e ??= c.Color4.ofRGBA(1 - this.mainColor.r, 1 - this.mainColor.g, 1 - this.mainColor.b, .2), 0 === this.mainColor.a && (e = c.Color4.ofRGBA(.5, .5, .5, .2)); const n = { fill: c.Color4.transparent, stroke: { width: this.gridStrokeWidth, color: e } }; t.drawPath((0, p.pathToRenderable)(this.generateGridPath(o), n)) } const s = e.backgroundTypeToClassNameMap[this.backgroundType], a = [e.imageBackgroundCSSClassName]; if (s !== e.imageBackgroundCSSClassName) { a.push(s); const t = (0, c.toRoundedString)(this.gridSize).replace(/[.]/g, "p"); a.push(e.imageBackgroundGridSizeCSSPrefix + t) } null !== this.secondaryColor && a.push(e.imageBackgroundNonAutomaticSecondaryColorCSSClassName), t.endObject(this.getLoadSaveData(), a) } intersects(t) { return this.contentBBox.getEdges().some((e => e.intersects(t))) } isSelectable() { return !1 } isBackground() { return !0 } getSizingMode() { return this.fillsScreen ? d.ComponentSizingMode.FillScreen : d.ComponentSizingMode.BoundingBox } serializeToJSON() { return { mainColor: this.mainColor.toHexString(), secondaryColor: this.secondaryColor?.toHexString(), backgroundType: this.backgroundType, gridSize: this.gridSize, gridStrokeWidth: this.gridStrokeWidth } } applyTransformation(t) { } description(t) { if (this.backgroundType === f.SolidColor) return t.filledBackgroundWithColor(this.mainColor.toString()); if (this.backgroundType === f.None) return t.emptyBackground; if (this.backgroundType === f.Grid) return t.gridBackground; return this.backgroundType } createClone() { return new m(this.backgroundType, this.mainColor) } static deserializeFromJSON(t) { if ("string" == typeof t && (t = JSON.parse(t)), "string" != typeof t.mainColor) throw new Error("Error deserializing — mainColor must be of type string."); let e; const o = t.backgroundType; if (o !== f.None && o !== f.Grid && o !== f.SolidColor) { return o } e = o; const n = c.Color4.fromHex(t.mainColor), i = t.secondaryColor ? c.Color4.fromHex(t.secondaryColor) : null, r = t.gridSize ?? void 0, s = t.gridStrokeWidth ?? void 0, a = new m(e, n); return a.secondaryColor = i, r && (a.gridSize = r), s && (a.gridStrokeWidth = s), a } } e.default = m, d.default.registerComponent("image-background", m.deserializeFromJSON) }, 4686: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = o(5379), r = o(7571), s = n(o(3029)), a = n(o(8614)); class l extends s.default { constructor(t) { super("image-component"), this.image = { ...t, label: t.label ?? t.image.getAttribute("alt") ?? t.image.getAttribute("aria-label") ?? void 0 }; void 0 === t.image.getAttribute("src") || t.image.complete || (t.image.onload = () => this.recomputeBBox()), this.recomputeBBox() } getImageRect() { return new i.Rect2(0, 0, this.image.image.width, this.image.image.height) } recomputeBBox() { this.contentBBox = this.getImageRect(), this.contentBBox = this.contentBBox.transformedBoundingBox(this.image.transform) } static async fromImage(t, e) { let o, n, i; await (0, a.default)(t), "number" == typeof t.width && "number" == typeof t.height && 0 !== t.width && 0 !== t.height ? (o = t.width, n = t.height) : (o = t.clientWidth, n = t.clientHeight); let r = t.src ?? ""; if (r.startsWith("data:image/")) i = new Image, i.src = r, i.width = o, i.height = n; else { const e = document.createElement("canvas"); e.width = o, e.height = n; e.getContext("2d").drawImage(t, 0, 0, e.width, e.height), r = e.toDataURL(), i = e } return i.setAttribute("alt", t.getAttribute("alt") ?? ""), i.setAttribute("aria-label", t.getAttribute("aria-label") ?? ""), new l({ image: i, base64Url: r, transform: e }) } render(t, e) { t.startObject(this.contentBBox), t.drawImage(this.image), t.endObject(this.getLoadSaveData()) } getProportionalRenderingTime() { return 10 } intersects(t) { const e = this.getImageRect().getEdges().map((t => t.transformedBy(this.image.transform))); for (const o of e) if (o.intersects(t)) return !0; return !1 } applyTransformation(t) { this.image.transform = t.rightMul(this.image.transform), this.recomputeBBox() } description(t) { return this.image.label ? t.imageNode(this.image.label) : t.unlabeledImageNode } getAltText() { return this.image.label } getURL() { return this.image.base64Url } getTransformation() { return this.image.transform } createClone() { return new l({ ...this.image }) } serializeToJSON() { return { src: this.image.base64Url, label: this.image.label, width: this.image.image.width, height: this.image.image.height, transform: this.image.transform.toArray() } } static deserializeFromJSON(t) { if ("string" != typeof t.src) throw new Error(`${t} has invalid format! Expected src property.`); (0, r.assertIsNumberArray)(t.transform), (0, r.assertIsNumber)(t.width), (0, r.assertIsNumber)(t.height); const e = new Image; e.src = t.src, e.width = t.width, e.height = t.height; const o = new i.Mat33(...t.transform); return new l({ image: e, base64Url: t.src, label: t.label, transform: o }) } } e.default = l, s.default.registerComponent("image-component", l.deserializeFromJSON) }, 486: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.isRestylableComponent = e.createRestyleComponentCommand = void 0; const i = o(5379), r = n(o(1434)), s = n(o(5922)), a = o(196), l = t => { const e = {}; return t.color && (e.color = t.color.toHexString()), t.textStyle && (e.textStyle = (0, a.textStyleToJSON)(t.textStyle)), e }, c = t => ({ color: t.color ? i.Color4.fromHex(t.color) : void 0, textStyle: t.textStyle ? (0, a.textStyleFromJSON)(t.textStyle) : void 0 }); e.createRestyleComponentCommand = (t, e, o) => new h(t, e, o.getId(), o); e.isRestylableComponent = t => !!("getStyle" in t && "updateStyle" in t && "forceStyle" in t) && !(!("isRestylableComponent" in t) || !t.isRestylableComponent); const d = "default-restyle-element"; class h extends s.default { constructor(t, e, o, n) { super(d, o, n), this.originalStyle = t, this.newStyle = e } getComponent(t) { this.resolveComponent(t.image); const e = this.component; if (!e || !e.forceStyle || !e.updateStyle) throw new Error("this.component is missing forceStyle and/or updateStyle methods!"); return e } apply(t) { this.getComponent(t).forceStyle(this.newStyle, t) } unapply(t) { this.getComponent(t).forceStyle(this.originalStyle, t) } description(t, e) { return e.restyledElement(this.getComponent(t).description(e)) } serializeToJSON() { return { id: this.componentID, originalStyle: l(this.originalStyle), newStyle: l(this.newStyle) } } } r.default.register(d, ((t, e) => { const o = c(t.originalStyle), n = c(t.newStyle), i = t.id; if ("string" != typeof t.id) throw new Error(`json.id is of type ${typeof t.id}, not string.`); return new h(o, n, i) })) }, 67: function (t, e, o) { "use strict"; var n, i = this && this.__createBinding || (Object.create ? function (t, e, o, n) { void 0 === n && (n = o); var i = Object.getOwnPropertyDescriptor(e, o); i && !("get" in i ? !e.__esModule : i.writable || i.configurable) || (i = { enumerable: !0, get: function () { return e[o] } }), Object.defineProperty(t, n, i) } : function (t, e, o, n) { void 0 === n && (n = o), t[n] = e[o] }), r = this && this.__setModuleDefault || (Object.create ? function (t, e) { Object.defineProperty(t, "default", { enumerable: !0, value: e }) } : function (t, e) { t.default = e }), s = this && this.__importStar || (n = function (t) { return n = Object.getOwnPropertyNames || function (t) { var e = []; for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[e.length] = o); return e }, n(t) }, function (t) { if (t && t.__esModule) return t; var e = {}; if (null != t) for (var o = n(t), s = 0; s < o.length; s++)"default" !== o[s] && i(e, t, o[s]); return r(e, t), e }), a = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const l = o(5379), c = a(o(1598)), d = s(o(3029)), h = "svg-global-attributes"; class u extends d.default { constructor(t) { super(h), this.contentBBox = l.Rect2.empty; const e = ["viewBox", "width", "height"]; this.attrs = t.filter((([t, o]) => !e.includes(t))) } render(t, e) { if (t instanceof c.default) for (const [e, o] of this.attrs) t.setRootSVGAttribute(e, o) } intersects(t) { return !1 } applyTransformation(t) { } isSelectable() { return !1 } getSizingMode() { return d.ComponentSizingMode.Anywhere } createClone() { return new u(this.attrs) } description(t) { return t.svgObject } serializeToJSON() { return JSON.stringify(this.attrs) } static deserializeFromString(t) { return new u([]) } } e.default = u, d.default.registerComponent(h, u.deserializeFromString) }, 2066: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = o(5379), r = o(8247), s = n(o(3029)), a = o(486), l = o(8258); class c extends s.default { constructor(t, e) { super("stroke", e), this.isRestylableComponent = !0, this.simplifiedPath = null, this.approximateRenderingTime = 0, this.parts = []; for (const e of t) { const t = (0, l.pathFromRenderable)(e), o = this.bboxForPart(t.bbox, e.style); this.contentBBox ? this.contentBBox = this.contentBBox.union(o) : this.contentBBox = o, this.parts.push({ path: t, startPoint: t.startPoint, style: e.style, commands: t.parts }), this.approximateRenderingTime += t.parts.length } this.contentBBox ??= i.Rect2.empty } getStyle() { if (0 === this.parts.length) return {}; const t = this.parts[0]; return void 0 === t.style.stroke || 0 === t.style.stroke.width ? { color: t.style.fill } : { color: t.style.stroke.color } } updateStyle(t) { return (0, a.createRestyleComponentCommand)(this.getStyle(), t, this) } forceStyle(t, e) { t.color && (this.parts = this.parts.map((e => { const o = { ...e.style, stroke: e.style.stroke ? { ...e.style.stroke } : void 0 }; return o.stroke && o.stroke.width > 0 ? o.stroke.color = t.color : o.fill = t.color, { path: e.path, startPoint: e.startPoint, commands: e.commands, style: o } })), e && (e.image.queueRerenderOf(this), e.queueRerender())) } withRegionErased(t, e) { const o = t.polylineApproximation(), n = []; let r = !1; for (const s of this.parts) { const a = s.path, d = t => { if (s.style.fill.a > 0) { if (t.parts.length < 1 || 1 === t.parts.length && t.parts[0].kind === i.PathCommandType.LineTo) return null; t = t.asClosed() } return isNaN(t.getExactBBox().area) ? (console.warn("Prevented creating a stroke with NaN area"), r = !0, null) : new c([(0, l.pathToRenderable)(t, s.style)], this.getZIndex()) }, h = []; for (const t of o) h.push(...a.intersection(t)); let u = !1; if (0 === h.length && s.style.stroke && s.style.stroke.width > .3 * t.bbox.minDimension && s.style.stroke.width < 30 * t.bbox.maxDimension) { for (const t of o) h.push(...a.intersection(t, s.style.stroke.width / 2)); u = !0 } h.sort(i.comparePathIndices); let p = (() => { if (0 === h.length) return !1; if (u) return 0 === h[0].curveIndex && h[0].parameterValue <= 0; const e = (0, i.stepPathIndexBy)(h[0], -1e-10); return o = a.at(e), t.closedContainsPoint(o); var o })() ? 1 : 0; const f = (e, o) => { const i = d(e); let s = p % 2 == 1; p++, void 0 !== o && (s = o), void 0 === o && !s && t.closedContainsPoint(e.getExactBBox().center) && (s = !s), i && (r ||= s && e.getExactBBox().maxDimension > 2 * t.getExactBBox().maxDimension, s || n.push(i)) }; if (0 === s.style.fill.a) { if (!(t.getExactBBox().maxDimension / 10 > a.getExactBBox().maxDimension)) { const t = a.splitAt(h, { mapNewPoint: t => e.roundPoint(t) }); for (const e of t) f(e) } } else if (h.length >= 2 && h.length % 2 == 0) { const t = a.splitAt(h, { mapNewPoint: t => e.roundPoint(t) }); for (let e = 0; e < Math.floor(t.length / 2); e++)f(t[e].union(t[t.length - e - 1]).asClosed()); t.length % 2 != 0 && f(t[Math.floor(t.length / 2)].asClosed()) } else f(a, !1) } return r ? [this] : n } intersects(t) { for (const e of this.parts) { const o = e.style.stroke?.width, n = o ? o / 2 : void 0; if (e.path.intersection(t, n).length > 0) return !0 } return !1 } intersectsRect(t) { if (!t.intersects(this.getBBox())) return !1; for (const e of this.parts) { const o = t.grownBy(-(e.style.stroke?.width ?? 0)); if (0 !== o.area) for (const t of e.path.startEndPoints()) if (o.containsPoint(t)) return !0 } return super.intersectsRect(t) } computeSimplifiedPathFor(t) { const e = []; let o = !1, n = !1; for (const i of this.parts) { if (n || !i.style.stroke || i.style.stroke.color.a < .99) { e.push(i); continue } const r = (0, l.simplifyPathToFullScreenOrEmpty)(i, t); r ? (e.push(r.path), r.fullScreen && (o = !0, n = !0)) : e.push(i) } return { forVisibleRect: t, parts: e, occludes: o } } occludesEverythingBelowWhenRenderedInRect(t) { return !!this.getBBox().containsRect(t) && (this.simplifiedPath && this.simplifiedPath.forVisibleRect.eq(t) || (this.simplifiedPath = this.computeSimplifiedPathFor(t)), this.simplifiedPath.occludes) } render(t, e) { t.startObject(this.getBBox()); let o = this.parts; e && this.simplifiedPath?.forVisibleRect?.containsRect(e) ? o = this.simplifiedPath.parts : this.simplifiedPath = null; for (const n of o) { const o = this.bboxForPart(n.path.bbox, n.style); if (e) { if (!o.intersects(e)) continue; if ((o.size.x > 3 * e.size.x || o.size.y > 3 * e.size.y) && !n.path.roughlyIntersects(e, n.style.stroke?.width ?? 0)) continue } t.drawPath(n) } t.endObject(this.getLoadSaveData()) } getProportionalRenderingTime() { return this.approximateRenderingTime } bboxForPart(t, e) { return e.stroke ? t.grownBy(e.stroke.width / 2) : t } getExactBBox() { let t = null; for (const { path: e, style: o } of this.parts) { const n = this.bboxForPart(e.getExactBBox(), o); t ??= n, t = t.union(n) } return t ?? i.Rect2.empty } applyTransformation(t) { this.contentBBox = i.Rect2.empty; let e = !0; this.parts = this.parts.map((o => { const n = o.path.transformedBy(t), i = { ...o.style, stroke: o.style.stroke ? { ...o.style.stroke } : void 0 }; if (i.stroke) { const e = t.getScaleFactor(); i.stroke.width *= e } const r = this.bboxForPart(n.bbox, i); return e ? (this.contentBBox = r, e = !1) : this.contentBBox = this.contentBBox.union(r), { path: n, startPoint: n.startPoint, commands: n.parts, style: i } })) } getParts() { return [...this.parts] } getPath() { let t = null; for (const e of this.parts) t ? t = t.union(e.path) : t ??= e.path; return t ?? i.Path.empty } description(t) { return t.stroke } createClone() { return new c(this.parts) } serializeToJSON() { return this.parts.map((t => ({ style: (0, r.styleToJSON)(t.style), path: t.path.serialize() }))) } static deserializeFromJSON(t) { if ("string" == typeof t && (t = JSON.parse(t)), "object" != typeof t || "number" != typeof t.length) throw new Error(`${t} is missing required field, parts, or parts is of the wrong type.`); const e = t.map((t => { const e = (0, r.styleFromJSON)(t.style); return (0, l.pathToRenderable)(i.Path.fromString(t.path), e) })); return new c(e) } } e.default = c, s.default.registerComponent("stroke", c.deserializeFromJSON) }, 2170: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.TextTransformMode = void 0; const i = o(5379), r = o(196), s = n(o(3029)), a = o(486), l = "text"; var c; !function (t) { t[t.ABSOLUTE_XY = 0] = "ABSOLUTE_XY", t[t.RELATIVE_XY = 1] = "RELATIVE_XY", t[t.RELATIVE_X_ABSOLUTE_Y = 2] = "RELATIVE_X_ABSOLUTE_Y", t[t.RELATIVE_Y_ABSOLUTE_X = 3] = "RELATIVE_Y_ABSOLUTE_X" }(c || (e.TextTransformMode = c = {})); const d = { fontFamily: "sans", size: 12, renderingStyle: { fill: i.Color4.purple } }; class h extends s.default { constructor(t, e, o = d, n = c.ABSOLUTE_XY) { super(l), this.textObjects = t, this.transform = e, this.style = o, this.transformMode = n, this.isRestylableComponent = !0, this.recomputeBBox(); !t.some((t => "string" == typeof t)) && t.length > 0 && (this.style = t[0].getTextStyle()) } static applyTextStyles(t, e) { const o = e.fontFamily.match(/\s/), n = e.fontFamily.match(/^".*"$/), i = o && !n ? `"${e.fontFamily.replace(/["]/g, '\\"')}"` : e.fontFamily; t.font = [e.fontStyle ?? "", e.fontWeight ?? "", (e.size ?? 12) + "px", `${i}`].join(" "), t.textAlign = "left" } static estimateTextDimens(t, e) { const o = t.length * e.size, n = e.size; return new i.Rect2(0, 2 * -n / 3, o, n) } static getTextMetrics(t, e) { if (h.textMeasuringCtx ??= document.createElement("canvas").getContext("2d") ?? null, !h.textMeasuringCtx) return null; const o = h.textMeasuringCtx; return h.applyTextStyles(o, e), o.measureText(t) } static getTextDimens(t, e) { const o = this.getTextMetrics(t, e); if (!o) return this.estimateTextDimens(t, e); const n = -o.actualBoundingBoxAscent, r = o.actualBoundingBoxAscent + o.actualBoundingBoxDescent; return new i.Rect2(0, n, o.width, r) } static getFontHeight(t) { return t.size } computeUntransformedBBoxOfPart(t) { return "string" == typeof t ? h.getTextDimens(t, this.style) : t.contentBBox } recomputeBBox() { let t = null; const e = new h.TextCursor(this.transform, this.style); for (const o of this.textObjects) { const n = e.update(o).transform, i = this.computeUntransformedBBoxOfPart(o).transformedBoundingBox(n); t ??= i, t = t.union(i) } this.contentBBox = t ?? i.Rect2.empty } renderInternal(t, e, o = i.Mat33.identity) { const n = new h.TextCursor(this.transform, this.style); for (const i of this.textObjects) { const { transform: r, bbox: s } = n.update(i); e && !e.intersects(s.transformedBoundingBox(o)) || ("string" == typeof i ? t.drawText(i, r, this.style) : (t.pushTransform(r), i.renderInternal(t, e, o.rightMul(r)), t.popTransform())) } } render(t, e) { t.startObject(this.contentBBox), this.renderInternal(t, e), t.endObject(this.getLoadSaveData()) } getProportionalRenderingTime() { return this.textObjects.length } intersects(t) { const e = new h.TextCursor(this.transform, this.style); for (const o of this.textObjects) { const n = e.update(o).transform.inverse(), i = t.transformedBy(n); if ("string" == typeof o) { if (h.getTextDimens(o, this.style).getEdges().some((t => null !== i.intersection(t)))) return !0 } else if (o.intersects(i)) return !0 } return !1 } getStyle() { return { color: this.style.renderingStyle.fill, textStyle: { ...this.style, renderingStyle: { ...this.style.renderingStyle } } } } updateStyle(t) { return (0, a.createRestyleComponentCommand)(this.getStyle(), t, this) } forceStyle(t, e) { if (t.textStyle) this.style = (0, r.cloneTextStyle)(t.textStyle); else { if (!t.color) return; this.style = { ...this.style, renderingStyle: { ...this.style.renderingStyle, fill: t.color } } } for (const o of this.textObjects) o instanceof h && o.forceStyle(t, e); e && (e.image.queueRerenderOf(this), e.queueRerender()) } getTextStyle() { return (0, r.cloneTextStyle)(this.style) } getBaselinePos() { return this.transform.transformVec2(i.Vec2.zero) } getTransform() { return this.transform } applyTransformation(t) { this.transform = t.rightMul(this.transform), this.recomputeBBox() } createClone() { const t = this.textObjects.map((t => "string" == typeof t ? t : t.createClone())); return new h(t, this.transform, this.style) } getText() { const t = []; for (const e of this.textObjects) "string" == typeof e ? t.push(e) : t.push(e.getText()); return t.join("\n") } description(t) { return t.text(this.getText()) } serializeToJSON() { const t = (0, r.textStyleToJSON)(this.style); return { textObjects: this.textObjects.map((t => "string" == typeof t ? { text: t } : { json: t.serializeToJSON() })), transform: this.transform.toArray(), style: t } } static deserializeFromString(t) { "string" == typeof t && (t = JSON.parse(t)); const e = (0, r.textStyleFromJSON)(t.style), o = t.textObjects.map((t => null !== (t.text ?? null) ? t.text : h.deserializeFromString(t.json))); if (t.transform = t.transform.filter((t => "number" == typeof t)), 9 !== t.transform.length) throw new Error(`Unable to deserialize transform, ${t.transform}.`); const n = t.transform, s = new i.Mat33(...n); return new h(o, s, e) } static fromLines(t, e, o) { let n = null; const r = [], s = Math.round(this.getFontHeight(o)); let a = i.Vec2.zero; for (const e of t) { n && (a = a.plus(i.Vec2.unitY.times(s))); const t = new h([e], i.Mat33.translation(a), o); r.push(t), n = t } return new h(r, e, o) } } h.textMeasuringCtx = null, h.TextCursor = class { constructor(t = i.Mat33.identity, e) { this.parentTransform = t, this.parentStyle = e, this.transform = i.Mat33.identity } update(t) { let e, o = i.Mat33.identity, n = i.Mat33.identity; "string" == typeof t ? e = h.getTextDimens(t, this.parentStyle) : (n = t.transform, e = t.getBBox()); const r = "string" == typeof t ? c.RELATIVE_XY : t.transformMode; if (r === c.RELATIVE_XY) o = this.transform.rightMul(o); else if (r === c.RELATIVE_X_ABSOLUTE_Y || r === c.RELATIVE_Y_ABSOLUTE_X) { o = this.transform.mapEntries(((t, [e, o]) => { if (r === c.RELATIVE_X_ABSOLUTE_Y) return 1 === e && 2 === o ? 0 : t; if (r === c.RELATIVE_Y_ABSOLUTE_X) return 0 === e && 2 === o ? 0 : t; throw new Error("Unreachable") })).rightMul(o) } const s = i.Mat33.translation(i.Vec2.of(e.width, 0)); this.transform = o.rightMul(n).rightMul(s); const a = this.parentTransform.rightMul(o); return { transform: a, bbox: e.transformedBoundingBox(a) } } }, e.default = h, s.default.registerComponent(l, (t => h.deserializeFromString(t))) }, 3405: function (t, e, o) { "use strict"; var n, i = this && this.__createBinding || (Object.create ? function (t, e, o, n) { void 0 === n && (n = o); var i = Object.getOwnPropertyDescriptor(e, o); i && !("get" in i ? !e.__esModule : i.writable || i.configurable) || (i = { enumerable: !0, get: function () { return e[o] } }), Object.defineProperty(t, n, i) } : function (t, e, o, n) { void 0 === n && (n = o), t[n] = e[o] }), r = this && this.__setModuleDefault || (Object.create ? function (t, e) { Object.defineProperty(t, "default", { enumerable: !0, value: e }) } : function (t, e) { t.default = e }), s = this && this.__importStar || (n = function (t) { return n = Object.getOwnPropertyNames || function (t) { var e = []; for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[e.length] = o); return e }, n(t) }, function (t) { if (t && t.__esModule) return t; var e = {}; if (null != t) for (var o = n(t), s = 0; s < o.length; s++)"default" !== o[s] && i(e, t, o[s]); return r(e, t), e }), a = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const l = o(5379), c = a(o(1598)), d = s(o(3029)), h = "unknown-svg-object"; class u extends d.default { constructor(t) { super(h), this.svgObject = t, this.contentBBox = l.Rect2.of(t.getBoundingClientRect()) } render(t, e) { t instanceof c.default && (t.startObject(this.contentBBox), t.drawSVGElem(this.svgObject), t.endObject(this.getLoadSaveData())) } intersects(t) { return this.contentBBox.getEdges().some((e => null !== e.intersection(t))) } applyTransformation(t) { } isSelectable() { return !1 } getSizingMode() { return d.ComponentSizingMode.Anywhere } createClone() { return new u(this.svgObject.cloneNode(!0)) } description(t) { return t.svgObject } serializeToJSON() { return JSON.stringify({ html: this.svgObject.outerHTML }) } } e.default = u, d.default.registerComponent(h, null) }, 8145: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.makeArrowBuilder = void 0; const i = o(5379), r = n(o(2066)), s = n(o(8091)); e.makeArrowBuilder = (0, s.default)(((t, e) => new a(t, e))); class a { constructor(t, e) { this.startPoint = t, this.viewport = e, this.endPoint = t } getLineWidth() { return Math.max(this.endPoint.width, this.startPoint.width) } getBBox() { return this.buildPreview().getBBox() } buildPreview() { const t = this.startPoint.pos, e = this.endPoint.pos, o = e.minus(t).normalized(), n = e.distanceTo(t), s = Math.min(this.getLineWidth(), n / 2), a = this.startPoint.width / 2, l = this.endPoint.width / 2, c = e.minus(o.times(s)), d = o.orthog(), h = d.times(a), u = d.times(l), p = new i.Path(c.minus(u), [{ kind: i.PathCommandType.LineTo, point: t.minus(h) }, { kind: i.PathCommandType.LineTo, point: t.plus(h) }, { kind: i.PathCommandType.LineTo, point: c.plus(u) }, { kind: i.PathCommandType.LineTo, point: c.plus(d.times(s).plus(u)) }, { kind: i.PathCommandType.LineTo, point: e.plus(o.times(l)) }, { kind: i.PathCommandType.LineTo, point: c.plus(d.times(-s).minus(u)) }, { kind: i.PathCommandType.LineTo, point: c.minus(u) }]).mapPoints((t => this.viewport.roundPoint(t))); return new r.default([{ startPoint: p.startPoint, commands: p.parts, style: { fill: this.startPoint.color } }]) } build() { return this.buildPreview() } preview(t) { this.buildPreview().render(t) } addPoint(t) { this.endPoint = t } } e.default = a }, 22: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.makeOutlinedCircleBuilder = void 0; const i = o(5379), r = o(8258), s = n(o(4093)), a = n(o(2066)), l = n(o(8091)); e.makeOutlinedCircleBuilder = (0, l.default)(((t, e) => new c(t, e))); class c { constructor(t, e) { this.startPoint = t, this.viewport = e, this.endPoint = t } getBBox() { return this.buildPreview().getBBox() } buildPreview() { const t = [], e = 2 * Math.PI / 6, o = s.default.roundPoint(this.endPoint.width, 5 / this.viewport.getScaleFactor()), n = this.startPoint.pos.lerp(this.endPoint.pos, .5), l = this.endPoint.pos.minus(n).length() - o / 2, c = n.plus(i.Vec2.of(l, 0)); for (let o = e; o <= 2 * Math.PI; o += e) { const r = i.Vec2.of(l * Math.cos(o), -l * Math.sin(o)).plus(n), s = 1.141, a = i.Vec2.of(Math.cos(o - e / 2), -Math.sin(o - e / 2)).times(l * s).plus(n); t.push({ kind: i.PathCommandType.QuadraticBezierTo, controlPoint: a, endPoint: r }) } t.push({ kind: i.PathCommandType.LineTo, point: c }); const d = new i.Path(c, t).mapPoints((t => this.viewport.roundPoint(t))); return new a.default([(0, r.pathToRenderable)(d, { fill: i.Color4.transparent, stroke: { width: o, color: this.endPoint.color } })]) } build() { return this.buildPreview() } preview(t) { this.buildPreview().render(t) } addPoint(t) { this.endPoint = t } } }, 9177: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.makeFreehandLineBuilder = void 0; const i = o(5379), r = n(o(2066)), s = n(o(4093)), a = o(780), l = n(o(3172)); e.makeFreehandLineBuilder = (0, l.default)(((t, e) => { const o = 3 * e.getSizeOfPixelOnCanvas(), n = e.getSizeOfPixelOnCanvas(); return new c(t, n, o, e) })); class c { constructor(t, e, o, n) { this.startPoint = t, this.minFitAllowed = e, this.viewport = n, this.isFirstSegment = !0, this.parts = [], this.widthAverageNumSamples = 1, this.curveFitter = new a.StrokeSmoother(t, e, o, (t => this.addCurve(t))), this.averageWidth = t.width, this.bbox = new i.Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0) } getBBox() { return this.bbox } getRenderingStyle() { return { fill: i.Color4.transparent, stroke: { color: this.startPoint.color, width: this.roundDistance(this.averageWidth) } } } previewCurrentPath() { const t = [...this.parts.slice(), ...this.curveToPathCommands(this.curveFitter.preview())]; return { startPoint: this.startPoint.pos, commands: t, style: this.getRenderingStyle() } } previewFullPath() { const t = this.previewCurrentPath(); return t ? [t] : null } previewStroke() { const t = this.previewFullPath(); return t ? new r.default(t) : null } preview(t) { const e = this.previewFullPath(); if (e) { const o = this.viewport.visibleRect; t.startObject(o); for (const o of e) t.drawPath(o); t.endObject() } } build() { return this.curveFitter.finalizeCurrentCurve(), this.previewStroke() } getMinFit() { let t = Math.min(this.minFitAllowed, this.averageWidth / 3); return t < 1e-10 && (t = this.minFitAllowed), t } roundPoint(t) { const e = this.getMinFit(); return s.default.roundPoint(t, e) } roundDistance(t) { const e = this.getMinFit(); return s.default.roundPoint(t, e) } curveToPathCommands(t) { if (!t) { if (!this.isFirstSegment) return []; const t = s.default.roundPoint(this.averageWidth / 10, Math.min(this.minFitAllowed, this.averageWidth / 10)), e = this.roundPoint(this.startPoint.pos); return [{ kind: i.PathCommandType.QuadraticBezierTo, controlPoint: e.plus(i.Vec2.of(t, t)), endPoint: e.plus(i.Vec2.of(0, t)) }, { kind: i.PathCommandType.QuadraticBezierTo, controlPoint: e.plus(i.Vec2.of(-t, t)), endPoint: e.plus(i.Vec2.of(-t, 0)) }, { kind: i.PathCommandType.QuadraticBezierTo, controlPoint: e.plus(i.Vec2.of(-t, -t)), endPoint: e.plus(i.Vec2.of(0, -t)) }, { kind: i.PathCommandType.QuadraticBezierTo, controlPoint: e.plus(i.Vec2.of(t, -t)), endPoint: e.plus(i.Vec2.of(t, 0)) }] } const e = []; return this.isFirstSegment && e.push({ kind: i.PathCommandType.MoveTo, point: this.roundPoint(t.startPoint) }), e.push({ kind: i.PathCommandType.QuadraticBezierTo, controlPoint: this.roundPoint(t.controlPoint), endPoint: this.roundPoint(t.endPoint) }), e } addCurve(t) { const e = this.curveToPathCommands(t); this.parts.push(...e), this.isFirstSegment && (this.isFirstSegment = !1) } addPoint(t) { this.curveFitter.addPoint(t), this.widthAverageNumSamples++, this.averageWidth = this.averageWidth * (this.widthAverageNumSamples - 1) / this.widthAverageNumSamples + t.width / this.widthAverageNumSamples } } e.default = c }, 9616: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.makeLineBuilder = void 0; const i = o(5379), r = o(8258), s = n(o(2066)), a = n(o(8091)); e.makeLineBuilder = (0, a.default)(((t, e) => new l(t, e))); class l { constructor(t, e) { this.startPoint = t, this.viewport = e, this.endPoint = t } getBBox() { return this.buildPreview().getBBox() } buildPreview() { const t = this.startPoint.pos, e = this.endPoint.pos, o = e.minus(t).normalized(), n = this.startPoint.width / 2, a = this.endPoint.width / 2, l = o.orthog(), c = l.times(n), d = l.times(a), h = t.minus(c), u = new i.Path(h, [{ kind: i.PathCommandType.LineTo, point: t.plus(c) }, { kind: i.PathCommandType.LineTo, point: e.plus(d) }, { kind: i.PathCommandType.LineTo, point: e.minus(d) }, { kind: i.PathCommandType.LineTo, point: t.minus(c) }]).mapPoints((t => this.viewport.roundPoint(t))); return new s.default([(0, r.pathToRenderable)(u, { fill: this.startPoint.color })]) } build() { return this.buildPreview() } preview(t) { this.buildPreview().render(t) } addPoint(t) { this.endPoint = t } } e.default = l }, 1342: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.makePolylineBuilder = void 0; const i = o(5379), r = n(o(2066)), s = n(o(4093)), a = n(o(3172)); e.makePolylineBuilder = (0, a.default)(((t, e) => { const o = .75 * e.getSizeOfPixelOnCanvas(); return new l(t, o, e) })); class l { constructor(t, e, o) { this.minFitAllowed = e, this.viewport = o, this.parts = [], this.widthAverageNumSamples = 1, this.lastLineSegment = null, this.averageWidth = t.width, this.startPoint = { ...t, pos: this.roundPoint(t.pos) }, this.lastPoint = this.startPoint.pos, this.bbox = new i.Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0), this.parts = [{ kind: i.PathCommandType.MoveTo, point: this.startPoint.pos }] } getBBox() { return this.bbox.grownBy(this.averageWidth) } getRenderingStyle() { return { fill: i.Color4.transparent, stroke: { color: this.startPoint.color, width: this.roundDistance(this.averageWidth) } } } previewCurrentPath() { const t = this.startPoint.pos, e = [...this.parts]; return e.length <= 1 && e.push({ kind: i.PathCommandType.LineTo, point: t.plus(i.Vec2.of(this.averageWidth / 4, 0)) }), { startPoint: t, commands: e, style: this.getRenderingStyle() } } previewFullPath() { return [this.previewCurrentPath()] } preview(t) { const e = this.previewFullPath(); if (e) { const o = this.viewport.visibleRect; t.startObject(o); for (const o of e) t.drawPath(o); t.endObject() } } build() { return new r.default(this.previewFullPath()) } getMinFit() { let t = Math.min(this.minFitAllowed, this.averageWidth / 4); return t < 1e-10 && (t = this.minFitAllowed), t } roundPoint(t) { const e = this.getMinFit(); return s.default.roundPoint(t, e) } roundDistance(t) { const e = this.getMinFit(); return s.default.roundPoint(t, e) } addPoint(t) { this.widthAverageNumSamples++, this.averageWidth = this.averageWidth * (this.widthAverageNumSamples - 1) / this.widthAverageNumSamples + t.width / this.widthAverageNumSamples; const e = this.roundPoint(t.pos); e.eq(this.lastPoint) || (this.lastLineSegment && this.lastLineSegment.direction.dot(e.minus(this.lastPoint).normalized()) > .997 && (this.parts.pop(), this.lastPoint = this.lastLineSegment.p1), this.parts.push({ kind: i.PathCommandType.LineTo, point: this.roundPoint(t.pos) }), this.bbox = this.bbox.grownToPoint(e), this.lastLineSegment = new i.LineSegment2(this.lastPoint, e), this.lastPoint = e) } } e.default = l }, 14: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.makePressureSensitiveFreehandLineBuilder = void 0; const i = o(5379), r = n(o(2066)), s = n(o(4093)), a = o(780), l = n(o(3172)); e.makePressureSensitiveFreehandLineBuilder = (0, l.default)(((t, e) => { const o = 3 * e.getSizeOfPixelOnCanvas(), n = e.getSizeOfPixelOnCanvas(); return new c(t, n, o, e) })); class c { constructor(t, e, o, n) { this.startPoint = t, this.minFitAllowed = e, this.viewport = n, this.isFirstSegment = !0, this.pathStartConnector = null, this.mostRecentConnector = null, this.nextCurveStartConnector = null, this.lastUpperBezier = null, this.lastLowerBezier = null, this.parts = [], this.upperSegments = [], this.lowerSegments = [], this.curveFitter = new a.StrokeSmoother(t, e, o, (t => this.addCurve(t))), this.curveStartWidth = t.width, this.bbox = new i.Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0) } getBBox() { return this.bbox } getRenderingStyle() { return { fill: this.startPoint.color ?? null } } previewCurrentPath(t = !0) { const e = this.upperSegments.slice(), o = this.lowerSegments.slice(); let n, r; const s = this.curveFitter.preview(); if (s && t) { const { upperCurveCommand: t, lowerToUpperConnector: i, upperToLowerConnector: a, lowerCurveCommand: l } = this.segmentToPath(s); e.push(t), o.push(l), n = i, r = this.pathStartConnector ?? [a] } else { if (null === this.mostRecentConnector || null === this.pathStartConnector) return null; n = this.mostRecentConnector, r = this.pathStartConnector } let a; const l = o[o.length - 1]; return a = l.kind === i.PathCommandType.LineTo || l.kind === i.PathCommandType.MoveTo ? l.point : l.endPoint, { startPoint: a, commands: [n, ...e.reverse(), ...r, ...o], style: this.getRenderingStyle() } } previewFullPath() { const t = this.previewCurrentPath(); return t ? [...this.parts, t] : null } preview(t) { const e = this.previewFullPath(); if (e) { const o = this.viewport.visibleRect; t.startObject(o); for (const o of e) t.drawPath(o); t.endObject() } } build() { return this.curveFitter.finalizeCurrentCurve(), this.isFirstSegment && this.addCurve(null), new r.default(this.previewFullPath()) } roundPoint(t) { let e = Math.min(this.minFitAllowed, this.curveStartWidth / 3); return e < 1e-10 && (e = this.minFitAllowed), s.default.roundPoint(t, e) } shouldStartNewSegment(t, e) { if (!this.lastLowerBezier || !this.lastUpperBezier) return !1; const o = (t, e) => { const o = t.intersectsBezier(e); return o.length ? o[0].point : null }, n = t => t.p2.minus(t.p1).normalized(), i = t => t.p1.minus(t.p0).normalized(); if (i(e).dot(n(this.lastUpperBezier)) < .35 || i(t).dot(n(this.lastLowerBezier)) < .35 || i(e).dot(n(e)) < 0 || i(t).dot(n(t)) < 0) return !0; const r = o(t, this.lastUpperBezier), s = o(e, this.lastLowerBezier); return !(!r && !s) } addCurve(t) { if (!t) { if (!this.isFirstSegment) return; const t = s.default.roundPoint(this.startPoint.width / 2.2, Math.min(this.minFitAllowed, this.startPoint.width / 4)), e = this.roundPoint(this.startPoint.pos), o = this.startPoint.pos.plus(i.Vec2.of(t, 0)); this.lowerSegments.push({ kind: i.PathCommandType.QuadraticBezierTo, controlPoint: e.plus(i.Vec2.of(t, t)), endPoint: e.plus(i.Vec2.of(0, t)) }, { kind: i.PathCommandType.QuadraticBezierTo, controlPoint: e.plus(i.Vec2.of(-t, t)), endPoint: e.plus(i.Vec2.of(-t, 0)) }, { kind: i.PathCommandType.QuadraticBezierTo, controlPoint: e.plus(i.Vec2.of(-t, -t)), endPoint: e.plus(i.Vec2.of(0, -t)) }, { kind: i.PathCommandType.QuadraticBezierTo, controlPoint: e.plus(i.Vec2.of(t, -t)), endPoint: e.plus(i.Vec2.of(t, 0)) }); const n = { kind: i.PathCommandType.LineTo, point: o }; return this.pathStartConnector = [n], void (this.mostRecentConnector = n) } const { upperCurveCommand: e, lowerToUpperConnector: o, upperToLowerConnector: n, lowerCurveCommand: r, lowerCurve: a, upperCurve: l, nextCurveStartConnector: c } = this.segmentToPath(t); let d = this.shouldStartNewSegment(a, l); if (d) { const t = this.previewCurrentPath(!1); t ? (this.parts.push(t), this.upperSegments = [], this.lowerSegments = []) : d = !1 } (this.isFirstSegment || d) && (this.pathStartConnector = this.nextCurveStartConnector ?? [n], this.isFirstSegment = !1), this.mostRecentConnector = o, this.nextCurveStartConnector = c, this.lowerSegments.push(r), this.upperSegments.push(e), this.lastLowerBezier = a, this.lastUpperBezier = l, this.curveStartWidth = t.startWidth } segmentToPath(t) { const e = new i.QuadraticBezier(t.startPoint, t.controlPoint, t.endPoint); let o = e.normal(0), n = e.normal(1); o = o.times(t.startWidth / 2), n = n.times(t.endWidth / 2), isFinite(o.magnitude()) || (console.error("Warning: startVec is NaN or ∞", o, n, t), o = n); const r = t.startPoint, s = t.endPoint, a = t.controlPoint, l = e.nearestPointTo(a).parameterValue, c = e.normal(l).times(t.startWidth / 2 * l + t.endWidth / 2 * (1 - l)), d = this.roundPoint(r.plus(o)), h = this.roundPoint(a.plus(c)), u = this.roundPoint(s.plus(n)), p = this.roundPoint(a.minus(c)), f = this.roundPoint(s.minus(n)), m = this.roundPoint(r.minus(o)), g = { kind: i.PathCommandType.QuadraticBezierTo, controlPoint: h, endPoint: u }, b = { kind: i.PathCommandType.LineTo, point: d }, y = { kind: i.PathCommandType.LineTo, point: f }, v = [{ kind: i.PathCommandType.LineTo, point: f }, { kind: i.PathCommandType.LineTo, point: u }]; return { upperCurveCommand: { kind: i.PathCommandType.QuadraticBezierTo, controlPoint: p, endPoint: m }, upperToLowerConnector: b, lowerToUpperConnector: y, lowerCurveCommand: g, upperCurve: new i.QuadraticBezier(f, p, m), lowerCurve: new i.QuadraticBezier(d, h, u), nextCurveStartConnector: v } } addPoint(t) { this.curveFitter.addPoint(t) } } e.default = c }, 117: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.makeOutlinedRectangleBuilder = e.makeFilledRectangleBuilder = void 0; const i = o(5379), r = o(8258), s = n(o(2066)), a = n(o(8091)); e.makeFilledRectangleBuilder = (0, a.default)(((t, e) => new l(t, !0, e))), e.makeOutlinedRectangleBuilder = (0, a.default)(((t, e) => new l(t, !1, e))); class l { constructor(t, e, o) { this.startPoint = t, this.filled = e, this.viewport = o, this.endPoint = t } getBBox() { return this.buildPreview().getBBox() } buildPreview() { const t = this.viewport.getRotationAngle(), e = i.Mat33.zRotation(-t), o = e.inverse().transformVec2(this.startPoint.pos), n = e.inverse().transformVec2(this.endPoint.pos), a = i.Rect2.fromCorners(o, n), l = i.Path.fromRect(a, this.filled ? null : this.endPoint.width).transformedBy(e).mapPoints((t => this.viewport.roundPoint(t))); return new s.default([(0, r.pathToRenderable)(l, { fill: this.endPoint.color })]) } build() { return this.buildPreview() } preview(t) { this.buildPreview().render(t) } addPoint(t) { this.endPoint = t } } e.default = l }, 3172: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); const n = o(5379); e.default = t => (e, o) => new s(t, e, o); const i = (t, e, o) => ({ points: [t, e[e.length - 1]] }), r = (t, e, o) => ({ points: [...o.corners, o.corners[0]] }); class s { constructor(t, e, o) { this.sourceFactory = t, this.startPoint = e, this.viewport = o, this.builder = t(e, o), this.points = [e] } getBBox() { return this.builder.getBBox() } build() { return this.builder.build() } preview(t) { this.builder.preview(t) } addPoint(t) { this.points.push(t), this.builder.addPoint(t) } async autocorrectShape() { const t = this.viewport.canvasToScreen(this.startPoint.pos), e = this.points.map((t => this.viewport.canvasToScreen(t.pos))), o = n.Rect2.bboxOf(e), s = this.viewport.canvasToScreen(this.viewport.snapToGrid(this.startPoint.pos)), a = this.points.map((t => this.viewport.canvasToScreen(this.viewport.snapToGrid(t.pos)))), l = n.Rect2.bboxOf(a); if (o.maxDimension < 32) return null; const c = Math.min(30, o.maxDimension / 4), d = [{ ...i(s, a), toleranceMultiplier: .5 }, i(t, e), { ...r(0, 0, l), toleranceMultiplier: .6 }, r(0, 0, o)], h = (o => { for (const i of d) { const r = i.points, s = o * o * (i.toleranceMultiplier ?? 1), a = t => { for (; t < 0;)t += r.length; return t %= r.length, r[t] }; let l = null, c = 1 / 0, d = 0; for (let e = 0; e < r.length; e++) { const o = r[e], n = o.squareDistanceTo(t); (!l || n < c) && (c = n, l = o, d = e) } let h = 0, u = d; for (const t of e) { let e = 1 / 0, o = u; const i = 6; for (let r = -i; r <= i; r++) { const i = u + r, s = a(i - 1), l = a(i), c = a(i + 1), d = new n.LineSegment2(s, l), h = new n.LineSegment2(l, c), p = d.distance(t), f = h.distance(t), m = Math.min(p, f), g = m * m; g < e && (e = g, o = i) } if (u = o, h = Math.max(e, h), h > s) break } if (h < s) return r } return null })(c); if (!h) return null; const u = this.points[this.points.length - 1], p = this.startPoint.width, f = u.width, m = this.startPoint.color, g = u.color, b = this.startPoint.time, y = u.time, v = t => { const e = h[Math.max(0, Math.floor(t))], o = h[Math.min(Math.ceil(t), h.length - 1)], n = e.lerp(o, t - Math.floor(t)), i = t / h.length; return { pos: this.viewport.screenToCanvas(n), width: p * (1 - i) + f * i, color: m.mix(g, i), time: b * (1 - i) + y * i } }, x = this.sourceFactory(v(0), this.viewport), w = h.length < 10; for (let t = 0; t < h.length; t++)w && x.addPoint(v(t - .001)), x.addPoint(v(t)), w && x.addPoint(v(t + .001)); return x.build() } } }, 8091: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); e.default = t => (e, n) => new o(t, e, n); class o { constructor(t, e, o) { this.sourceFactory = t, this.startPoint = e, this.viewport = o, this.builder = t(e, o), this.points = [e] } getBBox() { return this.builder.getBBox() } build() { return this.builder.build() } preview(t) { this.builder.preview(t) } addPoint(t) { this.points.push(t), this.builder.addPoint(t) } async autocorrectShape() { const t = t => ({ ...t, pos: this.viewport.snapToGrid(t.pos) }), e = t(this.startPoint), o = this.sourceFactory(e, this.viewport), n = this.points.map((e => t(e))); for (const t of n) o.addPoint(t); return o.build() } } }, 6938: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.makeOutlinedRectangleBuilder = e.makeFilledRectangleBuilder = e.makeLineBuilder = e.makeArrowBuilder = e.makeOutlinedCircleBuilder = e.makePressureSensitiveFreehandLineBuilder = e.makePolylineBuilder = e.makeFreehandLineBuilder = void 0; var n = o(9177); Object.defineProperty(e, "makeFreehandLineBuilder", { enumerable: !0, get: function () { return n.makeFreehandLineBuilder } }); var i = o(1342); Object.defineProperty(e, "makePolylineBuilder", { enumerable: !0, get: function () { return i.makePolylineBuilder } }); var r = o(14); Object.defineProperty(e, "makePressureSensitiveFreehandLineBuilder", { enumerable: !0, get: function () { return r.makePressureSensitiveFreehandLineBuilder } }); var s = o(22); Object.defineProperty(e, "makeOutlinedCircleBuilder", { enumerable: !0, get: function () { return s.makeOutlinedCircleBuilder } }); var a = o(8145); Object.defineProperty(e, "makeArrowBuilder", { enumerable: !0, get: function () { return a.makeArrowBuilder } }); var l = o(9616); Object.defineProperty(e, "makeLineBuilder", { enumerable: !0, get: function () { return l.makeLineBuilder } }); var c = o(117); Object.defineProperty(e, "makeFilledRectangleBuilder", { enumerable: !0, get: function () { return c.makeFilledRectangleBuilder } }), Object.defineProperty(e, "makeOutlinedRectangleBuilder", { enumerable: !0, get: function () { return c.makeOutlinedRectangleBuilder } }) }, 1508: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }) }, 3331: function (t, e, o) { "use strict"; var n, i = this && this.__createBinding || (Object.create ? function (t, e, o, n) { void 0 === n && (n = o); var i = Object.getOwnPropertyDescriptor(e, o); i && !("get" in i ? !e.__esModule : i.writable || i.configurable) || (i = { enumerable: !0, get: function () { return e[o] } }), Object.defineProperty(t, n, i) } : function (t, e, o, n) { void 0 === n && (n = o), t[n] = e[o] }), r = this && this.__setModuleDefault || (Object.create ? function (t, e) { Object.defineProperty(t, "default", { enumerable: !0, value: e }) } : function (t, e) { t.default = e }), s = this && this.__exportStar || function (t, e) { for (var o in t) "default" === o || Object.prototype.hasOwnProperty.call(e, o) || i(e, t, o) }, a = this && this.__importStar || (n = function (t) { return n = Object.getOwnPropertyNames || function (t) { var e = []; for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[e.length] = o); return e }, n(t) }, function (t) { if (t && t.__esModule) return t; var e = {}; if (null != t) for (var o = n(t), s = 0; s < o.length; s++)"default" !== o[s] && i(e, t, o[s]); return r(e, t), e }), l = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.ImageComponent = e.BackgroundComponentBackgroundType = e.BackgroundComponent = e.StrokeComponent = e.Text = e.TextComponent = e.isRestylableComponent = e.createRestyleComponentCommand = e.Stroke = e.AbstractComponent = e.StrokeSmoother = void 0, s(o(1508), e), s(o(6938), e); var c = o(780); Object.defineProperty(e, "StrokeSmoother", { enumerable: !0, get: function () { return l(c).default } }), s(o(3029), e); var d = o(3029); Object.defineProperty(e, "AbstractComponent", { enumerable: !0, get: function () { return l(d).default } }); const h = l(o(2066)); e.Stroke = h.default, e.StrokeComponent = h.default; const u = l(o(2170)); e.TextComponent = u.default, e.Text = u.default; const p = l(o(4686)); e.ImageComponent = p.default; const f = o(486); Object.defineProperty(e, "createRestyleComponentCommand", { enumerable: !0, get: function () { return f.createRestyleComponentCommand } }), Object.defineProperty(e, "isRestylableComponent", { enumerable: !0, get: function () { return f.isRestylableComponent } }); const m = a(o(2115)); e.BackgroundComponent = m.default, Object.defineProperty(e, "BackgroundComponentBackgroundType", { enumerable: !0, get: function () { return m.BackgroundType } }) }, 3539: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.defaultComponentLocalization = void 0, e.defaultComponentLocalization = { unlabeledImageNode: "Unlabeled image node", stroke: "Stroke", svgObject: "SVG Object", emptyBackground: "Empty background", gridBackground: "Grid background", filledBackgroundWithColor: t => `Filled background (${t})`, text: t => `Text object: ${t}`, imageNode: t => `Image: ${t}`, restyledElement: t => `Restyled ${t}` } }, 780: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.StrokeSmoother = void 0; const n = o(5379); class i { constructor(t, e, o, i) { this.startPoint = t, this.minFitAllowed = e, this.maxFitAllowed = o, this.onCurveAdded = i, this.isFirstSegment = !0, this.lastExitingVec = null, this.currentCurve = null, this.lastPoint = this.startPoint, this.buffer = [this.startPoint.pos], this.momentum = n.Vec2.zero, this.currentCurve = null, this.curveStartWidth = t.width, this.bbox = new n.Rect2(this.startPoint.pos.x, this.startPoint.pos.y, 0, 0) } getBBox() { return this.bbox } preview() { return this.currentCurve ? this.currentSegmentToPath() : null } approxCurrentCurveLength() { if (!this.currentCurve) return 0; const t = this.currentCurve.p0, e = this.currentCurve.p1, o = this.currentCurve.p2; return t.distanceTo(e) + o.distanceTo(e) } finalizeCurrentCurve() { if (!this.currentCurve) return; this.onCurveAdded(this.currentSegmentToPath()); const t = this.buffer[this.buffer.length - 1]; this.lastExitingVec = this.currentCurve.p2.minus(this.currentCurve.p1), console.assert(0 !== this.lastExitingVec.magnitude(), "lastExitingVec has zero length!"), this.buffer = [this.buffer[this.buffer.length - 2], t], this.currentCurve = null, this.isFirstSegment = !1 } currentSegmentToPath() { if (null == this.currentCurve) throw new Error("Invalid State: currentCurve is null!"); const t = this.currentCurve.normal(0).normalized(); if (!isFinite(t.magnitude())) throw new Error(`startVec(${t}) is NaN or ∞`); const e = this.currentCurve.at(0), o = this.currentCurve.at(1); return { startPoint: e, controlPoint: this.currentCurve.p1, endPoint: o, startWidth: this.curveStartWidth, endWidth: this.curveEndWidth } } computeExitingVec() { return this.momentum.normalized().times(this.lastPoint.width / 2) } addPoint(t) { if (this.lastPoint) { const e = 1e-10, o = t.time - this.lastPoint.time; if (t.pos.eq(this.lastPoint.pos, e) || 0 === o) return; if (isNaN(t.pos.magnitude())) return void console.warn("Discarding NaN point.", t); const n = Math.min(this.lastPoint.width, t.width) / 3; if (this.startPoint.pos.distanceTo(t.pos) < n && this.isFirstSegment) return; const i = o / 1e3, r = t.pos.minus(this.lastPoint.pos).times(1 / i); this.momentum = r } const e = this.lastPoint ?? t; this.lastPoint = t, this.buffer.push(t.pos); const o = t.width, i = this.curveEndWidth; if (this.curveEndWidth = o, this.bbox = this.bbox.grownToPoint(t.pos, o), null === this.currentCurve) { const r = e.pos, s = e.pos.plus(this.lastExitingVec ?? n.Vec2.unitX), a = t.pos; this.currentCurve = new n.QuadraticBezier(r, s, a), console.assert(!isNaN(r.magnitude()) && !isNaN(s.magnitude()) && !isNaN(a.magnitude()), "Expected !NaN"), this.isFirstSegment ? this.curveStartWidth = (this.curveStartWidth + o) / 2 : this.curveStartWidth = i } let r = this.lastExitingVec; if (!r) { let t = Math.ceil(this.buffer.length / 2); (0 === t || t >= this.buffer.length) && (t = this.buffer.length - 1), r = this.buffer[t].minus(this.buffer[0]) } let s = this.computeExitingVec(); const a = this.buffer[0], l = t.pos, c = l.distanceTo(a), d = 1.7 * c; if (0 === d || 0 === s.magnitude() || !isFinite(s.magnitude())) return; console.assert(isFinite(r.magnitude()), "Pre-normalized enteringVec has NaN or ∞ magnitude!"), r = r.normalized(), s = s.normalized(), console.assert(isFinite(r.magnitude()), "Normalized enteringVec has NaN or ∞ magnitude!"); const h = new n.LineSegment2(a, a.plus(r.times(d))), u = new n.LineSegment2(l.minus(s.times(d)), l).intersection(h); let p = null; u && (p = u.point), p || (p = a.lerp(l, .5).lerp(a.plus(r.times(c)), .1)), (a.eq(p) || l.eq(p)) && (p = a.plus(r.times(c / 5))), console.assert(!a.eq(p, 1e-11), "Start and control points are equal!"), console.assert(!p.eq(l, 1e-11), "Control and end points are equal!"); const f = this.currentCurve; this.currentCurve = new n.QuadraticBezier(a, p, l), isNaN(this.currentCurve.normal(0).magnitude()) && (console.error("NaN normal at 0. Curve:", this.currentCurve), this.currentCurve = f); const m = t => { const e = Math.min(Math.max(Math.min(this.curveStartWidth, this.curveEndWidth) / 4, this.minFitAllowed), this.maxFitAllowed), o = e; let n = 0; for (const i of this.buffer) { let r = t.approximateDistance(i); if (r > e && (r = t.distance(i), n += Math.max(0, r - e), n > o)) return !1 } return !0 }; return this.buffer.length > 3 && this.approxCurrentCurveLength() > this.curveStartWidth / 2 && !m(this.currentCurve) ? (this.currentCurve = f, this.curveEndWidth = i, this.lastPoint = e, void this.finalizeCurrentCurve()) : void 0 } } e.StrokeSmoother = i, e.default = i }, 3925: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = (t, e) => { if (0 === e.length) return null; const o = e[0].description(t); for (const n of e) if (n.description(t) !== o) return null; return o } }, 4690: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(8816)); e.default = (t, e) => { const o = (0, i.default)(t, { title: t.localization.about, contentClassNames: ["about-dialog-content"] }); for (const t of e) { const e = document.createElement(t.minimized ? "details" : "div"); e.classList.add("about-entry"); const n = document.createElement(t.minimized ? "summary" : "h2"); if ("string" == typeof t.heading) n.innerText = t.heading; else { const e = document.createElement("a"); e.href = t.heading.href.replace(/^javascript:/i, ""), e.text = t.heading.text, n.appendChild(e) } if (e.appendChild(n), t.text) { const o = document.createElement("div"); o.innerText = t.text, e.appendChild(o) } o.appendChild(e) } return { close: () => o.close() } } }, 8816: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(6453)); e.default = (t, e) => { const o = document.createElement("div"), { remove: n } = t.createHTMLOverlay(o); o.classList.add("dialog-container", "message-dialog-container", ...e.classNames ?? []); const r = document.createElement("dialog"), s = document.createElement("div"); s.classList.add("message-dialog-content", ...e.contentClassNames ?? []); const a = document.createElement("h1"); a.textContent = e.title, a.setAttribute("autofocus", "true"); const l = document.createElement("button"); l.innerText = t.localization.closeDialog, l.classList.add("close"); const c = document.createElement("div"); c.classList.add("scroll"), c.onwheel = t => t.stopPropagation(), s.replaceChildren(a, c, l), r.replaceChildren(s), o.replaceChildren(r); r.style.setProperty("--close-delay", "300ms"); const d = async () => { r.classList.add("-closing"), await (0, i.default)(300), r.close() }; return r.addEventListener("pointerdown", (t => { t.target === r && d() })), r.onclose = () => { n() }, l.onclick = () => d(), r.showModal(), { close: () => d(), appendChild: t => { c.appendChild(t) } } } }, 7: function (t, e, o) { "use strict"; var n, i, r, s, a = this && this.__createBinding || (Object.create ? function (t, e, o, n) { void 0 === n && (n = o); var i = Object.getOwnPropertyDescriptor(e, o); i && !("get" in i ? !e.__esModule : i.writable || i.configurable) || (i = { enumerable: !0, get: function () { return e[o] } }), Object.defineProperty(t, n, i) } : function (t, e, o, n) { void 0 === n && (n = o), t[n] = e[o] }), l = this && this.__setModuleDefault || (Object.create ? function (t, e) { Object.defineProperty(t, "default", { enumerable: !0, value: e }) } : function (t, e) { t.default = e }), c = this && this.__importStar || (n = function (t) { return n = Object.getOwnPropertyNames || function (t) { var e = []; for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[e.length] = o); return e }, n(t) }, function (t) { if (t && t.__esModule) return t; var e = {}; if (null != t) for (var o = n(t), i = 0; i < o.length; i++)"default" !== o[i] && a(e, t, o[i]); return l(e, t), e }), d = this && this.__setFunctionName || function (t, e, o) { return "symbol" == typeof e && (e = e.description ? "[".concat(e.description, "]") : ""), Object.defineProperty(t, "name", { configurable: !0, value: o ? "".concat(o, " ", e) : e }) }, h = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.RootImageNode = e.ImageNode = e.computeFirstIndexToRender = e.EditorImageEventType = e.sortLeavesByZIndex = void 0; const u = h(o(4093)), p = c(o(3029)), f = o(5379), m = h(o(1434)), g = h(o(9118)), b = o(7571), y = h(o(1403)); var v; e.sortLeavesByZIndex = t => { t.sort(((t, e) => t.getContent().getZIndex() - e.getContent().getZIndex())) }, function (t) { t[t.ExportViewportChanged = 0] = "ExportViewportChanged", t[t.AutoresizeModeChanged = 1] = "AutoresizeModeChanged" }(v || (e.EditorImageEventType = v = {})); let x = !1; class w { constructor() { this.componentCount = 0, this.settingExportRect = !1, this.root = new T, this.background = new T, this.componentsById = Object.create(null), this.notifier = new g.default, this.importExportViewport = new u.default((() => { this.onExportViewportChanged() })), this.importExportViewport.updateScreenSize(f.Vec2.of(500, 500)), this.shouldAutoresizeExportViewport = !1 } getBackgroundComponents() { const t = [], o = this.background.getLeaves(); (0, e.sortLeavesByZIndex)(o); for (const e of o) { const o = e.getContent(); o && t.push(o) } return t } findParent(t) { return this.background.getChildWithContent(t) ?? this.root.getChildWithContent(t) } queueRerenderOf(t) { const e = this.findParent(t); e && (e.remove(), this.addElementDirectly(t)) } renderWithCache(t, e, o) { this.background.render(t, o.visibleRect), x ? this.root.render(t, o.visibleRect) : e.render(t, this.root, o) } render(t, e) { this.background.render(t, e?.visibleRect), this.root.render(t, e?.visibleRect) } async renderAllAsync(t, e) { return !!await this.background.renderAllAsync(t, e) && await this.root.renderAllAsync(t, e) } renderAll(t) { this.render(t, null) } getAllElements() { const t = this.root.getLeaves(); return (0, e.sortLeavesByZIndex)(t), t.map((t => t.getContent())) } estimateNumElements() { return this.componentCount } getElementsIntersectingRegion(t, o = !1) { let n = this.root.getLeavesIntersectingRegion(t); return o && (n = n.concat(this.background.getLeavesIntersectingRegion(t))), (0, e.sortLeavesByZIndex)(n), n.map((t => t.getContent())) } onDestroyElement(t) { this.componentCount--, delete this.componentsById[t.getId()], this.autoresizeExportViewport() } onElementAdded(t) { this.componentCount++, this.componentsById[t.getId()] = t, this.autoresizeExportViewport() } lookupElement(t) { return this.componentsById[t] ?? null } addElementDirectly(t) { t.onAddToImage(this); const e = (t.isBackground() ? this.background : this.root).addLeaf(t); return this.onElementAdded(t), e } removeElementDirectly(t) { const e = this.findParent(t); return e?.remove(), !!e && (this.onDestroyElement(t), !0) } static addElement(t, e = !1) { return new i.AddElementCommand(t, e) } addElement(t, e) { return i.addElement(t, e) } getImportExportViewport() { return this.importExportViewport } getImportExportRect() { return this.getImportExportViewport().visibleRect } setImportExportRect(t) { return i.SetImportExportRectCommand.of(this, t, !1) } getAutoresizeEnabled() { return this.shouldAutoresizeExportViewport } setAutoresizeEnabled(t) { if (t === this.shouldAutoresizeExportViewport) return y.default.empty; const e = this.root.getBBox(); return i.SetImportExportRectCommand.of(this, e, t) } setAutoresizeEnabledDirectly(t) { t !== this.shouldAutoresizeExportViewport && (this.shouldAutoresizeExportViewport = t, this.notifier.dispatch(v.AutoresizeModeChanged, { image: this })) } autoresizeExportViewport() { this.shouldAutoresizeExportViewport && this.setExportRectDirectly(this.root.getBBox()) } setExportRectDirectly(t) { const e = this.getImportExportViewport(), o = e.getScreenRectSize(), n = e.canvasToScreenTransform, i = f.Mat33.translation(t.topLeft.times(-1)); return (!o.eq(t.size) || !n.eq(i)) && (this.settingExportRect = !0, e.updateScreenSize(t.size), e.resetTransform(i), this.settingExportRect = !1, this.onExportViewportChanged(), !0) } onExportViewportChanged() { this.settingExportRect || this.notifier.dispatch(v.ExportViewportChanged, { image: this }) } static setDebugMode(t) { x = t } } i = w, w.AddElementCommand = (d(r = class extends m.default { constructor(t, e = !1) { if (super("add-element"), this.element = t, this.applyByFlattening = e, this.serializedElem = null, this.serializedElem = null, isNaN(t.getBBox().area)) throw new Error("Elements in the image cannot have NaN bounding boxes") } apply(t) { t.image.addElementDirectly(this.element), this.applyByFlattening ? (this.applyByFlattening = !1, t.display.flatten()) : t.queueRerender() } unapply(t) { t.image.removeElementDirectly(this.element), t.queueRerender() } description(t, e) { return e.addElementAction(this.element.description(e)) } serializeToJSON() { return { elemData: this.serializedElem ?? this.element.serialize() } } }, "AddElementCommand"), m.default.register("add-element", ((t, e) => { const o = t.elemData.id, n = e.image.lookupElement(o) ?? p.default.deserialize(t.elemData), r = new i.AddElementCommand(n); return r.serializedElem = t.elemData, r })), r), w.SetImportExportRectCommand = (d(s = class extends m.default { constructor(t, e, o, n, r) { super(i.SetImportExportRectCommand.commandId), this.originalSize = t, this.originalTransform = e, this.originalAutoresize = o, this.newExportRect = n, this.newAutoresize = r } static of(t, e, o) { const n = t.getImportExportViewport(), r = n.visibleRect.size, s = n.canvasToScreenTransform, a = t.getAutoresizeEnabled(); return new i.SetImportExportRectCommand(r, s, a, e, o) } apply(t) { t.image.setAutoresizeEnabledDirectly(this.newAutoresize), t.image.setExportRectDirectly(this.newExportRect), t.queueRerender() } unapply(t) { const e = t.image.getImportExportViewport(); t.image.setAutoresizeEnabledDirectly(this.originalAutoresize), e.updateScreenSize(this.originalSize), e.resetTransform(this.originalTransform), t.queueRerender() } description(t, e) { return this.newAutoresize !== this.originalAutoresize ? this.newAutoresize ? e.enabledAutoresizeOutputCommand : e.disabledAutoresizeOutputCommand : e.resizeOutputCommand(this.newExportRect) } serializeToJSON() { return { originalSize: this.originalSize.xy, originalTransform: this.originalTransform.toArray(), newRegion: { x: this.newExportRect.x, y: this.newExportRect.y, w: this.newExportRect.w, h: this.newExportRect.h }, autoresize: this.newAutoresize, originalAutoresize: this.originalAutoresize } } }, "SetImportExportRectCommand"), s.commandId = "set-import-export-rect", (() => { const t = s.commandId; m.default.register(t, ((t, e) => { (0, b.assertIsNumber)(t.originalSize.x), (0, b.assertIsNumber)(t.originalSize.y), (0, b.assertIsNumberArray)(t.originalTransform), (0, b.assertIsNumberArray)([t.newRegion.x, t.newRegion.y, t.newRegion.w, t.newRegion.h]), (0, b.assertIsBoolean)(t.autoresize ?? !1), (0, b.assertIsBoolean)(t.originalAutoresize ?? !1); const o = f.Vec2.ofXY(t.originalSize), n = new f.Mat33(...t.originalTransform), r = new f.Rect2(t.newRegion.x, t.newRegion.y, t.newRegion.w, t.newRegion.h), s = t.autoresize ?? !1, a = t.originalAutoresize ?? !1; return new i.SetImportExportRectCommand(o, n, a, r, s) })) })(), s), e.default = w; e.computeFirstIndexToRender = (t, e) => { let o = 0; if (e) for (let n = t.length - 1; n >= 1; n--)if (t[n].getBBox().containsRect(e) && t[n].getContent()?.occludesEverythingBelowWhenRenderedInRect(e)) { o = n; break } return o }; class S { constructor(t = null) { this.parent = t, this.targetChildCount = 30, this.children = [], this.bbox = f.Rect2.empty, this.content = null, this.id = S.idCounter++ } getId() { return this.id } onContentChange() { this.id = S.idCounter++ } getContent() { return this.content } getParent() { return this.parent } getChildrenIntersectingRegion(t, e) { return this.children.filter((o => { const n = o.getBBox(); return !e?.(n) && n.intersects(t) })) } getChildrenOrSelfIntersectingRegion(t) { return this.content ? [this] : this.getChildrenIntersectingRegion(t) } getLeavesIntersectingRegion(t, e) { const o = [], n = []; for (n.push(this); n.length > 0;) { const i = n.pop(); null !== i.content && o.push(i), n.push(...i.getChildrenIntersectingRegion(t, e)) } return o } getChildWithContent(t) { const e = this.getLeavesIntersectingRegion(t.getBBox()); for (const o of e) if (o.getContent() === t) return o; return null } getLeaves() { if (this.content) return [this]; const t = []; for (const e of this.children) t.push(...e.getLeaves()); return t } addLeaf(t) { if (this.onContentChange(), null === this.content && 0 === this.children.length) return this.content = t, this.recomputeBBox(!0), this; if (null !== this.content) { console.assert(0 === this.children.length); const t = new S(this); t.content = this.content, this.content = null, this.children.push(t), t.recomputeBBox(!1) } const e = t.getBBox(); if (e.containsRect(this.getBBox())) { const e = new S(this); if (this.children.length < this.targetChildCount) this.children.push(e); else { const t = new S(this); t.children = this.children, this.children = [e, t], t.updateParents(), t.recomputeBBox(!0) } return e.addLeaf(t) } const o = this.children.filter((t => t.getBBox().containsRect(e))); if (o.length > 0 && this.children.length >= this.targetChildCount) { o.sort(((t, e) => t.getBBox().area - e.getBBox().area)); const e = o[0].addLeaf(t); return e.rebalance(), e } const n = S.createLeafNode(this, t); return this.children.push(n), n.recomputeBBox(!0), this.children.length >= this.targetChildCount && this.rebalance(), n } static createLeafNode(t, e) { const o = new S(t); return o.content = e, o } getBBox() { return this.bbox } recomputeBBox(t) { const e = this.bbox; null !== this.content ? this.bbox = this.content.getBBox() : this.bbox = f.Rect2.union(...this.children.map((t => t.getBBox()))), t && !e.eq(this.bbox) && (this.bbox.containsRect(e) ? this.parent?.unionBBoxWith(this.bbox) : this.parent?.recomputeBBox(!0)), this.checkRep() } unionBBoxWith(t) { this.bbox = this.bbox.union(t), this.parent?.unionBBoxWith(t) } updateParents(t = !1) { for (const e of this.children) e.parent = this, t && e.updateParents(t) } rebalance() { if (this.parent && 1 === this.parent.children.length) { console.assert(null === this.parent.content), console.assert(this.parent.children[0] === this); const t = this.parent; if (null !== t.parent) { const e = t.parent; e.children = e.children.filter((e => e !== t)), t.parent = null, t.children = [], this.parent = e, e.children.push(this), this.parent.recomputeBBox(!1) } else null === this.content && (this.parent.children = this.children, this.parent.updateParents(), this.parent = null) } if (this.children.length > 10 * this.targetChildCount) { const t = this.getBBox().divideIntoGrid(4, 4), e = []; for (; e.length < t.length;)e.push(0); for (const o of this.children) for (let n = 0; n < t.length; n++)t[n].containsRect(o.getBBox()) && e[n]++; let o = 0, n = e[0]; for (let t = 1; t < e.length; t++)e[t] > n && (o = t, n = e[t]); const i = t[o]; if (n > 4) { const t = [], e = []; for (const o of this.children) i.containsRect(o.getBBox()) ? e.push(o) : t.push(o); if (e.length < this.children.length) { this.children = t; const o = new S(this); this.children.push(o), o.children = e, o.updateParents(!1), o.recomputeBBox(!1), o.rebalance() } } } this.parent && 0 === this.children.length && null === this.content && this.remove() } removeChild(t) { this.checkRep(); const e = this.children.length; this.children = this.children.filter((e => e !== t)), console.assert(this.children.length === e - 1, `${e - 1} ≠ ${this.children.length} after removing all nodes equal to ${t}. Nodes should only be removed once.`), this.children.forEach((t => { t.rebalance() })), this.recomputeBBox(!0), this.rebalance(), this.checkRep() } remove() { if (this.content?.onRemoveFromImage(), !this.parent) return this.content = null, void (this.children = []); this.parent.removeChild(this), this.parent = null, this.content = null, this.children = [], this.checkRep() } async renderAllAsync(t, o) { const n = this.getLeaves(); (0, e.sortLeavesByZIndex)(n); const i = n.length; for (let e = 0; e < i; e++) { const r = n[e].getContent(); if (!r) continue; if (!await o(r, e, i)) return !1; r.render(t, void 0) } return !0 } render(t, o) { let n; n = o ? this.getLeavesIntersectingRegion(o, (e => t.isTooSmallToRender(e))) : this.getLeaves(), (0, e.sortLeavesByZIndex)(n); const i = (0, e.computeFirstIndexToRender)(n); for (let e = i; e < n.length; e++) { n[e].getContent().render(t, o) } x && o && (0 !== i && console.log("EditorImage: skipped ", i, "nodes due to occlusion"), this.renderDebugBoundingBoxes(t, o)) } renderDebugBoundingBoxes(t, e, o = 0) { const n = this.getBBox(), i = 1 / (t.getSizeOfCanvasPixelOnScreen() || 1); if (n.maxDimension < 3 * i || !n.intersects(e)) return; t.startObject(n); const r = !!this.content, s = r ? f.Color4.ofRGBA(1, 0, 1, .4) : f.Color4.ofRGBA(0, 1, Math.sin(o), .6), a = r ? 1 * i : 2 * i; if (t.drawRect(n.intersection(e), a, { fill: s }), t.endObject(), n.maxDimension > e.maxDimension / 3) { const e = { fontFamily: "monospace", size: n.minDimension / 20, renderingStyle: { fill: f.Color4.red } }; t.drawText(`Depth: ${o}`, f.Mat33.translation(n.bottomLeft), e) } for (const n of this.children) n.renderDebugBoundingBoxes(t, e, o + 1) } checkRep(t = 0) { if (x) { if (this.parent && !this.parent.children.includes(this)) throw new Error(`Parent does not have this node as a child. (depth: ${t})`); let e = null; const o = new Set; for (const t of this.children) { if (e ??= t.getBBox(), e = e.union(t.getBBox()), t.parent !== this) throw new Error(`Child with bbox ${t.getBBox()} and ${t.children.length} has wrong parent (was ${t.parent}).`); if (o.has(t)) throw new Error(`Child ${t} is present twice or more in its parent's child list`); o.add(t) } const n = this.bbox.minDimension / 100; if (e && !this.bbox.eq(e, n)) throw new Error(`Wrong bounding box ${e} \\neq ${this.bbox} (depth: ${t})`) } } } e.ImageNode = S, S.idCounter = 0; class T extends S { constructor() { super(...arguments), this.fullscreenChildren = [], this.dataComponents = [] } getChildrenIntersectingRegion(t, e) { const o = super.getChildrenIntersectingRegion(t); for (const t of this.fullscreenChildren) o.push(t); return o } getLeaves() { const t = super.getLeaves(); return this.dataComponents.concat(this.fullscreenChildren, t) } removeChild(t) { let e = !1; const o = o => { const n = o === t; return e ||= n, !n }; this.dataComponents = this.dataComponents.filter(o), this.fullscreenChildren = this.fullscreenChildren.filter(o), e || super.removeChild(t) } getChildWithContent(t) { const e = () => { const e = this.fullscreenChildren.concat(this.dataComponents); for (const o of e) if (o.getContent() === t) return o; return null }; return t.getSizingMode(), p.ComponentSizingMode.BoundingBox, super.getChildWithContent(t) ?? e() } addLeaf(t) { const e = t.getSizingMode(); if (e === p.ComponentSizingMode.BoundingBox) return super.addLeaf(t); if (e === p.ComponentSizingMode.FillScreen) { this.onContentChange(); const e = S.createLeafNode(this, t); return this.fullscreenChildren.push(e), e } if (e === p.ComponentSizingMode.Anywhere) { this.onContentChange(); const e = S.createLeafNode(this, t); return this.dataComponents.push(e), e } throw new Error(`Invalid sizing mode, ${e}`) } } e.RootImageNode = T }, 495: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); const n = o(5379); e.default = (t, e, o) => { let i = e.w, r = e.h; if (o?.minDimension && i < o.minDimension) { const t = o.minDimension; r *= t / (i || 1), i = t } if (o?.minDimension && r < o.minDimension) { const t = o.minDimension; i *= t / (r || 1), r = t } t.setAttribute("width", (0, n.toRoundedString)(i)), t.setAttribute("height", (0, n.toRoundedString)(r)) } }, 9261: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.editorImageToSVGAsync = e.editorImageToSVGSync = void 0; const i = o(5379), r = n(o(1598)), s = o(3604), a = n(o(495)), l = (t, e, o) => { const n = t.getImportExportViewport().getTemporaryClone(); if (o?.minDimension) { const t = n.visibleRect; let e = t; e.w <= 0 && (e = new i.Rect2(e.x, e.y, o.minDimension, e.h)), e.h <= 0 && (e = new i.Rect2(e.x, e.y, e.w, o.minDimension)), e.eq(t) || n.updateScreenSize(e.size) } const { element: l, renderer: c } = r.default.fromViewport(n, { sanitize: o.sanitize ?? !1, useViewBoxForPositioning: !0 }); return e(c, (() => { t.getAutoresizeEnabled() ? l.classList.add(s.svgLoaderAutoresizeClassName) : l.classList.remove(s.svgLoaderAutoresizeClassName); const e = n.visibleRect; return (0, a.default)(l, e, o), l })), l }; e.editorImageToSVGSync = (t, e) => l(t, ((e, o) => { t.renderAll(e), o() }), e); e.editorImageToSVGAsync = (t, e, o) => new Promise((n => { l(t, (async (o, i) => { await t.renderAllAsync(o, e); const r = i(); n(r) }), o) })) }, 278: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.EditorImage = void 0; var i = o(7); Object.defineProperty(e, "EditorImage", { enumerable: !0, get: function () { return n(i).default } }) }, 7394: (t, e) => { "use strict"; var o; Object.defineProperty(e, "__esModule", { value: !0 }), e.isPointerEvt = e.keyPressEventFromHTMLEvent = e.keyUpEventFromHTMLEvent = e.InputEvtType = void 0, function (t) { t[t.PointerDownEvt = 0] = "PointerDownEvt", t[t.PointerMoveEvt = 1] = "PointerMoveEvt", t[t.PointerUpEvt = 2] = "PointerUpEvt", t[t.GestureCancelEvt = 3] = "GestureCancelEvt", t[t.WheelEvt = 4] = "WheelEvt", t[t.KeyPressEvent = 5] = "KeyPressEvent", t[t.KeyUpEvent = 6] = "KeyUpEvent", t[t.CopyEvent = 7] = "CopyEvent", t[t.PasteEvent = 8] = "PasteEvent", t[t.ContextMenu = 9] = "ContextMenu" }(o || (e.InputEvtType = o = {})); const n = (t, e) => ({ kind: t, key: e.key, code: e.code, ctrlKey: e.ctrlKey || e.metaKey, altKey: e.altKey, shiftKey: e.shiftKey }); e.keyUpEventFromHTMLEvent = t => n(o.KeyUpEvent, t); e.keyPressEventFromHTMLEvent = t => n(o.KeyPressEvent, t); e.isPointerEvt = t => t.kind === o.PointerDownEvt || t.kind === o.PointerMoveEvt || t.kind === o.PointerUpEvt }, 6592: function (t, e, o) { "use strict"; var n = this && this.__createBinding || (Object.create ? function (t, e, o, n) { void 0 === n && (n = o); var i = Object.getOwnPropertyDescriptor(e, o); i && !("get" in i ? !e.__esModule : i.writable || i.configurable) || (i = { enumerable: !0, get: function () { return e[o] } }), Object.defineProperty(t, n, i) } : function (t, e, o, n) { void 0 === n && (n = o), t[n] = e[o] }), i = this && this.__exportStar || function (t, e) { for (var o in t) "default" === o || Object.prototype.hasOwnProperty.call(e, o) || n(e, t, o) }, r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.HTMLToolbar = e.AbstractToolbar = e.Editor = e.__js_draw__version = e.UndoRedoHistory = e.PointerDevice = e.Pointer = e.EventDispatcher = e.Viewport = e.SVGLoader = e.matchingLocalizationTable = e.getLocalizationTable = void 0; const s = r(o(3954)); e.Editor = s.default, i(o(278), e), i(o(2018), e), i(o(7394), e); var a = o(2543); Object.defineProperty(e, "getLocalizationTable", { enumerable: !0, get: function () { return r(a).default } }), Object.defineProperty(e, "matchingLocalizationTable", { enumerable: !0, get: function () { return a.matchingLocalizationTable } }), i(o(5246), e); var l = o(3604); Object.defineProperty(e, "SVGLoader", { enumerable: !0, get: function () { return r(l).default } }); var c = o(4093); Object.defineProperty(e, "Viewport", { enumerable: !0, get: function () { return r(c).default } }), i(o(5379), e), i(o(3331), e), i(o(525), e), i(o(6532), e), i(o(3280), e), i(o(1063), e), i(o(9611), e), i(o(4772), e); var d = o(9118); Object.defineProperty(e, "EventDispatcher", { enumerable: !0, get: function () { return r(d).default } }); var h = o(578); Object.defineProperty(e, "Pointer", { enumerable: !0, get: function () { return r(h).default } }), Object.defineProperty(e, "PointerDevice", { enumerable: !0, get: function () { return h.PointerDevice } }); var u = o(1721); Object.defineProperty(e, "UndoRedoHistory", { enumerable: !0, get: function () { return r(u).default } }), i(o(9395), e); var p = o(5711); Object.defineProperty(e, "__js_draw__version", { enumerable: !0, get: function () { return r(p).default } }); const f = r(o(2101)); e.AbstractToolbar = f.default, e.HTMLToolbar = f.default, e.default = s.default }, 5246: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.defaultEditorLocalization = void 0; const n = o(9985), i = o(3539), r = o(4215), s = o(7806), a = o(8658); e.defaultEditorLocalization = { ...s.defaultToolbarLocalization, ...a.defaultToolLocalization, ...n.defaultCommandLocalization, ...i.defaultComponentLocalization, ...r.defaultTextRendererLocalization, accessibilityInputInstructions: ['Press "t" to read the contents of the viewport as text.', "Use the arrow keys to move the viewport, click and drag to draw strokes.", 'Press "w" to zoom in and "s" to zoom out.'].join(" "), loading: t => `Loading ${t}%...`, imageEditor: "Image Editor", doneLoading: "Done loading", undoAnnouncement: t => `Undid ${t}`, redoAnnouncement: t => `Redid ${t}`, softwareLibraries: "Libraries", developerInformation: "Developer information" } }, 8351: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); const n = { ...o(5246).defaultEditorLocalization, pen: "Stift", eraser: "Radierer", select: "Auswahl", handTool: "Verschieben", zoom: "Vergrößerung", image: "Bild", inputAltText: "Alt-Text: ", chooseFile: "Wähle Datei: ", submit: "Absenden", cancel: "Abbrechen", resetView: "Ansicht zurücksetzen", thicknessLabel: "Dicke: ", colorLabel: "Farbe: ", fontLabel: "Schriftart: ", textSize: "Größe: ", resizeImageToSelection: "Bildgröße an Auswahl anpassen", deleteSelection: "Auswahl löschen", duplicateSelection: "Auswahl duplizieren", undo: "Rückgängig", redo: "Wiederholen", pickColorFromScreen: "Farbe von Bildschirm auswählen", clickToPickColorAnnouncement: "Klicke auf den Bildschirm, um eine Farbe auszuwählen", selectionToolKeyboardShortcuts: "Auswahl-Werkzeug: Verwende die Pfeiltasten, um ausgewählte Elemente zu verschieben und ‚i‘ und ‚o‘, um ihre Größe zu ändern.", touchPanning: "Ansicht mit Touchscreen verschieben", anyDevicePanning: "Ansicht mit jedem Eingabegerät verschieben", selectPenType: "Objekt-Typ: ", roundedTipPen: "Freihand", flatTipPen: "Stift (druckempfindlich)", arrowPen: "Pfeil", linePen: "Linie", outlinedRectanglePen: "Umrissenes Rechteck", filledRectanglePen: "Ausgefülltes Rechteck", lockRotation: "Sperre Rotation", paste: "Einfügen", dropdownShown: t => `Dropdown-Menü für ${t} angezeigt`, dropdownHidden: t => `Dropdown-Menü für ${t} versteckt`, zoomLevel: t => `Vergößerung: ${t}%`, colorChangedAnnouncement: t => `Farbe zu ${t} geändert`, imageSize: (t, e) => `Bild-Größe: ${t} ${e}`, imageLoadError: t => `Fehler beim Laden des Bildes: ${t}`, errorImageHasZeroSize: "Fehler: Bild hat Größe Null", penTool: t => `Stift ${t}`, selectionTool: "Auswahl", eraserTool: "Radiergummi", touchPanTool: "Ansicht mit Touchscreen verschieben", twoFingerPanZoomTool: "Ansicht verschieben und vergrößern", undoRedoTool: "Rückgängig/Wiederholen", rightClickDragPanTool: "Rechtsklick-Ziehen", pipetteTool: "Farbe von Bildschirm auswählen", keyboardPanZoom: "Tastaturkürzel zum Verschieben/Vergrößern der Ansicht", textTool: "Text", enterTextToInsert: "Einzufügender Text", changeTool: "Wechsle Werkzeug", pasteHandler: "Copy-Paste-Handler", findLabel: "Finde", toNextMatch: "Nächstes", closeDialog: "Schließen", findDialogShown: "Finde-Dialog angezeigt", findDialogHidden: "Finde-Dialog versteckt", focusedFoundText: (t, e) => `Sieh Treffer ${t} von ${e} an`, toolEnabledAnnouncement: t => `${t} aktiviert`, toolDisabledAnnouncement: t => `${t} deaktiviert`, updatedViewport: "Transformierte Ansicht", transformedElements: t => `${t} Element${1 === t ? "" : "e"} transformiert`, resizeOutputCommand: t => `Bildgröße auf ${t.w}x${t.h} geändert`, addElementAction: t => `${t} hinzugefügt`, eraseAction: (t, e) => `${e} ${t} gelöscht`, duplicateAction: (t, e) => `${e} ${t} dupliziert`, inverseOf: t => `${t} umgekehrt`, elements: "Elemente", erasedNoElements: "Nichts entfernt", duplicatedNoElements: "Nichts dupliziert", rotatedBy: t => `${Math.abs(t)} Grad ${t < 0 ? "im Uhrzeigersinn" : "gegen den Uhrzeigersinn"} gedreht`, movedLeft: "Nacht links bewegt", movedUp: "Nacht oben bewegt", movedDown: "Nacht unten bewegt", movedRight: "Nacht rechts bewegt", zoomedOut: "Ansicht verkleinert", zoomedIn: "Ansicht vergrößert", selectedElements: t => `${t} Element${1 === t ? "" : "e"} ausgewählt`, stroke: "Strich", svgObject: "SVG-Objekt", text: t => `Text-Objekt: ${t}`, pathNodeCount: t => `Es gibt ${t} sichtbare Pfad-Objekte.`, textNodeCount: t => `Es gibt ${t} sichtbare Text-Knotenpunkte.`, textNode: t => `Text: ${t}`, imageNodeCount: t => `Es gibt ${t} sichtbare Bild-Knoten.`, imageNode: t => `Bild: ${t}`, unlabeledImageNode: "Bild ohne Label", rerenderAsText: "Als Text darstellen", accessibilityInputInstructions: "Drücke ‚t‘, um den Inhalt des Ansichtsfensters als Text zu lesen. Verwende die Pfeiltasten, um die Ansicht zu verschieben, und klicke und ziehe, um Striche zu zeichnen. Drücke ‚w‘ zum Vergrößern und ‚s‘ zum Verkleinern der Ansicht.", loading: t => `Laden ${t}%...`, doneLoading: "Laden fertig", imageEditor: "Bild-Editor", undoAnnouncement: t => `${t} rückgängig gemacht`, redoAnnouncement: t => `${t} wiederholt`, reformatSelection: "Formatiere Auswahl", documentProperties: "Seite", backgroundColor: "Hintergrundfarbe: ", imageWidthOption: "Breite: ", imageHeightOption: "Höhe: ", useGridOption: "Gitter: ", toggleOverflow: "Mehr", selectAllTool: "Alle auswählen", soundExplorer: "Klangbasierte Bilderkundung", disableAccessibilityExploreTool: "Deaktiviere klangbasierte Erkundung", enableAccessibilityExploreTool: "Aktiviere klangbasierte Erkundung", unionOf: (t, e) => `Vereinigung: ${e} ${t}`, emptyBackground: "Leerer Hintergrund", filledBackgroundWithColor: t => `Gefüllter Hintergrund (${t})`, restyledElement: t => `${t} umgestaltet` }; e.default = n }, 5831: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); const n = { ...o(5246).defaultEditorLocalization }; e.default = n }, 4988: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); const n = { ...o(5246).defaultEditorLocalization, pen: "Lapiz", eraser: "Borrador", select: "Selecciona", handTool: "Mover", image: "Imagen", inputAltText: "Texto alternativo", resetImage: "Reiniciar", chooseFile: "Seleccionar archivo", cancel: "Cancelar", resetView: "Reiniciar vista", thicknessLabel: "Tamaño", fontLabel: "Fuente:", textSize: "Tamaño", resizeImageToSelection: "Redimensionar la imagen a lo que está seleccionado", deleteSelection: "Borra la selección", duplicateSelection: "Duplica la selección", exit: "Salir", save: "Guardar", undo: "Deshace", redo: "Rehace", selectPenType: "Punta", selectShape: "Forma", pickColorFromScreen: "Selecciona un color de la pantalla", clickToPickColorAnnouncement: "Haga un clic en la pantalla para seleccionar un color", documentProperties: "Fondo", backgroundColor: "Color de fondo", imageWidthOption: "Ancho", imageHeightOption: "Alto", enableAutoresizeOption: "Redimensionar automático", toggleOverflow: "Más", about: "Acerca de", touchPanning: "Mover la pantalla con un dedo", roundedTipPen: "Lapiz Redondeado", arrowPen: "Flecha", linePen: "Línea", outlinedRectanglePen: "Rectángulo delineado", filledRectanglePen: "Rectángulo sin borde", lockRotation: "Bloquea rotación", paste: "Pegar", selectionMenu__paste: "Pegar", selectionMenu__delete: "Eliminar", selectionMenu__duplicate: "Duplicar", closeSidebar: t => `Close sidebar for ${t}`, dropdownShown: t => `Menú por ${t} es visible`, dropdownHidden: t => `Menú por ${t} fue ocultado`, zoomLevel: t => `Zoom: ${t}%`, colorChangedAnnouncement: t => `Color fue cambiado a ${t}`, imageSize: (t, e) => `Tamaño del imagen: ${t} ${e}`, imageLoadError: t => `Error cargando imagen: ${t}`, penTool: t => `Lapiz ${t}`, selectionTool: "Selecciona", eraserTool: "Borrador", touchPanTool: "Instrumento de mover la pantalla con un dedo", undoRedoTool: "Deshace/rehace", pipetteTool: "Seleccione un color de la pantalla", keyboardPanZoom: "Mover la pantalla con el teclado", textTool: "Texto", enterTextToInsert: "Entra texto", findLabel: "Buscar", toNextMatch: "Próxima", closeDialog: "Cerrar", anyDevicePanning: "Mover la pantalla con todo dispotivo", copied: t => `${t} cosas fueron copiados`, pasted: t => 1 === t ? "Pegado" : `${t} cosas fueron pegados`, toolEnabledAnnouncement: t => `${t} fue activado`, toolDisabledAnnouncement: t => `${t} fue desactivado`, resizeOutputCommand: t => `Tamaño de imagen fue cambiado a ${t.w}x${t.h}`, eraseAction: (t, e) => `Borrado: ${e} ${t}`, rerenderAsText: "Redibuja la pantalla al texto", loading: t => `Cargando: ${t}%...`, imageEditor: "Editor de dibujos", doneLoading: "El cargado terminó", undoAnnouncement: t => `${t} fue deshecho`, redoAnnouncement: t => `${t} fue rehecho` }; e.default = n }, 2543: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.matchingLocalizationTable = e.allLocales = void 0; const i = o(5246), r = n(o(8351)), s = n(o(5831)), a = n(o(4988)); e.allLocales = { de: r.default, en: s.default, es: a.default }; const l = t => { const e = /^(\w+)[_-](\w+)$/.exec(t); return e ? e[1] : t }; e.matchingLocalizationTable = (t, e, o) => { let n; for (const o of t) { const t = l(o); if (n && t !== n && n in e) return e[n]; if (o in e) return e[o]; n = t } return n && n in e ? e[n] : o }; e.default = t => (t ??= navigator.languages, (0, e.matchingLocalizationTable)(t, e.allLocales, i.defaultEditorLocalization)) }, 1606: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.RenderingMode = void 0; const i = n(o(8748)), r = o(2018), s = n(o(7376)), a = o(5379), l = n(o(1258)), c = n(o(1733)); var d; !function (t) { t[t.DummyRenderer = 0] = "DummyRenderer", t[t.CanvasRenderer = 1] = "CanvasRenderer" }(d || (e.RenderingMode = d = {})); e.default = class { constructor(t, e, o) { if (this.editor = t, this.parent = o, this.textRerenderOutput = null, this.devicePixelRatio = window.devicePixelRatio ?? 1, this.getColorAt = t => null, e === d.CanvasRenderer) this.initializeCanvasRendering(); else { if (e !== d.DummyRenderer) throw new Error(`Unknown rendering mode, ${e}!`); this.dryInkRenderer = new s.default(t.viewport), this.wetInkRenderer = new s.default(t.viewport) } this.textRenderer = new c.default(t.viewport, t.localization), this.initializeTextRendering(); const n = a.Vec2.of(600, 600); this.cache = new l.default({ createRenderer: () => { if (e === d.DummyRenderer) return new s.default(t.viewport); if (e !== d.CanvasRenderer) throw new Error("Unspported rendering mode"); const o = document.createElement("canvas"); o.width = n.x + 1, o.height = n.y + 1; const r = o.getContext("2d"); return new i.default(r, t.viewport) }, isOfCorrectType: t => this.dryInkRenderer.canRenderFromWithoutDataLoss(t), blockResolution: n, cacheSize: 1296e5, maxScale: Math.max(1, 1.3 / window.devicePixelRatio), minProportionalRenderTimePerCache: 80, minProportionalRenderTimeToUseCache: 420 }), this.editor.notifier.on(r.EditorEventType.DisplayResized, (t => { if (t.kind !== r.EditorEventType.DisplayResized) throw new Error("Mismatched event.kinds!"); this.resizeSurfacesCallback?.() })) } get width() { return this.dryInkRenderer.displaySize().x } get height() { return this.dryInkRenderer.displaySize().y } getCache() { return this.cache } initializeCanvasRendering() { const t = document.createElement("canvas"), e = document.createElement("canvas"), o = t.getContext("2d"), n = e.getContext("2d"); this.dryInkRenderer = new i.default(o, this.editor.viewport), this.wetInkRenderer = new i.default(n, this.editor.viewport), t.className = "dryInkCanvas", e.className = "wetInkCanvas", this.parent && (this.parent.appendChild(t), this.parent.appendChild(e)), this.resizeSurfacesCallback = () => { const i = t => Math.ceil(t.clientWidth * this.devicePixelRatio) || t.width, s = t => Math.ceil(t.clientHeight * this.devicePixelRatio) || t.height, l = t => s(t) !== t.height || i(t) !== t.width; (l(t) || l(e)) && (t.width = i(t), t.height = s(t), e.width = i(e), e.height = s(e), n.resetTransform(), o.resetTransform(), o.scale(this.devicePixelRatio, this.devicePixelRatio), n.scale(this.devicePixelRatio, this.devicePixelRatio), this.editor.notifier.dispatch(r.EditorEventType.DisplayResized, { kind: r.EditorEventType.DisplayResized, newSize: a.Vec2.of(this.width, this.height) })) }, this.resizeSurfacesCallback(), this.flattenCallback = () => { o.save(), o.resetTransform(), o.drawImage(e, 0, 0), o.restore() }, this.getColorAt = t => { const e = t.times(this.devicePixelRatio), n = o.getImageData(e.x, e.y, 1, 1), i = n?.data; if (i) { return a.Color4.ofRGBA(i[0] / 255, i[1] / 255, i[2] / 255, i[3] / 255) } return null } } initializeTextRendering() { const t = document.createElement("div"); t.classList.add("textRendererOutputContainer"); const e = document.createElement("button"); e.classList.add("rerenderButton"), e.innerText = this.editor.localization.rerenderAsText, this.textRerenderOutput = document.createElement("div"), this.textRerenderOutput.setAttribute("aria-live", "polite"), e.onclick = () => { this.rerenderAsText() }, t.replaceChildren(e, this.textRerenderOutput), this.editor.createHTMLOverlay(t) } setDevicePixelRatio(t) { if (isFinite(t) && t >= .001 && t <= 10 && t !== this.devicePixelRatio) return this.devicePixelRatio = t, this.resizeSurfacesCallback?.(), this.editor.queueRerender() } getDevicePixelRatio() { return this.devicePixelRatio } rerenderAsText() { this.textRenderer.clear(), this.editor.image.render(this.textRenderer, this.editor.viewport), this.textRerenderOutput && (this.textRerenderOutput.innerText = this.textRenderer.getDescription()) } startRerender() { return this.resizeSurfacesCallback?.(), this.dryInkRenderer.clear(), this.dryInkRenderer } setDraftMode(t) { this.dryInkRenderer.setDraftMode(t) } getDryInkRenderer() { return this.dryInkRenderer } getWetInkRenderer() { return this.wetInkRenderer } flatten() { this.flattenCallback?.() } } }, 8258: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.visualEquivalent = e.simplifyPathToFullScreenOrEmpty = e.pathToRenderable = e.pathFromRenderable = void 0; const n = o(5379); e.pathFromRenderable = t => t.path ? t.path : new n.Path(t.startPoint, t.commands); e.pathToRenderable = (t, e) => ({ startPoint: t.startPoint, style: e, commands: t.parts, path: t }); e.simplifyPathToFullScreenOrEmpty = (t, o, i = { fastCheck: !0, expensiveCheck: !0 }) => { const r = (0, e.pathFromRenderable)(t), s = t.style.stroke?.width ?? 0, a = s > 0 && 0 === t.style.fill.a, l = r.bbox.grownBy(s), c = a && s > o.maxDimension && l.containsRect(o); if (i.fastCheck && c && t.style.stroke) { const i = s / 2; for (const s of r.startEndPoints()) if (o.isWithinRadiusOf(i, s)) return { rectangle: o, path: (0, e.pathToRenderable)(n.Path.fromRect(o), { fill: t.style.stroke.color }), fullScreen: !0 } } if (i.expensiveCheck && c && t.style.stroke && s > 3 * o.maxDimension) { const i = r.signedDistance(o.center, s / 2), a = s / 6; if (i < -o.maxDimension / 2 - a) return { path: (0, e.pathToRenderable)(n.Path.fromRect(o), { fill: t.style.stroke.color }), rectangle: o, fullScreen: !0 }; if (i > o.maxDimension / 2 + a) return { path: (0, e.pathToRenderable)(n.Path.empty, { fill: n.Color4.transparent }), rectangle: n.Rect2.empty, fullScreen: !1 } } return null }; e.visualEquivalent = (t, o) => { const i = (0, e.pathFromRenderable)(t), r = t.style.stroke?.width ?? 0, s = r > 0 && 0 === t.style.fill.a, a = i.bbox.grownBy(r); let l = (0, e.simplifyPathToFullScreenOrEmpty)(t, o, { fastCheck: !0, expensiveCheck: !1 }); if (l) return l.path; if (o.grownBy(r).transformedBoundingBox(n.Mat33.scaling2D(4, o.center)).containsRect(a)) return ((t, e) => t.path ? t : { ...t, path: e })(t, i); const c = []; let d = i.startPoint; for (const t of i.parts) { const e = n.Path.computeBBoxForSegment(d, t).grownBy(r); let i; i = t.kind === n.PathCommandType.LineTo || t.kind === n.PathCommandType.MoveTo ? t.point : t.endPoint; e.intersects(o) ? c.push(t) : s || t.kind === n.PathCommandType.MoveTo ? c.push({ kind: n.PathCommandType.MoveTo, point: i }) : c.push({ kind: n.PathCommandType.LineTo, point: i }), d = i } const h = new n.Path(i.startPoint, c), u = t.style; return l = (0, e.simplifyPathToFullScreenOrEmpty)(t, o, { fastCheck: !1, expensiveCheck: !0 }), l ? l.path : (0, e.pathToRenderable)(h, u) } }, 8247: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.styleFromJSON = e.styleToJSON = e.stylesEqual = e.cloneStyle = void 0; const n = o(5379); e.cloneStyle = t => ({ fill: t.fill, stroke: t.stroke ? { ...t.stroke } : void 0 }); e.stylesEqual = (t, e) => (t === e || t.fill.eq(e.fill) && null == t.stroke == (null == e.stroke) && (t.stroke?.color?.eq(e.stroke?.color) ?? !0) && t.stroke?.width === e.stroke?.width) ?? !1; e.styleToJSON = t => { const e = t.stroke ? { color: t.stroke.color.toHexString(), width: t.stroke.width } : void 0; return { fill: t.fill.toHexString(), stroke: e } }; e.styleFromJSON = t => { const e = t.stroke ? { color: n.Color4.fromHex(t.stroke.color), width: t.stroke.width } : void 0; return { fill: n.Color4.fromHex(t.fill), stroke: e } } }, 196: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.textStyleToJSON = e.textStyleFromJSON = e.cloneTextStyle = void 0; const n = o(8247); e.cloneTextStyle = t => ({ ...t, renderingStyle: (0, n.cloneStyle)(t.renderingStyle) }); e.textStyleFromJSON = t => { if ("string" == typeof t && (t = JSON.parse(t)), "string" != typeof t.fontFamily) throw new Error("Serialized textStyle missing string fontFamily attribute!"); return { renderingStyle: (0, n.styleFromJSON)(t.renderingStyle), size: t.size, fontWeight: t.fontWeight, fontVariant: t.fontVariant, fontFamily: t.fontFamily } }; e.textStyleToJSON = t => ({ ...t, renderingStyle: (0, n.styleToJSON)(t.renderingStyle) }) }, 6601: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); const n = o(5379); e.default = class { constructor(t, e) { this.onBeforeDeallocCallback = t, this.cacheState = e, this.allocd = !1, this.allocCount = 0, this.renderer = e.props.createRenderer(), this.lastUsedCycle = -1, this.allocd = !0 } startRender() { if (this.lastUsedCycle = this.cacheState.currentRenderingCycle, !this.allocd) throw new Error("Only alloc'd canvases can be rendered to"); return this.renderer } dealloc() { this.onBeforeDeallocCallback?.(), this.allocd = !1, this.onBeforeDeallocCallback = null, this.lastUsedCycle = 0 } isAllocd() { return this.allocd } realloc(t) { this.allocd && this.dealloc(), this.allocd = !0, this.onBeforeDeallocCallback = t, this.lastUsedCycle = this.cacheState.currentRenderingCycle, this.allocCount++ } getLastUsedCycle() { return this.lastUsedCycle } getTransform(t) { return n.Mat33.scaling2D(this.cacheState.props.blockResolution.x / t.size.x).rightMul(n.Mat33.translation(t.topLeft.times(-1))) } setRenderingRegion(t) { const e = this.getTransform(t); this.renderer.setTransform(e), this.renderer.overrideVisibleRect(t.grownBy(1 / e.getScaleFactor())) } } }, 2062: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.CacheRecordManager = void 0; const i = n(o(6601)); e.CacheRecordManager = class { constructor(t) { this.cacheRecords = [], this.maxCanvases = Math.ceil(t.cacheSize / 4 / t.blockResolution.x / t.blockResolution.y) } setSharedState(t) { this.cacheState = t } allocCanvas(t, e) { if (this.cacheRecords.length < this.maxCanvases) { const o = new i.default(e, this.cacheState); return o.setRenderingRegion(t), this.cacheRecords.push(o), this.cacheState.debugMode && console.log("[Cache] Cache spaces used: ", this.cacheRecords.length, " of ", this.maxCanvases), o } { const o = this.getLeastRecentlyUsedRecord(); return this.cacheState.debugMode && console.log("[Cache] Re-alloc. Times allocated: ", o.allocCount, "\nLast used cycle: ", o.getLastUsedCycle(), "\nCurrent cycle: ", this.cacheState.currentRenderingCycle), o.realloc(e), o.setRenderingRegion(t), this.cacheState.debugMode && (console.log("[Cache] Now re-alloc'd. Last used cycle: ", o.getLastUsedCycle()), console.assert(o.cacheState === this.cacheState, "[Cache] Unequal cache states! cacheState should be a shared object!")), o } } getLeastRecentlyUsedRecord() { return this.cacheRecords.sort(((t, e) => t.getLastUsedCycle() - e.getLastUsedCycle())), this.cacheRecords[0] } getDebugInfo() { let t = 0, e = 0; for (const o of this.cacheRecords) e += o.allocCount, o.isAllocd() && t++; e /= Math.max(this.cacheRecords.length, 1); return [`${this.cacheRecords.length} cache records (max ${this.maxCanvases})`, `${t} assigned to screen regions`, "Average number of times reassigned: " + Math.round(100 * e) / 100].join("\n") } } }, 1258: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = o(5379), r = n(o(9418)), s = o(2062); e.default = class { constructor(t) { this.recordManager = new s.CacheRecordManager(t), this.sharedState = { props: t, currentRenderingCycle: 0, recordManager: this.recordManager, debugMode: !1 }, this.recordManager.setSharedState(this.sharedState) } render(t, e, o) { const n = o.visibleRect; if (this.sharedState.currentRenderingCycle++, !this.sharedState.props.isOfCorrectType(t)) return void e.render(t, n); if (!this.rootNode) { const t = this.sharedState.props.blockResolution, e = n.topLeft; this.rootNode = new r.default(new i.Rect2(e.x, e.y, t.x, t.y), this.sharedState) } for (; !this.rootNode.region.containsRect(n);)this.rootNode = this.rootNode.generateParent(); this.rootNode = this.rootNode.smallestChildContaining(n) ?? this.rootNode; const s = e.getLeavesIntersectingRegion(o.visibleRect, (e => t.isTooSmallToRender(e))); let a = 0; for (const t of s) a += t.getContent().getProportionalRenderingTime(); a > this.sharedState.props.minProportionalRenderTimeToUseCache ? this.rootNode.renderItems(t, [e], o) : e.render(t, n) } getDebugInfo() { return this.recordManager.getDebugInfo() } setIsDebugMode(t) { this.sharedState.debugMode = t } } }, 9418: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); const n = o(7), i = o(5379); class r { constructor(t, e) { this.region = t, this.cacheState = e, this.instantiatedChildren = [], this.parent = null, this.cachedRenderer = null, this.renderedIds = [], this.renderedMaxZIndex = null } generateParent() { if (this.parent) return this.parent; const t = i.Rect2.fromCorners(this.region.topLeft.minus(this.region.size), this.region.bottomRight.plus(this.region.size)), e = new r(t, this.cacheState); e.generateChildren(); const o = this.region.maxDimension / 100, n = (e.instantiatedChildren.length - 1) / 2; if (!e.instantiatedChildren[n].region.eq(this.region, o)) throw console.error(e.instantiatedChildren[n].region, "≠", this.region), new Error("Logic error: [this] is not contained within its parent's center child"); return e.instantiatedChildren[n] = this, this.parent = e, e } generateChildren() { if (0 === this.instantiatedChildren.length) { if (this.region.size.x / 3 == 0 || this.region.size.y / 3 == 0) return void console.warn("Cache element has zero size! Not generating children."); const t = this.region.divideIntoGrid(3, 3); console.assert(9 === t.length, "Warning: divideIntoGrid created the wrong number of subrectangles!"); for (const e of t) { const t = new r(e, this.cacheState); t.parent = this, this.instantiatedChildren.push(t) } } this.checkRep() } getChildren() { return this.checkRep(), this.generateChildren(), this.instantiatedChildren } smallestChildContaining(t) { const e = t.maxDimension > this.region.maxDimension / 3; if (!this.region.containsRect(t) || e) return null; for (const e of this.getChildren()) if (e.region.containsRect(t)) return e.smallestChildContaining(t) ?? e; return null } renderingWouldBeHighEnoughResolution(t) { const e = this.region.w / this.cacheState.props.blockResolution.x; return !(t.getScaleFactor() * e > this.cacheState.props.maxScale) } allChildrenCanRender(t, e) { if (0 === this.instantiatedChildren.length) return !1; for (const o of this.instantiatedChildren) if (o.region.intersects(t.visibleRect) && !o.renderingIsUpToDate(this.idsOfIntersecting(e))) return !1; return !0 } computeSortedByLeafIds(t) { const e = t.slice(); return e.sort(((t, e) => t.getId() - e.getId())), e } idsOfIntersecting(t) { const e = []; for (const o of t) o.getBBox().intersects(this.region) && e.push(o.getId()); return e } allRenderedIdsIn(t) { if (this.renderedIds.length > t.length) return !1; for (let e = 0; e < this.renderedIds.length; e++)if (t[e] !== this.renderedIds[e]) return !1; return !0 } renderingIsUpToDate(t) { return null !== this.cachedRenderer && t.length === this.renderedIds.length && this.allRenderedIdsIn(t) } renderItems(t, e, o) { if (!o.visibleRect.intersects(this.region) || 0 === e.length) return; if (e = (t => { const e = []; for (const o of t) { const t = o.getBBox(); t.intersects(this.region) && (t.maxDimension >= this.region.maxDimension ? e.push(...o.getChildrenOrSelfIntersectingRegion(this.region)) : e.push(o)) } return e })(e), !this.cacheState.props.isOfCorrectType(t)) { for (const n of e) n.render(t, o.visibleRect); return } this.cacheState.debugMode && t.drawRect(this.region, o.getSizeOfPixelOnCanvas(), { fill: i.Color4.yellow }); if (this.renderingWouldBeHighEnoughResolution(o)) { const r = t => t.w / this.region.w < 1 / this.cacheState.props.blockResolution.x, s = []; for (const t of e) s.push(...t.getLeavesIntersectingRegion(this.region, r)); (0, n.sortLeavesByZIndex)(s); const a = this.computeSortedByLeafIds(s); if (0 === a.length) return; const l = a.map((t => t.getId())); let c; if (this.renderingIsUpToDate(l)) c = this.cachedRenderer.startRender(); else { if (this.allChildrenCanRender(o, a)) { for (const n of this.getChildren()) n.renderItems(t, e, o); return } let d = 0; for (const t of a) r(t.getBBox()) || (d += t.getContent().getProportionalRenderingTime()); if (d > this.cacheState.props.minProportionalRenderTimePerCache) { let e = !0; if (this.cachedRenderer) if (a.length > this.renderedIds.length && this.allRenderedIdsIn(l) && null !== this.renderedMaxZIndex) { const n = []; let r = null; for (let t = 0; t < a.length; t++) { const e = a[t], o = e.getContent().getZIndex(); (t >= this.renderedIds.length || e.getId() !== this.renderedIds[t]) && (n.push(e), (null === r || o < r) && (r = o)) } if (null !== r && r > this.renderedMaxZIndex) { e = !1, c = this.cachedRenderer.startRender(); for (let t = 0; t < s.length; t++) { const e = s[t], o = e.getContent().getZIndex(); o > this.renderedMaxZIndex && (e.render(c, this.region), this.renderedMaxZIndex = o) } this.cacheState.debugMode && t.drawRect(this.region, 2 * o.getSizeOfPixelOnCanvas(), { fill: i.Color4.clay }) } } else this.cacheState.debugMode && console.log("Decided on a full re-render. Reason: At least one of the following is false:", "\n leafIds.length > this.renderedIds.length: ", l.length > this.renderedIds.length, "\n this.allRenderedIdsIn(leafIds): ", this.allRenderedIdsIn(l), "\n this.renderedMaxZIndex !== null: ", null !== this.renderedMaxZIndex, "\n\nthis.rerenderedIds: ", this.renderedIds, ", leafIds: ", l); else this.cachedRenderer = this.cacheState.recordManager.allocCanvas(this.region, (() => this.onRegionDealloc())); if (e) { c = this.cachedRenderer.startRender(), c.clear(), this.renderedMaxZIndex = null; for (let t = (0, n.computeFirstIndexToRender)(s, this.region); t < s.length; t++) { const e = s[t], o = e.getContent(); this.renderedMaxZIndex ??= o.getZIndex(), this.renderedMaxZIndex = Math.max(this.renderedMaxZIndex, o.getZIndex()), e.render(c, this.region) } this.cacheState.debugMode && t.drawRect(this.region, 3 * o.getSizeOfPixelOnCanvas(), { fill: i.Color4.red }) } this.renderedIds = l } else { this.cachedRenderer?.dealloc(); const e = o.getSizeOfPixelOnCanvas(), n = new i.Rect2(this.region.x, this.region.y, this.region.w + e, this.region.h + e), r = !0; t.startObject(n, r); for (const e of s) e.render(t, this.region.intersection(o.visibleRect)); t.endObject(), this.cacheState.debugMode && t.drawRect(this.region, 2 * o.getSizeOfPixelOnCanvas(), { fill: i.Color4.green }) } } if (c) { const e = this.cachedRenderer.getTransform(this.region).inverse(); t.renderFromOtherOfSameType(e, c) } this.instantiatedChildren.every((t => t.isEmpty())) && (this.instantiatedChildren = []) } else for (const n of this.getChildren()) n.renderItems(t, e.filter((t => t.getBBox().intersects(n.region))), o); this.checkRep() } isEmpty() { return null === this.cachedRenderer && this.instantiatedChildren.every((t => t.isEmpty())) } onRegionDealloc() { this.cachedRenderer = null, this.isEmpty() && (this.instantiatedChildren = []) } checkRep() { if (9 !== this.instantiatedChildren.length && 0 !== this.instantiatedChildren.length) throw new Error(`Repcheck: Wrong number of children. Got ${this.instantiatedChildren.length}`); if (void 0 !== this.renderedIds[1] && this.renderedIds[0] >= this.renderedIds[1]) throw console.error(this.renderedIds), new Error("Repcheck: First two ids are not in ascending order!"); for (const t of this.instantiatedChildren) if (t.parent !== this) throw new Error("Children should be linked to their parents!"); if (this.cachedRenderer && !this.cachedRenderer.isAllocd()) throw new Error("this' cachedRenderer != null, but is dealloc'd") } } e.default = r }, 1063: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.pathVisualEquivalent = e.pathFromRenderable = e.pathToRenderable = e.RenderingMode = e.Display = e.CanvasRenderer = e.SVGRenderer = e.DummyRenderer = e.AbstractRenderer = void 0; var i = o(3982); Object.defineProperty(e, "AbstractRenderer", { enumerable: !0, get: function () { return n(i).default } }); var r = o(7376); Object.defineProperty(e, "DummyRenderer", { enumerable: !0, get: function () { return n(r).default } }); var s = o(1598); Object.defineProperty(e, "SVGRenderer", { enumerable: !0, get: function () { return n(s).default } }); var a = o(8748); Object.defineProperty(e, "CanvasRenderer", { enumerable: !0, get: function () { return n(a).default } }); var l = o(1606); Object.defineProperty(e, "Display", { enumerable: !0, get: function () { return n(l).default } }), Object.defineProperty(e, "RenderingMode", { enumerable: !0, get: function () { return l.RenderingMode } }); var c = o(8258); Object.defineProperty(e, "pathToRenderable", { enumerable: !0, get: function () { return c.pathToRenderable } }), Object.defineProperty(e, "pathFromRenderable", { enumerable: !0, get: function () { return c.pathFromRenderable } }), Object.defineProperty(e, "pathVisualEquivalent", { enumerable: !0, get: function () { return c.visualEquivalent } }) }, 4215: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.defaultTextRendererLocalization = void 0, e.defaultTextRendererLocalization = { pathNodeCount: t => `There are ${t} visible path objects.`, textNodeCount: t => `There are ${t} visible text nodes.`, imageNodeCount: t => `There are ${t} visible image nodes.`, textNode: t => `Text: ${t}`, imageNode: t => `Image: ${t}`, unlabeledImageNode: "Unlabeled image", rerenderAsText: "Re-render as text" } }, 3982: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); const n = o(5379), i = o(8247), r = o(8258); e.default = class { constructor(t) { this.viewport = t, this.selfTransform = null, this.transformStack = [], this.objectLevel = 0, this.currentPaths = null } getViewport() { return this.viewport } setDraftMode(t) { } flushPath() { if (!this.currentPaths) return; let t = null; for (const e of this.currentPaths) { const { startPoint: o, commands: r, style: s } = e; t && (0, i.stylesEqual)(t, s) ? this.moveTo(o) : (t && this.endPath(t), this.beginPath(o), t = s); for (const t of r) t.kind === n.PathCommandType.LineTo ? this.lineTo(t.point) : t.kind === n.PathCommandType.MoveTo ? this.moveTo(t.point) : t.kind === n.PathCommandType.CubicBezierTo ? this.traceCubicBezierCurve(t.controlPoint1, t.controlPoint2, t.endPoint) : t.kind === n.PathCommandType.QuadraticBezierTo && this.traceQuadraticBezierCurve(t.controlPoint, t.endPoint) } t && this.endPath(t), this.currentPaths = [] } drawPath(t) { 0 === this.objectLevel || null === this.currentPaths ? (this.currentPaths = [t], this.flushPath(), this.currentPaths = null) : this.currentPaths.push(t) } drawRect(t, e, o) { const i = n.Path.fromRect(t, e); this.drawPath((0, r.pathToRenderable)(i, o)) } fillRect(t, e) { const o = n.Path.fromRect(t); this.drawPath((0, r.pathToRenderable)(o, { fill: e })) } startObject(t, e) { this.objectLevel > 0 && this.flushPath(), this.currentPaths = [], this.objectLevel++ } endObject(t, e) { if (this.flushPath(), this.currentPaths = null, this.objectLevel--, this.objectLevel < 0) throw new Error("More objects have ended than have been started (negative object nesting level)!") } getNestingLevel() { return this.objectLevel } canRenderFromWithoutDataLoss(t) { return !1 } renderFromOtherOfSameType(t, e) { throw new Error(`Unable to render from ${e}: Not implemented`) } setTransform(t) { this.selfTransform = t } pushTransform(t) { this.transformStack.push(this.selfTransform), this.setTransform(this.getCanvasToScreenTransform().rightMul(t)) } popTransform() { if (0 === this.transformStack.length) throw new Error("Unable to pop more transforms than have been pushed!"); this.setTransform(this.transformStack.pop() ?? null) } getCanvasToScreenTransform() { return this.selfTransform ? this.selfTransform : this.viewport.canvasToScreenTransform } canvasToScreen(t) { return this.getCanvasToScreenTransform().transformVec2(t) } getSizeOfCanvasPixelOnScreen() { return this.getCanvasToScreenTransform().transformVec3(n.Vec2.unitX).length() } overrideVisibleRect(t) { this.visibleRectOverride = t } getVisibleRect() { return this.visibleRectOverride ?? this.viewport.visibleRect } } }, 8748: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(2170)), r = o(5379), s = n(o(3982)), a = o(8258); class l extends s.default { constructor(t, e) { super(e), this.ctx = t, this.ignoreObjectsAboveLevel = null, this.ignoringObject = !1, this.currentObjectBBox = null, this.clipLevels = [], this.setDraftMode(!1) } transformBy(t) { this.ctx.transform(t.a1, t.b1, t.a2, t.b2, t.a3, t.b3) } canRenderFromWithoutDataLoss(t) { return t instanceof l } renderFromOtherOfSameType(t, e) { if (!(e instanceof l)) throw new Error(`${e} cannot be rendered onto ${this}`); t = this.getCanvasToScreenTransform().rightMul(t), this.ctx.save(), this.transformBy(t), this.ctx.drawImage(e.ctx.canvas, 0, 0), this.ctx.restore() } setDraftMode(t) { t ? (this.minSquareCurveApproxDist = 9, this.minRenderSizeBothDimens = 1, this.minRenderSizeAnyDimen = .1) : (this.minSquareCurveApproxDist = .5, this.minRenderSizeBothDimens = .1, this.minRenderSizeAnyDimen = 1e-6) } displaySize() { return r.Vec2.of(this.ctx.canvas.clientWidth, this.ctx.canvas.clientHeight) } clear() { this.ctx.save(), this.ctx.resetTransform(), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore() } beginPath(t) { t = this.canvasToScreen(t), this.ctx.beginPath(), this.ctx.moveTo(t.x, t.y) } endPath(t) { t.fill.a > 0 && (this.ctx.fillStyle = t.fill.toHexString(), this.ctx.fill()), t.stroke && (this.ctx.strokeStyle = t.stroke.color.toHexString(), this.ctx.lineWidth = this.getSizeOfCanvasPixelOnScreen() * t.stroke.width, this.ctx.lineCap = "round", this.ctx.lineJoin = "round", this.ctx.stroke(), this.ctx.lineWidth = 1), this.ctx.closePath() } lineTo(t) { t = this.canvasToScreen(t), this.ctx.lineTo(t.x, t.y) } moveTo(t) { t = this.canvasToScreen(t), this.ctx.moveTo(t.x, t.y) } traceCubicBezierCurve(t, e, o) { t = this.canvasToScreen(t), e = this.canvasToScreen(e), o = this.canvasToScreen(o); const n = e.minus(t), i = o.minus(e); n.magnitudeSquared() < this.minSquareCurveApproxDist && i.magnitudeSquared() < this.minSquareCurveApproxDist ? this.ctx.lineTo(o.x, o.y) : this.ctx.bezierCurveTo(t.x, t.y, e.x, e.y, o.x, o.y) } traceQuadraticBezierCurve(t, e) { t = this.canvasToScreen(t), e = this.canvasToScreen(e); t.minus(e).magnitudeSquared() < this.minSquareCurveApproxDist ? this.ctx.lineTo(e.x, e.y) : this.ctx.quadraticCurveTo(t.x, t.y, e.x, e.y) } drawPath(t) { if (this.ignoringObject) return; const e = this.getVisibleRect(); this.currentObjectBBox?.containsRect(e) && (t = (0, a.visualEquivalent)(t, e)), super.drawPath(t) } drawText(t, e, o) { this.ctx.save(), e = this.getCanvasToScreenTransform().rightMul(e), this.transformBy(e), i.default.applyTextStyles(this.ctx, o), 0 !== o.renderingStyle.fill.a && (this.ctx.fillStyle = o.renderingStyle.fill.toHexString(), this.ctx.fillText(t, 0, 0)), o.renderingStyle.stroke && (this.ctx.strokeStyle = o.renderingStyle.stroke.color.toHexString(), this.ctx.lineWidth = o.renderingStyle.stroke.width, this.ctx.strokeText(t, 0, 0)), this.ctx.restore() } drawImage(t) { if (0 === t.image.width || 0 === t.image.height) return; this.ctx.save(); const e = this.getCanvasToScreenTransform().rightMul(t.transform); this.transformBy(e), this.ctx.drawImage(t.image, 0, 0), this.ctx.restore() } startObject(t, e) { if (this.isTooSmallToRender(t) && (this.ignoreObjectsAboveLevel = this.getNestingLevel(), this.ignoringObject = !0), super.startObject(t), this.currentObjectBBox = t, !this.ignoringObject && e) { if (!t.containsRect(this.getVisibleRect())) { this.clipLevels.push(this.objectLevel), this.ctx.save(), this.ctx.beginPath(); for (const e of t.corners) { const t = this.canvasToScreen(e); this.ctx.lineTo(t.x, t.y) } this.ctx.clip() } } } endObject() { const t = this.objectLevel; this.currentObjectBBox = null, super.endObject(), !this.ignoringObject && this.clipLevels.length > 0 && this.clipLevels[this.clipLevels.length - 1] === t && (this.ctx.restore(), this.clipLevels.pop()), null !== this.ignoreObjectsAboveLevel && this.getNestingLevel() <= this.ignoreObjectsAboveLevel && (this.ignoreObjectsAboveLevel = null, this.ignoringObject = !1) } drawPoints(...t) { for (let e = 0; e < t.length; e++) { const o = this.canvasToScreen(t[e]); this.ctx.beginPath(), this.ctx.arc(o.x, o.y, 10, 0, 2 * Math.PI), this.ctx.fillStyle = r.Color4.ofRGBA(.5 + Math.sin(e) / 2, 1, .5 + Math.cos(.2 * e) / 4, .5).toHexString(), this.ctx.lineWidth = 2, this.ctx.fill(), this.ctx.stroke(), this.ctx.closePath(), this.ctx.textAlign = "center", this.ctx.textBaseline = "middle", this.ctx.fillStyle = "black", this.ctx.fillText(`${e}`, o.x, o.y, 20) } } isTooSmallToRender(t) { const e = t.size.times(this.getSizeOfCanvasPixelOnScreen()), o = this.minRenderSizeBothDimens, n = Math.abs(e.x) < o && Math.abs(e.y) < o, i = this.minRenderSizeAnyDimen, r = Math.abs(e.x) < i || Math.abs(e.y) < i; return n || r } static fromViewport(t, e = {}) { const o = document.createElement("canvas"), n = t.getScreenRectSize(); let i = e.canvasSize ?? n; e.maxCanvasDimen && i.maximumEntryMagnitude() > e.maxCanvasDimen && (i = i.times(e.maxCanvasDimen / i.maximumEntryMagnitude())), o.width = i.x, o.height = i.y; const r = o.getContext("2d"), s = Math.min(i.x / n.x, i.y / n.y); return r.scale(s, s), { renderer: new l(r, t), element: o } } } e.default = l }, 7376: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = o(5379), r = n(o(3982)); class s extends r.default { constructor(t) { super(t), this.clearedCount = 0, this.renderedPathCount = 0, this.lastFillStyle = null, this.lastPoint = null, this.objectNestingLevel = 0, this.lastText = null, this.lastImage = null, this.pointBuffer = [] } displaySize() { const t = this.getViewport().getScreenRectSize(); return 0 === t.x || 0 === t.y ? i.Vec2.of(640, 480) : t } clear() { if (this.clearedCount++, this.renderedPathCount = 0, this.pointBuffer = [], this.lastText = null, this.lastImage = null, this.objectNestingLevel > 0) throw new Error(`Within an object while clearing! Nesting level: ${this.objectNestingLevel}`) } beginPath(t) { this.lastPoint = t, this.pointBuffer.push(t) } endPath(t) { this.renderedPathCount++, this.lastFillStyle = t } lineTo(t) { t = this.canvasToScreen(t), this.lastPoint = t, this.pointBuffer.push(t) } moveTo(t) { t = this.canvasToScreen(t), this.lastPoint = t, this.pointBuffer.push(t) } traceCubicBezierCurve(t, e, o) { t = this.canvasToScreen(t), e = this.canvasToScreen(e), o = this.canvasToScreen(o), this.lastPoint = o, this.pointBuffer.push(t, e, o) } traceQuadraticBezierCurve(t, e) { t = this.canvasToScreen(t), e = this.canvasToScreen(e), this.lastPoint = e, this.pointBuffer.push(t, e) } drawPoints(...t) { } drawText(t, e, o) { this.lastText = t } drawImage(t) { this.lastImage = t } startObject(t, e) { super.startObject(t), this.objectNestingLevel += 1 } endObject() { super.endObject(), this.objectNestingLevel -= 1 } isTooSmallToRender(t) { return !1 } canRenderFromWithoutDataLoss(t) { return t instanceof s } renderFromOtherOfSameType(t, e) { if (!(e instanceof s)) throw new Error(`${e} cannot be rendered onto ${this}`); this.renderedPathCount += e.renderedPathCount, this.lastFillStyle = e.lastFillStyle, this.lastPoint = e.lastPoint, this.pointBuffer.push(...e.pointBuffer.map((e => t.transformVec2(e)))) } toString() { return "[DummyRenderer]" } } e.default = s }, 1598: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.renderedStylesheetId = void 0; const i = o(5379), r = o(3604), s = o(8247), a = n(o(3982)), l = o(8258), c = n(o(6953)); e.renderedStylesheetId = "js-draw-style-sheet"; const d = "http://www.w3.org/2000/svg", h = { fontWeight: "400", fontStyle: "normal" }; class u extends a.default { constructor(t, e, o = !1) { super(e), this.elem = t, this.sanitize = o, this.lastPathStyle = null, this.lastPathString = [], this.lastContainerIDList = [], this.objectElems = null, this.overwrittenAttrs = {}, this.textContainer = null, this.textContainerTransform = null, this.textParentStyle = h, this.clear(), this.addStyleSheet() } addStyleSheet() { if (!this.elem.querySelector(`#${e.renderedStylesheetId}`)) { const t = document.createElementNS("http://www.w3.org/2000/svg", "style"); t.appendChild(document.createTextNode("\n\t\t\t\tpath {\n\t\t\t\t\tstroke-linecap: round;\n\t\t\t\t\tstroke-linejoin: round;\n\t\t\t\t}\n\n\t\t\t\ttext {\n\t\t\t\t\twhite-space: pre;\n\t\t\t\t}\n\t\t\t".replace(/\s+/g, ""))), t.setAttribute("id", e.renderedStylesheetId), this.elem.appendChild(t) } } setRootSVGAttribute(t, e) { this.sanitize || (t in this.overwrittenAttrs || (this.overwrittenAttrs[t] = this.elem.getAttribute(t)), null !== e ? this.elem.setAttribute(t, e) : this.elem.removeAttribute(t)) } displaySize() { return i.Vec2.of(this.elem.clientWidth, this.elem.clientHeight) } clear() { if (this.lastPathString = [], this.lastContainerIDList = [], !this.sanitize) { for (const t in this.overwrittenAttrs) { const e = this.overwrittenAttrs[t]; e ? this.elem.setAttribute(t, e) : this.elem.removeAttribute(t) } this.overwrittenAttrs = {} } } addPathToSVG() { if (!this.lastPathStyle || 0 === this.lastPathString.length) return null; const t = document.createElementNS(d, "path"); t.setAttribute("d", this.lastPathString.join(" ")); const e = this.lastPathStyle; return e.fill.a > 0 ? t.setAttribute("fill", e.fill.toHexString()) : t.setAttribute("fill", "none"), e.stroke && (t.setAttribute("stroke", e.stroke.color.toHexString()), t.setAttribute("stroke-width", (0, i.toRoundedString)(e.stroke.width * this.getSizeOfCanvasPixelOnScreen()))), this.elem.appendChild(t), this.objectElems?.push(t), t } drawPath(t) { const e = t.style, o = (0, l.pathFromRenderable)(t).transformedBy(this.getCanvasToScreenTransform()); 0 !== this.lastPathString.length && this.lastPathStyle && (0, s.stylesEqual)(this.lastPathStyle, e) || (this.addPathToSVG(), this.lastPathStyle = e, this.lastPathString = []), this.lastPathString.push(o.toString()) } transformFrom(t, e, o = !1) { const n = o ? t : this.getCanvasToScreenTransform().rightMul(t); if (n.eq(i.Mat33.identity)) e.style.transform = ""; else { const t = n.toCSSMatrix(); e.style.transform = t, e.setAttribute("data-highp-transform", t) } } drawText(t, e, o) { const n = (t, e) => { e.fontFamily !== this.textParentStyle?.fontFamily && (t.style.fontFamily = e.fontFamily), e.fontVariant !== this.textParentStyle?.fontVariant && (t.style.fontVariant = e.fontVariant ?? ""), e.fontWeight !== this.textParentStyle?.fontWeight && (t.style.fontWeight = e.fontWeight ?? ""), e.fontStyle !== this.textParentStyle?.fontStyle && (t.style.fontStyle = e.fontStyle ?? ""), e.size !== this.textParentStyle?.size && (t.style.fontSize = e.size + "px"); const o = e.renderingStyle.fill.toHexString(); if (t.style.fill = o, e.renderingStyle.stroke) { const o = e.renderingStyle.stroke; t.style.stroke = o.color.toHexString(), t.style.strokeWidth = o.width + "px" } }; if (e = this.getCanvasToScreenTransform().rightMul(e), this.textContainer) { const r = document.createElementNS(d, "tspan"); r.appendChild(document.createTextNode(t)), this.textContainer.appendChild(r); const s = (e = this.textContainerTransform.inverse().rightMul(e)).transformVec2(i.Vec2.zero); r.setAttribute("x", `${(0, i.toRoundedString)(s.x)}`), r.setAttribute("y", `${(0, i.toRoundedString)(s.y)}`), n(r, o) } else { const i = document.createElementNS(d, "text"); i.appendChild(document.createTextNode(t)), this.transformFrom(e, i, !0), n(i, o), this.elem.appendChild(i), this.objectElems?.push(i), this.objectLevel > 0 && (this.textContainer = i, this.textContainerTransform = e, this.textParentStyle = { ...h, ...o }) } } drawImage(t) { let e = t.label ?? t.image.getAttribute("aria-label") ?? ""; "" === e && (e = t.image.getAttribute("alt") ?? ""); const o = document.createElementNS(d, "image"); o.setAttribute("href", t.base64Url), o.setAttribute("width", t.image.getAttribute("width") ?? ""), o.setAttribute("height", t.image.getAttribute("height") ?? ""), o.setAttribute("aria-label", e), this.transformFrom(t.transform, o), this.elem.appendChild(o), this.objectElems?.push(o) } startObject(t) { super.startObject(t), this.lastPathString = [], this.lastPathStyle = null, this.textContainer = null, this.textParentStyle = h, this.objectElems = [] } endObject(t, e) { if (super.endObject(t), this.addPathToSVG(), this.objectElems) { if (t && !this.sanitize) { for (const e of this.objectElems) { const o = t[r.svgAttributesDataKey], n = t[r.svgStyleAttributesDataKey]; if (o) for (const [t, n] of o) e.setAttribute(t, n); if (n) for (const t of n) e.style.setProperty(t.key, t.value, t.priority) } const e = t[r.svgLoaderAttributeContainerID]; let o = []; if (e && e[0] && e[0].length && (o = e[0]), o.length > 0 && (0, c.default)(this.lastContainerIDList, o) && this.lastContainerIDList.length >= o.length - 1) { const t = o[o.length - 1], e = this.elem.querySelectorAll(`g#${t}`); if (e.length >= 1) { const t = e[0]; if (0 === t.children.length || this.lastContainerIDList.length >= o.length) for (const e of this.objectElems) e.remove(), t.appendChild(e); else o = [] } } else o = []; this.lastContainerIDList = o } if (e && this.objectElems) if (1 === this.objectElems.length) this.objectElems[0].classList.add(...e); else { const t = document.createElementNS(d, "g"); t.classList.add(...e); for (const e of this.objectElems) e.remove(), t.appendChild(e); this.elem.appendChild(t) } } } unimplementedMessage() { throw new Error("Not implemenented!") } beginPath(t) { this.unimplementedMessage() } endPath(t) { this.unimplementedMessage() } lineTo(t) { this.unimplementedMessage() } moveTo(t) { this.unimplementedMessage() } traceCubicBezierCurve(t, e, o) { this.unimplementedMessage() } traceQuadraticBezierCurve(t, e) { this.unimplementedMessage() } drawPoints(...t) { t.map((t => { const e = document.createElementNS(d, "circle"); e.setAttribute("cx", `${t.x}`), e.setAttribute("cy", `${t.y}`), e.setAttribute("r", "15"), this.elem.appendChild(e) })) } drawSVGElem(t) { if (this.sanitize) return; if ("style" === t.tagName.toLowerCase() && t.getAttribute("id") === e.renderedStylesheetId) return; const o = t.cloneNode(!0); this.elem.appendChild(o), this.objectElems?.push(o) } isTooSmallToRender(t) { return !1 } static fromViewport(t, e = !0) { let o, n; "boolean" == typeof e ? (o = e, n = !1) : (o = e.sanitize ?? !0, n = e.useViewBoxForPositioning ?? !1); const r = "http://www.w3.org/2000/svg", s = document.createElementNS(r, "svg"), a = t.getScreenRectSize(), l = t.visibleRect; let c; if (n) { const e = t.visibleRect; c = [e.x, e.y, e.w, e.h], (t = t.getTemporaryClone()).resetTransform(i.Mat33.identity) } else c = [0, 0, a.x, a.y]; s.setAttribute("viewBox", c.map((t => (0, i.toRoundedString)(t))).join(" ")), s.setAttribute("width", (0, i.toRoundedString)(a.x)), s.setAttribute("height", (0, i.toRoundedString)(a.y)), s.setAttribute("version", "1.1"), s.setAttribute("baseProfile", "full"), s.setAttribute("xmlns", r); const d = new u(s, t, o); return l.eq(t.visibleRect) || d.overrideVisibleRect(l), { element: s, renderer: d } } } e.default = u }, 1733: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = o(5379), r = n(o(3982)); class s extends r.default { constructor(t, e) { super(t), this.localizationTable = e, this.descriptionBuilder = [], this.pathCount = 0, this.textNodeCount = 0, this.imageNodeCount = 0 } displaySize() { return i.Vec2.of(500, 500) } clear() { this.descriptionBuilder = [], this.pathCount = 0, this.textNodeCount = 0, this.imageNodeCount = 0 } getDescription() { return [this.localizationTable.pathNodeCount(this.pathCount), ...this.textNodeCount > 0 ? [this.localizationTable.textNodeCount(this.textNodeCount)] : [], ...this.imageNodeCount > 0 ? [this.localizationTable.imageNodeCount(this.imageNodeCount)] : [], ...this.descriptionBuilder].join("\n") } beginPath(t) { } endPath(t) { this.pathCount++ } lineTo(t) { } moveTo(t) { } traceCubicBezierCurve(t, e, o) { } traceQuadraticBezierCurve(t, e) { } drawText(t, e, o) { this.descriptionBuilder.push(this.localizationTable.textNode(t)), this.textNodeCount++ } drawImage(t) { const e = t.label ? this.localizationTable.imageNode(t.label) : this.localizationTable.unlabeledImageNode; this.descriptionBuilder.push(e), this.imageNodeCount++ } isTooSmallToRender(t) { return t.maxDimension < 15 / this.getSizeOfCanvasPixelOnScreen() } drawPoints(...t) { } } e.default = s }, 7067: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); const o = t => t.toUpperCase() === t && t.toLowerCase() !== t && 1 === t.length, n = t => t.toLowerCase() === t && t.toUpperCase() !== t && 1 === t.length; class i { constructor(t) { this.key = t.key, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey, this.altKey = t.altKey, this.metaKey = t.metaKey, this.controlOrMeta = t.controlOrMeta } matchesEvent(t) { const e = t.key?.toLowerCase(), i = o(t.key ?? ""), r = n(t.key ?? ""), s = (t.ctrlKey ?? !1) || "control" === e, a = (t.altKey ?? !1) || "alt" === e, l = (t.metaKey ?? !1) || "meta" === e, c = (t.shiftKey ?? i) || "shift" === e, d = t.controlOrMeta || t.ctrlKey || t.metaKey || !1; if (this.key !== t.code) { if (this.key.toLowerCase() !== e) return !1; if ((i || r) && this.key !== t.key) { if (!(!0 === this.shiftKey && this.key.toUpperCase() === t.key)) return !1 } } const h = this.controlOrMeta; return (s === this.ctrlKey && l === this.metaKey && !h || h && d) && a === this.altKey && (c === this.shiftKey || void 0 === this.shiftKey) } toString() { const t = []; return this.ctrlKey && "control" !== this.key && t.push("Ctrl"), this.controlOrMeta && t.push("CtrlOrMeta"), this.altKey && "alt" !== this.key && t.push("Alt"), this.metaKey && "meta" !== this.key && t.push("Meta"), this.shiftKey && "shift" !== this.key && t.push("Shift"), t.push(this.key), t.join("+") } static fromString(t) { const e = t => { let e; o(t) ? e = !0 : (n(t) || t.length > 1) && (e = !1); const i = t.toLowerCase(); return "shift" === i && (e = !0), { shiftKey: e, ctrlKey: "control" === i || "ctrl" === i, altKey: "alt" === i, metaKey: "meta" === i, controlOrMeta: "control or meta" === i || "ctrlormeta" === i } }; if (-1 === t.search(/[-+]/) || 1 === t.length) { const o = e(t); return new i({ key: t, ...o }) } const r = /^(.*[-+])?(.+)$/g.exec(t); if (!r) throw new Error(`Invalid shortcut expression, ${t}!`); const s = r[2], a = e(s), l = (r[1] ?? "").split(/[-+]/); let c = a.shiftKey, d = a.ctrlKey, h = a.altKey, u = a.metaKey, p = a.controlOrMeta; for (const e of l) if ("" !== e) switch (e.toLowerCase()) { case "shift": c = !0; break; case "anyshift": c = void 0; break; case "ctrl": case "control": d = !0; break; case "meta": u = !0; break; case "ctrlormeta": case "ctrl or meta": case "controlormeta": p = !0; break; case "alt": h = !0; break; default: throw new Error(`Unknown modifier: "${e}" in shortcut ${t}.`) }return new i({ key: s, shiftKey: c, ctrlKey: d, altKey: h, metaKey: u, controlOrMeta: p }) } } e.default = i }, 5577: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = o(2543), r = n(o(7067)); class s { constructor(t) { this.shortcutOverrides = Object.create(null); for (const e in t) this.overrideShortcut(e, t[e]) } overrideShortcut(t, e) { this.shortcutOverrides[t] = [...e] } matchesShortcut(t, e) { let o = this.shortcutOverrides[t]; if (!o) { if (!(t in s.shortcuts)) throw new Error(`No shortcut with ID ${t} exists!`); o = s.shortcuts[t] } for (const t of o) if (t.matchesEvent(e)) return !0; return !1 } static registerDefaultKeyboardShortcut(t, e, o) { if (t in s.shortcuts) return !1; const n = e.map((t => "string" == typeof t ? r.default.fromString(t) : t)); return s.shortcuts[t] = [...n], s.shortcutDefaultDescriptions[t] = o, !0 } static provideShortcutDescription(t, e, o) { e in s.shortcutLocalizedDescriptions || (s.shortcutLocalizedDescriptions[e] = Object.create(null)), s.shortcutLocalizedDescriptions[e][t] = o } static getAllShortcutIds() { const t = []; for (const e in this.shortcuts) t.push(e); return t } static getShortcutDefaultKeybindings(t) { if (!(t in s.shortcuts)) throw new Error(`No shortcut with ID ${t} exists!`); return s.shortcuts[t] } static getShortcutDescription(t, e) { return (0, i.matchingLocalizationTable)(e ?? [], this.shortcutLocalizedDescriptions, this.shortcutDefaultDescriptions)[t] ?? this.shortcutDefaultDescriptions[t] ?? null } } s.shortcuts = Object.create(null), s.shortcutDefaultDescriptions = Object.create(null), s.shortcutLocalizedDescriptions = Object.create(null), e.default = s }, 4772: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.KeyBinding = e.KeyboardShortcutManager = void 0; var i = o(5577); Object.defineProperty(e, "KeyboardShortcutManager", { enumerable: !0, get: function () { return n(i).default } }); var r = o(7067); Object.defineProperty(e, "KeyBinding", { enumerable: !0, get: function () { return n(r).default } }) }, 9979: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); e.default = t => { let e = 0; const o = t.map((t => t.id)); o.sort(); for (const t of o) e === t && (e = t + 1); return e } }, 9611: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.sendTouchEvent = e.sendPenEvent = void 0; var i = o(4433); Object.defineProperty(e, "sendPenEvent", { enumerable: !0, get: function () { return n(i).default } }); var r = o(8441); Object.defineProperty(e, "sendTouchEvent", { enumerable: !0, get: function () { return n(r).default } }) }, 4433: function (t, e, o) { "use strict"; var n, i = this && this.__createBinding || (Object.create ? function (t, e, o, n) { void 0 === n && (n = o); var i = Object.getOwnPropertyDescriptor(e, o); i && !("get" in i ? !e.__esModule : i.writable || i.configurable) || (i = { enumerable: !0, get: function () { return e[o] } }), Object.defineProperty(t, n, i) } : function (t, e, o, n) { void 0 === n && (n = o), t[n] = e[o] }), r = this && this.__setModuleDefault || (Object.create ? function (t, e) { Object.defineProperty(t, "default", { enumerable: !0, value: e }) } : function (t, e) { t.default = e }), s = this && this.__importStar || (n = function (t) { return n = Object.getOwnPropertyNames || function (t) { var e = []; for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[e.length] = o); return e }, n(t) }, function (t) { if (t && t.__esModule) return t; var e = {}; if (null != t) for (var o = n(t), s = 0; s < o.length; s++)"default" !== o[s] && i(e, t, o[s]); return r(e, t), e }), a = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const l = s(o(578)), c = o(7394), d = a(o(9979)); e.default = (t, e, o, n, i = l.PointerDevice.Pen) => { const r = (0, d.default)(n ?? []), s = l.default.ofCanvasPoint(o, e !== c.InputEvtType.PointerUpEvt, t.viewport, r, i); return t.toolController.dispatchInputEvent({ kind: e, allPointers: n ?? [s], current: s }), s } }, 8441: function (t, e, o) { "use strict"; var n, i = this && this.__createBinding || (Object.create ? function (t, e, o, n) { void 0 === n && (n = o); var i = Object.getOwnPropertyDescriptor(e, o); i && !("get" in i ? !e.__esModule : i.writable || i.configurable) || (i = { enumerable: !0, get: function () { return e[o] } }), Object.defineProperty(t, n, i) } : function (t, e, o, n) { void 0 === n && (n = o), t[n] = e[o] }), r = this && this.__setModuleDefault || (Object.create ? function (t, e) { Object.defineProperty(t, "default", { enumerable: !0, value: e }) } : function (t, e) { t.default = e }), s = this && this.__importStar || (n = function (t) { return n = Object.getOwnPropertyNames || function (t) { var e = []; for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[e.length] = o); return e }, n(t) }, function (t) { if (t && t.__esModule) return t; var e = {}; if (null != t) for (var o = n(t), s = 0; s < o.length; s++)"default" !== o[s] && i(e, t, o[s]); return r(e, t), e }), a = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const l = s(o(578)), c = o(7394), d = a(o(9979)); e.default = (t, e, o, n) => { const i = t.viewport.screenToCanvas(o), r = (0, d.default)(n ?? []), s = l.default.ofCanvasPoint(i, e !== c.InputEvtType.PointerUpEvt, t.viewport, r, l.PointerDevice.Touch); return t.toolController.dispatchInputEvent({ kind: e, allPointers: [...n ?? [], s], current: s }), s } }, 2101: function (t, e, o) { "use strict"; var n, i, r, s, a = this && this.__classPrivateFieldGet || function (t, e, o, n) { if ("a" === o && !n) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === o ? n : "a" === o ? n.call(t) : n ? n.value : e.get(t) }, l = this && this.__classPrivateFieldSet || function (t, e, o, n, i) { if ("m" === n) throw new TypeError("Private method is not writable"); if ("a" === n && !i) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof e ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === n ? i.call(t, o) : i ? i.value = o : e.set(t, o), o }, c = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const d = o(2018), h = o(1666), u = o(7806), p = c(o(1172)), f = c(o(7955)), m = c(o(7686)), g = c(o(1011)), b = c(o(9392)), y = c(o(9108)), v = c(o(1295)), x = c(o(869)), w = c(o(5360)), S = c(o(1210)), T = o(5068), C = c(o(9751)), P = c(o(1294)), k = c(o(7021)), E = o(5379), z = o(2034), M = c(o(8230)), _ = c(o(7855)); class I { constructor(t, e = u.defaultToolbarLocalization) { this.editor = t, this.localizationTable = e, n.set(this, []), i.set(this, {}), r.set(this, []), s.set(this, null), this.closeColorPickerOverlay = null, I.colorisStarted || ((0, h.init)(), I.colorisStarted = !0), this.setupColorPickers() } setupCloseColorPickerOverlay() { this.closeColorPickerOverlay || (this.closeColorPickerOverlay = document.createElement("div"), this.closeColorPickerOverlay.className = `${z.toolbarCSSPrefix}closeColorPickerOverlay`, this.editor.createHTMLOverlay(this.closeColorPickerOverlay), a(this, n, "f").push(this.editor.handlePointerEventsExceptClicksFrom(this.closeColorPickerOverlay, (t => ("pointerdown" === t && (0, h.close)(), "pointerup" === t && this.editor.focus(), !0))))) } setupColorPickers() { if (a(this, s, "f")) return void a(this, s, "f").call(this); this.setupCloseColorPickerOverlay(); const t = [E.Color4.red.toHexString(), E.Color4.purple.toHexString(), E.Color4.blue.toHexString(), E.Color4.clay.toHexString(), E.Color4.black.toHexString(), E.Color4.white.toHexString()], e = t.length; let o = !1; const i = () => { try { (0, h.coloris)({ el: ".coloris_input", format: "hex", selectInput: !1, focusInput: !1, themeMode: "auto", swatches: t }) } catch (t) { console.warn("Failed to initialize Coloris. Error: ", t), o || (o = !0, document.addEventListener("load", (() => { i() }), { once: !0 })) } }; i(), l(this, s, i, "f"); a(this, n, "f").push(this.editor.notifier.on(d.EditorEventType.ColorPickerToggled, (t => { t.kind === d.EditorEventType.ColorPickerToggled && this.closeColorPickerOverlay && (this.closeColorPickerOverlay.style.display = t.open ? "block" : "none") }))), a(this, n, "f").push(this.editor.notifier.on(d.EditorEventType.ColorPickerColorSelected, (o => { o.kind === d.EditorEventType.ColorPickerColorSelected && (o => { let n = !1; for (const e of t) e === o && (n = !0); n || (t.push(o), t.length > 12 && t.splice(e, 1), i()) })(o.color.toHexString()) }))) } closeColorPickers() { (0, h.close)?.() } getWidgetUniqueId(t) { return t.getUniqueIdIn(a(this, i, "f")) } getWidgetFromId(t) { return a(this, i, "f")[t] } getAllWidgets() { return a(this, r, "f") } addWidget(t) { const e = t.getUniqueIdIn(a(this, i, "f")); a(this, i, "f")[e] = t, a(this, r, "f").push(t), this.addWidgetInternal(t), this.setupColorPickers() } removeWidget(t) { const e = t.getUniqueIdIn(a(this, i, "f")); this.removeWidgetInternal(t), delete a(this, i, "f")[e], l(this, r, a(this, r, "f").filter((e => e !== t)), "f") } serializeState() { const t = {}; for (const e in a(this, i, "f")) t[e] = a(this, i, "f")[e].serializeState(); return t[I.rootToolbarId] = this.serializeInternal(), JSON.stringify(t) } deserializeState(t) { const e = JSON.parse(t), o = I.rootToolbarId; this.deserializeInternal(e[o]); for (const t in e) t !== o && (t in a(this, i, "f") ? a(this, i, "f")[t].deserializeFrom(e[t]) : console.warn(`Unable to deserialize widget ${t} ­— no such widget.`)) } serializeInternal() { } deserializeInternal(t) { } makeActionButton(t, e, o = !0) { "boolean" == typeof o && (o = { mustBeToplevel: o }); const n = o.mustBeToplevel ?? !0, i = o.autoDisableInReadOnlyEditors ?? !0, r = "string" == typeof t ? t : t.label; return new C.default(this.editor, "action-button", (() => "string" == typeof t ? null : t.icon), r, e, this.editor.localization, n, i) } addActionButton(t, e, o = !0) { const n = this.makeActionButton(t, e, o); return this.addWidget(n), n } addTaggedActionButton(t, e, o, n = !0) { const i = this.makeActionButton(e, o, n); return i.setTags(t), this.addWidget(i), i } addSaveButton(t, e = {}) { const o = new M.default(this.editor, this.localizationTable, t, e); return this.addWidget(o), o } addExitButton(t, e = {}) { const o = new _.default(this.editor, this.localizationTable, t, e); return this.addWidget(o), o } addUndoRedoButtons(t = !0) { const e = () => this.addTaggedActionButton([T.ToolbarWidgetTag.Undo], { label: this.localizationTable.undo, icon: this.editor.icons.makeUndoIcon() }, (() => { this.editor.history.undo() })), o = () => this.addTaggedActionButton([T.ToolbarWidgetTag.Redo], { label: this.localizationTable.redo, icon: this.editor.icons.makeRedoIcon() }, (() => { this.editor.history.redo() })); let n, i; t ? (n = e(), i = o()) : (i = o(), n = e()), n.setDisabled(!0), i.setDisabled(!0), this.editor.notifier.on(d.EditorEventType.UndoRedoStackUpdated, (t => { if (t.kind !== d.EditorEventType.UndoRedoStackUpdated) throw new Error("Wrong event type!"); n.setDisabled(0 === t.undoStackSize), i.setDisabled(0 === t.redoStackSize) })) } addWidgetsForPrimaryTools(t) { for (const e of this.editor.toolController.getPrimaryTools()) if (!t || t?.(e)) if (e instanceof b.default) { const t = new y.default(this.editor, e, this.localizationTable); this.addWidget(t) } else e instanceof g.default ? this.addWidget(new v.default(this.editor, e, this.localizationTable)) : e instanceof p.default ? this.addWidget(new x.default(this.editor, e, this.localizationTable)) : e instanceof m.default ? this.addWidget(new w.default(this.editor, e, this.localizationTable)) : e instanceof f.default && this.addWidget(new S.default(this.editor, e, this.localizationTable)) } addDefaultToolWidgets() { this.addWidgetsForPrimaryTools(), this.addDefaultEditorControlWidgets() } addDefaultEditorControlWidgets() { this.addWidget(new k.default(this.editor, this.localizationTable)), this.addWidget(new P.default(this.editor, this.localizationTable)) } addDefaultActionButtons() { this.addUndoRedoButtons() } remove() { this.closeColorPickerOverlay?.remove(); for (const t of a(this, n, "f")) t.remove(); l(this, n, [], "f"), this.onRemove(); for (const t of a(this, r, "f")) t.remove() } manageListener(t) { a(this, n, "f").push(t) } } n = new WeakMap, i = new WeakMap, r = new WeakMap, s = new WeakMap, I.colorisStarted = !1, I.rootToolbarId = "root-toolbar--", e.default = I }, 4659: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.makeDropdownToolbar = void 0; const i = o(7806), r = n(o(816)), s = n(o(2101)), a = o(2034); e.makeDropdownToolbar = t => new l(t, t.getRootElement()); class l extends s.default { constructor(t, e, o = i.defaultToolbarLocalization) { super(t, o), this.widgetOrderCounter = 0, this.overflowWidget = null, this.reLayoutQueued = !1, this.container = document.createElement("div"), this.container.classList.add(`${a.toolbarCSSPrefix}root`), this.container.classList.add(`${a.toolbarCSSPrefix}element`), this.container.classList.add(`${a.toolbarCSSPrefix}dropdown-toolbar`), this.container.setAttribute("role", "toolbar"), e.appendChild(this.container), "ResizeObserver" in window ? (this.resizeObserver = new ResizeObserver((t => { this.reLayout() })), this.resizeObserver.observe(this.container)) : console.warn("ResizeObserver not supported. Toolbar will not resize.") } queueReLayout() { this.reLayoutQueued || (this.reLayoutQueued = !0, requestAnimationFrame((() => this.reLayout()))) } reLayout() { if (this.reLayoutQueued = !1, !this.overflowWidget) return; const t = t => { let e = 0; for (const o of t) o.isHidden() || (e += o.getButtonWidth()); return e }, e = this.getAllWidgets(); let o = t(this.overflowWidget.getChildWidgets()), n = t(e) - o, i = .87 * this.container.clientWidth; window.innerHeight > 1.75 * i && (i *= 1.75); let r = !1; if ((t => { const e = this.overflowWidget?.getChildWidgets() ?? []; return 0 !== e.length && e[0].getButtonWidth() <= t })(i - n)) { const t = this.overflowWidget.clearChildren(); for (const e of t) e.addTo(this.container), e.setIsToplevel(!0), e.isHidden() || (n += e.getButtonWidth()); o = 0, r = !0 } if (n >= i) { for (let t = e.length - 1; t >= 0 && n >= i; t--) { const o = e[t]; this.overflowWidget.hasAsChild(o) || o.canBeInOverflowMenu() && (n -= o.getButtonWidth(), this.overflowWidget.addToOverflow(o)) } r = !0 } this.overflowWidget.setHidden(0 === this.overflowWidget.getChildWidgets().length), r && this.setupColorPickers() } addWidgetInternal(t) { t.addTo(this.container).style.order = "" + this.widgetOrderCounter++, this.queueReLayout() } removeWidgetInternal(t) { t.remove(), this.queueReLayout() } addSpacer(t = {}) { const e = document.createElement("div"); e.classList.add(`${a.toolbarCSSPrefix}spacer`), t.grow && (e.style.flexGrow = `${t.grow}`), t.minSize && (e.style.minWidth = t.minSize), t.maxSize && (e.style.maxWidth = t.maxSize), e.style.order = "" + this.widgetOrderCounter++, this.container.appendChild(e) } addOverflowWidget() { this.overflowWidget = new r.default(this.editor, this.localizationTable), this.addWidget(this.overflowWidget) } addDefaults() { this.addDefaultToolWidgets(), this.addOverflowWidget(), this.addDefaultActionButtons() } onRemove() { this.container.remove(), this.resizeObserver.disconnect() } } e.default = l }, 1083: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.makeEdgeToolbar = void 0; const i = o(5068), r = o(2034), s = n(o(4175)), a = o(7988), l = n(o(2101)), c = n(o(9292)), d = n(o(1576)); e.makeEdgeToolbar = t => new h(t, t.getRootElement(), t.localization); class h extends l.default { constructor(t, e, o) { super(t, o), this.clearDragListeners = null, this.toolbarContainer = document.createElement("div"), this.toolbarContainer.classList.add(`${r.toolbarCSSPrefix}root`), this.toolbarContainer.classList.add(`${r.toolbarCSSPrefix}element`), this.toolbarContainer.classList.add(`${r.toolbarCSSPrefix}edge-toolbar`), this.toolbarContainer.setAttribute("role", "toolbar"), this.toolbarActionRow = document.createElement("div"), this.toolbarActionRow.classList.add("toolbar-element", "toolbar-action-row"), this.toolbarToolRow = document.createElement("div"), this.toolbarToolRow.classList.add("toolbar-element", "toolbar-tool-row"), (0, c.default)(this.toolbarToolRow), "ResizeObserver" in window ? (this.toolRowResizeObserver = new ResizeObserver((t => { this.onToolbarRowResize() })), this.toolRowResizeObserver.observe(this.toolbarToolRow)) : console.warn("ResizeObserver not supported. Toolbar will not resize."), this.toolbarContainer.replaceChildren(this.toolbarActionRow, this.toolbarToolRow), e.appendChild(this.toolbarContainer), this.sidebarVisible = a.ReactiveValue.fromInitialValue(!1), this.sidebarY = a.ReactiveValue.fromInitialValue(0), this.menuContainer = document.createElement("div"), this.menuContainer.classList.add(`${r.toolbarCSSPrefix}edgemenu-container`), this.sidebarContainer = document.createElement("div"), this.sidebarContainer.classList.add(`${r.toolbarCSSPrefix}edgemenu`, `${r.toolbarCSSPrefix}element`), this.sidebarContainer.classList.add(`${r.toolbarCSSPrefix}tool-properties`), this.sidebarContent = document.createElement("div"), this.sidebarY.onUpdateAndNow((t => { const e = "dropdown-below-edge"; t > 0 ? (this.sidebarContainer.style.transform = `translate(0, ${t}px)`, this.sidebarContainer.style.paddingBottom = "", this.menuContainer.classList.add(e)) : (this.sidebarContainer.style.transform = "", this.sidebarContainer.style.paddingBottom = -t + "px", this.menuContainer.classList.remove(e)) })), this.closeButton = document.createElement("button"), this.closeButton.classList.add("drag-elem"), this.editor.handleKeyEventsFrom(this.closeButton, (t => "Space" !== t.code && "Enter" !== t.code && "Tab" !== t.code)), this.sidebarContainer.addEventListener("keyup", (t => { t.defaultPrevented || "Escape" !== t.code || (this.sidebarVisible.set(!1), t.preventDefault()) })), this.initDragListeners(); this.sidebarTitle = a.MutableReactiveValue.fromInitialValue(""), this.layoutManager = new s.default(((...t) => { this.sidebarContent.replaceChildren(...t), this.setupColorPickers() }), this.sidebarTitle, this.sidebarVisible, t.announceForAccessibility.bind(t), o), this.sidebarTitle.onUpdateAndNow((t => { this.closeButton.setAttribute("aria-label", o.closeSidebar(t)) })), this.listenForVisibilityChanges(), this.sidebarContainer.replaceChildren(this.closeButton, this.sidebarContent), this.menuContainer.replaceChildren(this.sidebarContainer), e.appendChild(this.menuContainer) } listenForVisibilityChanges() { let t = null; this.sidebarVisible.get() || (this.menuContainer.style.display = "none", this.menuContainer.style.opacity = "0"); const e = window.matchMedia?.("(prefers-reduced-motion: reduce)") ?? ""; this.sidebarVisible.onUpdate((o => { const n = "170ms ease", i = e.matches ? "-reduce-motion" : ""; o ? (this.sidebarY.set(this.snappedSidebarY()), t && (clearTimeout(t), t = null), this.menuContainer.style.display = "", this.sidebarContainer.style.animation = `${n} ${r.toolbarCSSPrefix}-edgemenu-transition-in${i}`, this.menuContainer.style.animation = `${n} ${r.toolbarCSSPrefix}-edgemenu-container-transition-in${i}`, this.menuContainer.style.opacity = "1", this.closeButton.focus({ preventScroll: !0 })) : (this.closeColorPickers(), null === t && (this.sidebarContainer.style.animation = `${n} ${r.toolbarCSSPrefix}-edgemenu-transition-out${i}`, this.menuContainer.style.animation = `${n} ${r.toolbarCSSPrefix}-edgemenu-container-transition-out${i}`, this.menuContainer.style.opacity = "0", this.editor.announceForAccessibility(this.localizationTable.dropdownHidden(this.sidebarTitle.get())), t = setTimeout((() => { this.menuContainer.style.display = "none", this.menuContainer.style.overflowY = "", t = null }), 170))) })) } onToolbarRowResize() { const t = () => { const t = this.toolbarToolRow.clientWidth; let e = 0, o = 0, n = 0; for (const i of this.toolbarToolRow.children) { const r = i.clientHeight; if (e += r, n++, e > t) { o = t - e + r / 2, o < 0 && (o += r); break } } const i = Math.round(o / n * 10) / 10; this.toolbarToolRow.style.setProperty("--extra-left-right-padding", `${i}px`) }, e = this.toolbarActionRow.getBoundingClientRect(), o = this.toolbarToolRow.getBoundingClientRect(); e.y + e.height <= o.y ? this.toolbarContainer.classList.remove("one-row") : this.toolbarContainer.classList.add("one-row"), this.toolbarToolRow.clientWidth < this.toolbarToolRow.scrollWidth ? (this.toolbarToolRow.classList.add("has-scroll"), t()) : this.toolbarToolRow.classList.remove("has-scroll", "extra-padding") } addSpacer(t) { } addUndoRedoButtons() { super.addUndoRedoButtons(!1) } addDefaults() { this.addDefaultActionButtons(), this.addDefaultToolWidgets() } updateWidgetCSSClasses(t) { const e = t.getTags(); t.removeCSSClassFromContainer("label-inline"), t.removeCSSClassFromContainer("label-left"), t.removeCSSClassFromContainer("label-right"), e.includes(i.ToolbarWidgetTag.Save) && (t.addCSSClassToContainer("label-inline"), t.addCSSClassToContainer("label-left")), e.includes(i.ToolbarWidgetTag.Exit) && (t.addCSSClassToContainer("label-inline"), t.addCSSClassToContainer("label-right")) } addWidgetInternal(t) { this.updateWidgetCSSClasses(t), t.setLayoutManager(this.layoutManager), t.mustBeInToplevelMenu() ? t.addTo(this.toolbarActionRow) : t.addTo(this.toolbarToolRow) } removeWidgetInternal(t) { t.remove() } onRemove() { this.toolbarContainer.remove(), this.menuContainer.remove(), this.toolRowResizeObserver.disconnect(), this.clearDragListeners?.() } initDragListeners() { const t = [this.closeButton, this.sidebarContainer, this.sidebarContent]; this.manageListener(this.editor.handlePointerEventsExceptClicksFrom(this.menuContainer, ((t, e) => e.target === this.menuContainer ? ("pointerdown" === t && (this.sidebarVisible.set(!1), setTimeout((() => this.editor.focus()), 0)), !0) : !this.sidebarVisible.get()), ((t, e) => e.target === this.menuContainer))); let e = !0, o = 0; const n = (0, d.default)(this.sidebarContainer, { draggableChildElements: t, onDrag: (t, e) => this.handleDrag(t, e), onDragEnd: t => { o = t.endTimestamp, e = t.roughlyClick, this.finalizeDrag() } }); this.clearDragListeners = () => n.removeListeners(), this.closeButton.onclick = () => { const t = performance.now() - o < 100; (t && e || !t) && this.sidebarVisible.set(!1) } } handleDrag(t, e) { this.sidebarContainer.style.transition = "none", this.sidebarY.set(this.sidebarY.get() + e) } snappedSidebarY(t) { const e = t ?? this.sidebarY.get(), o = [-100, 0]; this.sidebarContainer.clientHeight > window.innerHeight && o.push(100); let n = o[0]; for (const t of o) Math.abs(t - e) < Math.abs(n - e) && (n = t); return n } finalizeDrag() { this.sidebarContainer.style.transition = "", this.sidebarY.get() > this.sidebarContainer.clientHeight / 2 ? this.sidebarVisible.set(!1) : this.sidebarY.set(this.snappedSidebarY()) } serializeInternal() { return { menuSizeY: this.snappedSidebarY() } } deserializeInternal(t) { "object" == typeof t && "number" == typeof t.menuSizeY && this.sidebarY.set(this.snappedSidebarY(t.menuSizeY)) } } e.default = h }, 6975: function (t, e, o) { "use strict"; var n, i, r = this && this.__classPrivateFieldGet || function (t, e, o, n) { if ("a" === o && !n) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === o ? n : "a" === o ? n.call(t) : n ? n.value : e.get(t) }, s = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const a = o(5379), l = s(o(1598)), c = s(o(4093)), d = o(9177), h = o(1342), u = o(1011), p = o(7964), f = "http://www.w3.org/2000/svg"; let m = 0; const g = () => { const t = "checkerboard-" + m++, e = (0, p.createSvgElement)("pattern", { id: t, viewBox: "0,0,10,10", width: "20%", height: "20%", patternUnits: "userSpaceOnUse", children: (0, p.createSvgElements)("rect", [{ x: 0, y: 0, width: 10, height: 10, fill: "white" }, { x: 0, y: 0, width: 5, height: 5, fill: "gray" }, { x: 5, y: 5, width: 5, height: 5, fill: "gray" }]) }), o = `url(#${t})`; return { patternDefElement: e, get patternDef() { return e.innerHTML }, patternRef: o } }, b = t => { const e = document.createElementNS(f, "svg"); e.innerHTML = "\n\t\t<style>\n\t\t\t.toolbar-svg-undo-redo-icon {\n\t\t\t\tstroke: var(--icon-color);\n\t\t\t\tstroke-width: 12;\n\t\t\t\tstroke-linejoin: round;\n\t\t\t\tstroke-linecap: round;\n\t\t\t\tfill: none;\n\n\t\t\t\ttransform-origin: center;\n\t\t\t}\n\t\t</style>\n\t"; const o = document.createElementNS(f, "path"); return o.setAttribute("d", "M20,20 A15,15 0 0 1 70,80 L80,90 L60,70 L65,90 L87,90 L65,80"), o.classList.add("toolbar-svg-undo-redo-icon"), t && (o.style.transform = "scale(-1, 1)"), e.appendChild(o), e.setAttribute("viewBox", "0 0 100 100"), e }; n = new WeakSet, i = function () { return this.makeIconFromPath("\n\t\t\tM 15,15 85,85\n\t\t\tM 15,85 85,15\n\t\t", "none", "var(--icon-color)", "6px") }, e.default = class { constructor() { n.add(this) } makeUndoIcon() { return b(!0) } makeRedoIcon() { return b(!1) } makeDropdownIcon() { const t = this.makeIconFromPath("M5,10 L50,90 L95,10 Z"); return t.setAttribute("viewBox", "-10 -10 110 110"), t } makeEraserIcon(t, e) { t ??= 10; const o = t / 4, n = "#ff70af"; return (0, p.createSvgElement)("svg", { viewBox: "0 0 120 120", children: [(0, p.createSvgElement)("defs", { children: [(0, p.createSvgElement)("linearGradient", { id: "dash-pattern", children: (0, p.createSvgElements)("stop", [{ offset: "80%", "stop-color": n }, { offset: "85%", "stop-color": "white" }, { offset: "90%", "stop-color": n }]) })] }), (0, p.createSvgElement)("path", { fill: e === u.EraserMode.PartialStroke ? "url(#dash-pattern)" : n, stroke: "black", transform: "rotate(41.35)", d: `\n\t\t\t\t\t\tM 52.5 27\n\t\t\t\t\t\tC 50 28.9 48.9 31.7 48.9 34.8\n\t\t\t\t\t\tL 48.9 39.8\n\t\t\t\t\t\tC 48.9 45.3 53.4 49.8 58.9 49.8\n\t\t\t\t\t\tL 103.9 49.8\n\t\t\t\t\t\tC 105.8 49.8 107.6 49.2 109.1 48.3\n\t\t\t\t\t\tL 110.2 ${o + 49.5} L 159.7 ${o + 5}\n\t\t\t\t\t\tL 157.7 ${5.2 - o} L 112.4 ${49.5 - o}\n\t\t\t\t\t\tC 113.4 43.5 113.9 41.7 113.9 39.8\n\t\t\t\t\t\tL 113.9 34.8\n\t\t\t\t\t\tC 113.9 29.3 109.4 24.8 103.9 24.8\n\t\t\t\t\t\tL 58.9 24.8\n\t\t\t\t\t\tC 56.5 24.8 54.3 25.7 52.5 27\n\t\t\t\t\t\tz\n\t\t\t\t\t` }), (0, p.createSvgElement)("rect", { stroke: "#cc8077", fill: "var(--icon-color)", width: 65, height: 75, x: 48.9, y: -38.7, transform: "rotate(41.35)" })] }) } makeSelectionIcon() { const t = document.createElementNS(f, "svg"); return t.innerHTML = '\n\t\t<g>\n\t\t\t<rect x="10" y="10" width="70" height="70" fill="pink" stroke="black"/>\n\t\t\t<rect x="75" y="75" width="10" height="10" fill="white" stroke="black"/>\n\t\t</g>\n\t\t', t.setAttribute("viewBox", "0 0 100 100"), t } makeRotateIcon() { const t = document.createElementNS(f, "svg"); return t.innerHTML = '\n\t\t\t<defs>\n\t\t\t\t<marker\n\t\t\t\t\tid="arrow-marker"\n\t\t\t\t\tviewBox="0 0 10 10"\n\t\t\t\t\trefX="3" refY="5"\n\t\t\t\t\tmarkerWidth="3" markerHeight="3"\n\t\t\t\t\torient="auto-start-reverse"\n\t\t\t\t>\n\t\t\t\t\t<path\n\t\t\t\t\t\td="M0,0 L8,5 L0,10z"\n\t\t\t\t\t\tfill="var(--icon-color)"\n\t\t\t\t\t/>\n\t\t\t\t</marker>\n\t\t\t</defs>\n\n\t\t\t<path\n\t\t\t\tmarker-start="url(#arrow-marker)"\n\t\t\t\td="\n\t\t\t\t\tM20,20\n\t\t\t\t\tA30,30 0 1 1 80 80\n\t\t\t\t"\n\t\t\t\tfill="none"\n\t\t\t\tstroke="var(--icon-color)"\n\t\t\t\tstroke-width="12"\n\t\t\t/>\n\t\t\t<path\n\t\t\t\td="\n\t\t\t\t\tM80,80\n\t\t\t\t\tA30,30 0 1 1 20 20\n\t\t\t\t"\n\t\t\t\tfill="none"\n\t\t\t\tstroke="var(--icon-color)"\n\t\t\t\tstroke-width="12"\n\t\t\t\tstroke-dasharray="30 10 20 10 20 10 10"\n\t\t\t\tstyle="stroke-linecap: butt;"\n\t\t\t/>\n\t\t', t.setAttribute("viewBox", "-5 -5 110 110"), t } makeHandToolIcon() { return this.makeIconFromPath("\n\t\t\tm 10,60\n\t\t\t\t5,30\n\t\t\tH 90\n\t\t\tV 30\n\t\t\tC 90,20 75,20 75,30\n\t\t\tV 60\n\t\t\t\t20\n\t\t\tC 75,10 60,10 60,20\n\t\t\tV 60\n\t\t\t\t15\n\t\t\tC 60,5 45,5 45,15\n\t\t\tV 60\n\t\t\t\t25\n\t\t\tC 45,15 30,15 30,25\n\t\t\tV 60\n\t\t\t\t75\n\t\t\tL 25,60\n\t\t\tC 20,45 10,50 10,60\n\t\t\tZ\n\t\t", "none", "var(--icon-color)", "3") } makeTouchPanningIcon() { return this.makeIconFromPath("\n\t\t\tM 5,5.5\n\t\t\tV 17.2\n\t\t\tL 16.25,5.46\n\t\t\tZ\n\t\n\t\t\tm 33.75,0\n\t\t\tL 50,17\n\t\t\tV 5.5\n\t\t\tZ\n\t\n\t\t\tM 5,40.7\n\t\t\tv 11.7\n\t\t\th 11.25\n\t\t\tz\n\t\n\t\t\tM 26,19\n\t\t\tC 19.8,19.4 17.65,30.4 21.9,34.8\n\t\t\tL 50,70\n\t\t\tH 27.5\n\t\t\tc -11.25,0 -11.25,17.6 0,17.6\n\t\t\tH 61.25\n\t\t\tC 94.9,87.8 95,87.6 95,40.7 78.125,23 67,29 55.6,46.5\n\t\t\tL 33.1,23\n\t\t\tC 30.3125,20.128192 27.9,19 25.830078,19.119756\n\t\t\tZ\n\t\t", "none", "var(--icon-color)", "3") } makeAllDevicePanningIcon() { return this.makeIconFromPath("\n\t\t\tM 5 5\n\t\t\tL 5 17.5\n\t\t\t\t17.5 5\n\t\t\t\t5 5\n\t\t\tz\n\t\n\t\t\tM 42.5 5\n\t\t\tL 55 17.5\n\t\t\t\t55 5\n\t\t\t\t42.5 5\n\t\t\tz\n\t\n\t\t\tM 70 10\n\t\t\tL 70 21\n\t\t\t\t61 15\n\t\t\t\t55.5 23\n\t\t\t\t66 30\n\t\t\t\t56 37\n\t\t\t\t61 45\n\t\t\t\t70 39\n\t\t\t\t70 50\n\t\t\t\t80 50\n\t\t\t\t80 39\n\t\t\t\t89 45\n\t\t\t\t95 36\n\t\t\t\t84 30\n\t\t\t\t95 23\n\t\t\t\t89 15\n\t\t\t\t80 21\n\t\t\t\t80 10\n\t\t\t\t70 10\n\t\t\tz\n\t\n\t\t\tM 27.5 26.25\n\t\t\tL 27.5 91.25\n\t\t\tL 43.75 83.125\n\t\t\tL 52 99\n\t\t\tL 68 91\n\t\t\tL 60 75\n\t\t\tL 76.25 66.875\n\t\t\tL 27.5 26.25\n\t\t\tz\n\t\n\t\t\tM 5 42.5\n\t\t\tL 5 55\n\t\t\tL 17.5 55\n\t\t\tL 5 42.5\n\t\t\tz\n\t\t", "none", "var(--icon-color)", "3") } makeZoomIcon() { const t = document.createElementNS(f, "svg"); t.setAttribute("viewBox", "0 0 100 100"); const e = (e, o, n) => { const i = document.createElementNS(f, "text"); i.appendChild(document.createTextNode(e)), i.setAttribute("x", o.toString()), i.setAttribute("y", n.toString()), i.style.textAlign = "center", i.style.textAnchor = "middle", i.style.fontSize = "55px", i.style.fill = "var(--icon-color)", i.style.fontFamily = "monospace", t.appendChild(i) }; return e("+", 40, 45), e("-", 70, 75), t } makeRotationLockIcon() { const t = this.makeIconFromPath("\n\t\t\tM 40.1 25.1 \n\t\t\tC 32.5 25 27.9 34.1 27.9 34.1 \n\t\t\tL 25.7 30 \n\t\t\tL 28 44.7 \n\t\t\tL 36.6 40.3 \n\t\t\tL 32.3 38.3 \n\t\t\tC 33.6 28 38.1 25.2 45.1 31.8 \n\t\t\tL 49.4 29.6 \n\t\t\tC 45.9 26.3 42.8 25.1 40.1 25.1 \n\t\t\tz\n\n\t\t\tM 51.7 34.2 \n\t\t\tL 43.5 39.1 \n\t\t\tL 48 40.8 \n\t\t\tC 47.4 51.1 43.1 54.3 35.7 48.2 \n\t\t\tL 31.6 50.7 \n\t\t\tC 45.5 62.1 52.6 44.6 52.6 44.6 \n\t\t\tL 55.1 48.6 \n\t\t\tL 51.7 34.2 \n\t\t\tz\n\n\t\t\tM 56.9 49.9 \n\t\t\tC 49.8 49.9 49.2 57.3 49.3 60.9 \n\t\t\tL 47.6 60.9 \n\t\t\tL 47.6 73.7 \n\t\t\tL 66.1 73.7 \n\t\t\tL 66.1 60.9 \n\t\t\tL 64.4 60.9 \n\t\t\tC 64.5 57.3 63.9 49.9 56.9 49.9 \n\t\t\tz\n\n\t\t\tM 56.9 53.5 \n\t\t\tC 60.8 53.5 61 58.2 60.8 60.9 \n\t\t\tL 52.9 60.9 \n\t\t\tC 52.7 58.2 52.9 53.5 56.9 53.5 \n\t\t\tz\n\t\t"); return t.setAttribute("viewBox", "10 10 70 70"), t } makeInsertImageIcon() { return this.makeIconFromPath("\n\t\t\tM 5 10 L 5 90 L 95 90 L 95 10 L 5 10 z\n\t\t\tM 10 15 L 90 15 L 90 50 L 70 75 L 40 50 L 10 75 L 10 15 z\n\t\t\tM 22.5 25 A 7.5 7.5 0 0 0 15 32.5 A 7.5 7.5 0 0 0 22.5 40 A 7.5 7.5 0 0 0 30 32.5 A 7.5 7.5 0 0 0 22.5 25 z \n\t\t") } makeUploadFileIcon() { return this.makeIconFromPath("\n\t\t\tM 48,10 32,34 43,33 42,68\n\t\t\tH 54\n\t\t\tL 53,33 64,34 Z\n\t\n\t\t\tM 8,66 V 86 H 88 V 66 H 78 V 76 H 18 V 66 Z\n\t\t") } makeTextIcon(t) { const e = document.createElementNS(f, "svg"); e.setAttribute("viewBox", "0 0 100 100"); const o = document.createElementNS(f, "text"); return o.appendChild(document.createTextNode("T")), o.style.fontFamily = t.fontFamily, o.style.fontWeight = t.fontWeight ?? "", o.style.fontVariant = t.fontVariant ?? "", o.style.fill = t.renderingStyle.fill.toHexString(), o.style.textAnchor = "middle", o.setAttribute("x", "50"), o.setAttribute("y", "75"), o.style.fontSize = "65px", o.style.filter = "drop-shadow(0px 0px 10px var(--shadow-color))", e.appendChild(o), e } makePenIcon(t) { const e = Math.round(4 * Math.sqrt(t.thickness)), o = t.color, n = e / 2, i = `\n\t\t\tM ${15 - n},${80 - n}\n\t\t\t  ${15 - n},${80 + n}\n\t\t\t  30,83\n\t\t\t  15,65\n\t\t\tZ\n\t\t`, r = 80 + n, s = `\n\t\t\tm ${15 - 1.1 * n},${r}\n\t\t\tc 35,10 55,15 60,30\n\t\t\tl ${35 + 1.2 * n},${-10 - n}\n\t\t\tC 80.47,98.32 50.5,${90 + n} 20,${r} Z\n\t\t`, l = "\n\t\t\tM 72.45,35.67\n\t\t\tA 10,15 41.8 0 1 55,40.2 10,15 41.8 0 1 57.55,22.3 10,15 41.8 0 1 75,17.8 10,15 41.8 0 1 72.5,35.67\n\t\t\tZ\n\t\t"; let c = "M 85,-25 25,35 h 10 v 10 h 10 v 10 h 10 v 10 h 10 l -5,10 60,-60 z", d = "M 25,35 H 35 L 90,-15 85,-25 Z", h = "M 60,75 65,65 H 55 l 55,-55 10,5 z"; this.isRoundedTipPen(t) && (c = "M 85,-25 25,35 c 15,0 40,30 35,40 l 60,-60 z", d = "m 25,35 c 3.92361,0.384473 7.644275,0.980572 10,3 l 55,-53 -5,-10 z", h = "M 60,75 C 61,66 59,65 56,59 l 54,-54 10,10 z"); const u = `M 25,35 ${10 - n / 4},${70 - n / 2} 20,75 25,85 60,75 70,55 45,25 Z`, m = a.Color4.fromHex("#f4d7d7").mix(o, n / 40 - .1).toHexString(), b = g(), y = o.toHexString(), v = (0, p.createSvgPaths)({ fill: b.patternRef, d: i }, { fill: b.patternRef, d: s }, { fill: y, d: i }, { fill: y, d: s }), x = (0, p.createSvgPaths)({ fill: b.patternRef, d: u }, { fill: m, stroke: y, d: u }), w = (0, p.createSvgPaths)({ fill: "var(--icon-color)", stroke: "var(--icon-color)", d: c }, { fill: "rgba(150, 150, 150, 0.3)", d }, { fill: "rgba(100, 100, 100, 0.2)", d: h }, { fill: b.patternRef, d: l }, { fill: y, d: l }), S = document.createElementNS(f, "svg"); S.setAttribute("viewBox", "0 0 100 100"); const T = (0, p.createSvgElement)("g", { children: [v, x, w].flat() }), C = (0, p.createSvgElement)("defs", { children: [b.patternDefElement] }); return S.replaceChildren(C, T), S } makeIconFromFactory(t) { const e = 3 * Math.sqrt(t.thickness), o = performance.now(), n = { pos: a.Vec2.of(10, 10), width: e, color: t.color, time: o - 100 }, i = { pos: a.Vec2.of(90, 90), width: e, color: t.color, time: o }, r = new c.default((() => { })), s = t.factory(n, r); s.addPoint(i); const d = document.createElementNS(f, "svg"); let h; d.setAttribute("viewBox", "0 0 100 100"), r.updateScreenSize(a.Vec2.of(100, 100)); if (t.color.a < 1) { const t = g(), e = document.createElementNS(f, "defs"); e.appendChild(t.patternDefElement), d.appendChild(e); const o = document.createElementNS(f, "g"); d.appendChild(o), h = new class extends l.default { constructor() { super(d, r) } addPathToSVG() { const e = super.addPathToSVG(); if (e) { const n = e.cloneNode(!0); n.style.zIndex = "-1", n.hasAttribute("stroke") ? n.setAttribute("stroke", t.patternRef) : n.hasAttribute("fill") && n.setAttribute("fill", t.patternRef), o.appendChild(n) } return e } } } else h = new l.default(d, r); s.preview(h); const u = s.getBBox(); return d.setAttribute("viewBox", `${u.x} ${u.y} ${u.w} ${u.h}`), d } makePipetteIcon(t) { const e = document.createElementNS(f, "svg"), o = document.createElementNS(f, "g"); o.style.rotate = "45deg", o.style.transformOrigin = "center"; const n = document.createElementNS(f, "g"); if (n.innerHTML = '\n\t\t<path\n\t\t\tstyle="fill: var(--icon-color); stroke-linecap:round; stroke-linejoin:round;"\n\t\t\td="\n\t\t\t\tm 32,12 v 68\n\t\t\t\tc 0,1 0.5,2 1.33,2.5 1.67,1.15 3.67,2.1 5.17,3.2 1.4,1.1 2.3,2.1 2.5,3.1 0.6,2.1 1,4.6 1,6.2 0,3.7 5.45,4.1 6,0.4 l 0.9,-6.8\n\t\t\t\tc 0.3,-0.9 1.1,-1.9 2.6,-2.9 1.5,-1.1 3.4,-2 5.1,-3.2\n\t\t\t\tC 57.5,82 58,81 58,80\n\t\t\t\tV 12 Z m 20,25 v 41.3\n\t\t\t\tc 0,1.7 -2.5,1.6 -4,2.7 -1,0.76 -2.1,1.5 -3,2.6\n\t\t\t\tC 44,82.5 43.02,81.75 42,81 40.51,79.92 38,80 38,78.34\n\t\t\t\tV 51 Z\n\t\t\t"\n\t\t/>\n\t\t<rect\n\t\t\tstyle="fill: var(--icon-color);"\n\t\t\twidth="32"\n\t\t\theight="9"\n\t\t\tx="29"\n\t\t\ty="2"\n\t\t\try="4.5"\n\t\t/>\n\t\t<path\n\t\t\tstyle="fill: var(--icon-color);"\n\t\t\td="m 45,-25 c -5.54,0 -11,4.26 -11,9 V 0 h 22 v -16 c 0,-4.74 -5.46,-9 -11,-9 z"\n\t\t/>\n\t\t', t) { const n = g(), i = document.createElementNS(f, "defs"); i.appendChild(n.patternDefElement), e.appendChild(i); const r = document.createElementNS(f, "path"), s = document.createElementNS(f, "path"), a = "\n\t\t\t\tM 35,36 H 55 V 78.678012 83 L 45,87 35,83 Z\n\t\t\t"; s.setAttribute("d", a), r.setAttribute("d", a), s.style.fill = t.toHexString(), r.style.fill = n.patternRef, o.appendChild(r), o.appendChild(s) } return o.appendChild(n), e.appendChild(o), e.setAttribute("viewBox", "5 -40 140 140"), e } makeShapeAutocorrectIcon() { return this.makeIconFromPath("\n\t\t\tm 79.129476,33.847107 9.967823,-0.03218 v 55 h -55 l 0.03218,-9.96782\n\t\t\tM 71.1,40.8 a 30,30 0 0 1 -30,30 30,30 0 0 1 -30,-30 30,30 0 0 1 30,-30 30,30 0 0 1 30,30 L 71.1,40.8\n\t\t\tM 34.1,58.8 v -25 h 25 v 0\n\t\t", "none", "var(--icon-color)", "7px") } makeStrokeSmoothingIcon() { return this.makeIconFromPath("\n\t\t\tm 31,83.2 c -50,0 30,-65 -20,-65\n\t\t\tM 75,17.3 40,59.7 38.2,77.6 55.5,72.4 90.5,30 Z\n\t\t", "none", "var(--icon-color)", "7px") } makeFormatSelectionIcon() { return this.makeIconFromPath("\n\t\t\tM 5 10\n\t\t\tL 5 20 L 10 20 L 10 15 L 20 15 L 20 40 L 15 40 L 15 45 L 35 45 L 35 40 L 30 40 L 30 15 L 40 15 L 40 20 L 45 20 L 45 15 L 45 10 L 5 10 z\n\t\t\tM 90 10 C 90 10 86.5 13.8 86 14 C 86 14 76.2 24.8 76 25 L 60 25 L 60 65 C 75 70 85 70 90 65 L 90 25 L 80 25 L 76.7 25 L 90 10 z\n\t\t\tM 60 25 L 55 25 L 50 30 L 60 25 z\n\t\t\tM 10 55 L 10 90 L 41 90 L 41 86 L 45 86 L 45 55 L 10 55 z\n\t\t\tM 42 87 L 42 93 L 48 93 L 48 87 L 42 87 z \n\t\t") } makeResizeImageToSelectionIcon() { return this.makeIconFromPath("\n\t\t\tM 75 5 75 10 90 10 90 25 95 25 95 5 75 5 z\n\t\t\tM 15 15 15 30 20 30 20 20 30 20 30 15 15 15 z\n\t\t\tM 84 15 82 17 81 16 81 20 85 20 84 19 86 17 84 15 z\n\t\t\tM 26 24 24 26 26 28 25 29 29 29 29 25 28 26 26 24 z\n\t\t\tM 25 71 26 72 24 74 26 76 28 74 29 75 29 71 25 71 z\n\t\t\tM 15 75 15 85 25 85 25 80 20 80 20 75 15 75 z\n\t\t\tM 90 75 90 90 75 90 75 95 95 95 95 75 90 75 z\n\t\t\tM 81 81 81 85 82 84 84 86 86 84 84 82 85 81 81 81 z\n\t\t") } makeResizeViewportIcon() { return this.makeResizeImageToSelectionIcon() } makeDuplicateSelectionIcon() { return this.makeIconFromPath("\n\t\t\tM 45,10 45,55 90,55 90,10 45,10 z\n\t\t\tM 10,25 10,90 70,90 70,60 40,60 40,25 10,25 z \n\t\t") } makeCopyIcon() { return this.makeIconFromPath("\n\t\t\tM 45,10 45,55 90,55 90,10 45,10 z\n\t\t\tM 10,25 10,90 70,90 70,60 40,60 40,25 10,25 z \n\t\t") } makePasteIcon() { const t = this.makeIconFromPath("\n\t\t\tM 50 0 L 50 5 L 35 5 L 40 24.75 L 20 25 L 20 100 L 85 100 L 100 90 L 100 24 L 75.1 24.3 L 80 5 L 65 5 L 65 0 L 50 0 z\n\t\t\tM 10 15 L 10 115 L 110 115 L 110 15 L 85 15 L 83 20 L 105 20 L 105 110 L 15 110 L 15 20 L 32 20 L 30 15 L 10 15 z\n\t\t\tM 25 35 L 90 35 L 90 40 L 25 40 L 25 35 z\n\t\t\tM 25 45 L 90 45 L 90 50 L 25 50 L 25 45 z\n\t\t\tM 25 55 L 85 55 L 85 60 L 25 60 L 25 55 z\n\t\t\tM 25 65 L 90 65 L 90 70 L 25 70 L 25 65 z \n\t\t"); return t.setAttribute("viewBox", "0 0 120 120"), t } makeDeleteSelectionIcon() { return r(this, n, "m", i).call(this) } makeCloseIcon() { return r(this, n, "m", i).call(this) } makeSaveIcon() { const t = document.createElementNS("http://www.w3.org/2000/svg", "svg"); return t.innerHTML = "\n\t\t\t<style>\n\t\t\t\t.toolbar-save-icon {\n\t\t\t\t\tstroke: var(--icon-color);\n\t\t\t\t\tstroke-width: 6;\n\t\t\t\t\tstroke-linejoin: round;\n\t\t\t\t\tstroke-linecap: round;\n\t\t\t\t\tfill: none;\n\t\t\t\t}\n\t\t\t</style>\n\t\t\t<path\n\t\t\t\td='\n\t\t\t\t\tM 15,55 30,70 85,20\n\t\t\t\t'\n\t\t\t\tclass='toolbar-save-icon'\n\t\t\t/>\n\t\t", t.setAttribute("viewBox", "0 0 100 100"), t } makeConfigureDocumentIcon() { const t = document.createElementNS("http://www.w3.org/2000/svg", "svg"); return t.innerHTML = "\n\t\t\t<path\n\t\t\t\td='\n\t\t\t\t\tM 5,5 V 95 H 95 V 5 Z m 5,5 H 90 V 90 H 10 Z\n\t\t\t\t\tm 5,10 V 30 H 50 V 25 H 20 v -5 z\n\t\t\t\t\tm 40,0 V 50 H 85 V 20 Z\n\t\t\t\t\tm 2,2 H 83 V 39 L 77,28 70,42 64,35 57,45 Z\n\t\t\t\t\tm 8.5,5 C 64.67,27 64,27.67 64,28.5 64,29.33 64.67,30 65.5,30 66.33,30 67,29.33 67,28.5 67,27.67 66.33,27 65.5,27 Z\n\t\t\t\t\tM 15,40 v 5 h 35 v -5 z\n\t\t\t\t\tm 0,15 v 5 h 70 v -5 z\n\t\t\t\t\tm 0,15 v 5 h 70 v -5 z\n\t\t\t\t'\n\t\t\t\tstyle='fill: var(--icon-color);'\n\t\t\t/>\n\t\t", t.setAttribute("viewBox", "0 0 100 100"), t } makeOverflowIcon() { return this.makeIconFromPath("\n\t\t\tM 15 40\n\t\t\tA 12.5 12.5 0 0 0 2.5 52.5\n\t\t\tA 12.5 12.5 0 0 0 15 65\n\t\t\tA 12.5 12.5 0 0 0 27.5 52.5\n\t\t\tA 12.5 12.5 0 0 0 15 40\n\t\t\tz\n\t\n\t\t\tM 50 40\n\t\t\tA 12.5 12.5 0 0 0 37.5 52.5\n\t\t\tA 12.5 12.5 0 0 0 50 65\n\t\t\tA 12.5 12.5 0 0 0 62.5 52.5\n\t\t\tA 12.5 12.5 0 0 0 50 40\n\t\t\tz\n\t\t\t\n\t\t\tM 85 40\n\t\t\tA 12.5 12.5 0 0 0 72.5 52.5\n\t\t\tA 12.5 12.5 0 0 0 85 65\n\t\t\tA 12.5 12.5 0 0 0 97.5 52.5\n\t\t\tA 12.5 12.5 0 0 0 85 40\n\t\t\tz\n\t\t") } makeHelpIcon() { const t = document.createElementNS("http://www.w3.org/2000/svg", "svg"); return t.innerHTML = '\n\t\t\t<circle\n\t\t\t\tstyle="stroke-width:1.587; stroke: var(--icon-color);"\n\t\t\t\tfill="none"\n\t\t\t\tcx="13.23"\n\t\t\t\tcy="13.23"\n\t\t\t\tr="11.9"\n\t\t\t/>\n\t\t\t<path\n\t\t\t\tstyle="stroke-width: 3; stroke-linecap: butt; stroke: var(--icon-color);"\n\t\t\t\tfill="none"\n\t\t\t\td="M 9.26,6.61 C 18.7,3.25 19.95,10.4 14.3,13.4 c -1.15,0.61 -1.32,1.32 -1.32,2.65 v 2.12"\n\t\t\t/>\n\t\t\t<circle\n\t\t\t\tstyle="fill: var(--icon-color);"\n\t\t\t\tcx="13"\n\t\t\t\tcy="21.32"\n\t\t\t\tr="1.9"\n\t\t\t/>\n\t\t', t.setAttribute("viewBox", "0 0 26.46 26.46"), t.setAttribute("width", "100"), t.setAttribute("height", "100"), t } makeIconFromPath(t, e = "var(--icon-color)", o = "none", n = "0px") { const i = document.createElementNS(f, "svg"), r = document.createElementNS(f, "path"); return r.setAttribute("d", t), r.style.fill = e, r.style.stroke = o, r.style.strokeWidth = n, i.appendChild(r), i.setAttribute("viewBox", "0 0 100 100"), i } makeCheckerboardPattern() { return g() } isRoundedTipPen(t) { return t.factory === d.makeFreehandLineBuilder || t.factory === h.makePolylineBuilder } isPolylinePen(t) { return t.factory === h.makePolylineBuilder } licenseInfo() { return null } } }, 2034: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.toolbarCSSPrefix = void 0, e.toolbarCSSPrefix = "toolbar-" }, 3280: function (t, e, o) { "use strict"; var n = this && this.__createBinding || (Object.create ? function (t, e, o, n) { void 0 === n && (n = o); var i = Object.getOwnPropertyDescriptor(e, o); i && !("get" in i ? !e.__esModule : i.writable || i.configurable) || (i = { enumerable: !0, get: function () { return e[o] } }), Object.defineProperty(t, n, i) } : function (t, e, o, n) { void 0 === n && (n = o), t[n] = e[o] }), i = this && this.__exportStar || function (t, e) { for (var o in t) "default" === o || Object.prototype.hasOwnProperty.call(e, o) || n(e, t, o) }, r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.makeEdgeToolbar = e.makeDropdownToolbar = e.IconProvider = void 0, i(o(6006), e), i(o(9943), e); var s = o(6975); Object.defineProperty(e, "IconProvider", { enumerable: !0, get: function () { return r(s).default } }); var a = o(4659); Object.defineProperty(e, "makeDropdownToolbar", { enumerable: !0, get: function () { return a.makeDropdownToolbar } }); var l = o(1083); Object.defineProperty(e, "makeEdgeToolbar", { enumerable: !0, get: function () { return l.makeEdgeToolbar } }) }, 7806: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.defaultToolbarLocalization = void 0; const n = o(4816); e.defaultToolbarLocalization = { ...n.defaultToolbarUtilsLocalization, pen: "Pen", eraser: "Eraser", select: "Select", handTool: "Pan", zoom: "Zoom", image: "Image", reformatSelection: "Format selection", inputAltText: "Alt text", decreaseImageSize: "Decrease size", resetImage: "Reset", chooseFile: "Choose file", dragAndDropHereOrBrowse: "Drag and drop here\nor\n{{browse}}", submit: "Submit", addAll: "Add all", cancel: "Cancel", resetView: "Reset view", thicknessLabel: "Thickness", colorLabel: "Color", fontLabel: "Font", textSize: "Size", resizeImageToSelection: "Resize image to selection", deleteSelection: "Delete selection", duplicateSelection: "Duplicate selection", exit: "Exit", save: "Save", undo: "Undo", redo: "Redo", fullStrokeEraser: "Full stroke eraser", selectPenType: "Pen type", selectShape: "Shape", pickColorFromScreen: "Pick color from screen", clickToPickColorAnnouncement: "Click on the screen to pick a color", colorSelectionCanceledAnnouncement: "Color selection canceled", selectionToolKeyboardShortcuts: "Selection tool: Use arrow keys to move selected items, lowercase/uppercase ‘i’ and ‘o’ to resize.", documentProperties: "Page", backgroundColor: "Background color", imageWidthOption: "Width", imageHeightOption: "Height", useGridOption: "Grid", enableAutoresizeOption: "Auto-resize", toggleOverflow: "More", about: "About", inputStabilization: "Stabilization", strokeAutocorrect: "Autocorrect", touchPanning: "Scroll with touch", roundedTipPen: "Round", roundedTipPen2: "Polyline", flatTipPen: "Flat", arrowPen: "Arrow", linePen: "Line", outlinedRectanglePen: "Outlined rectangle", filledRectanglePen: "Filled rectangle", outlinedCirclePen: "Outlined circle", lockRotation: "Lock rotation", paste: "Paste", errorImageHasZeroSize: "Error: Image has zero size", describeTheImage: "Image description", fileInput__loading: "Loading...", fileInput__andNMoreFiles: t => `(...${t} more)`, penDropdown__baseHelpText: "This tool draws shapes or freehand lines.", penDropdown__colorHelpText: "Changes the pen's color", penDropdown__thicknessHelpText: "Changes the thickness of strokes drawn by the pen.", penDropdown__penTypeHelpText: "Changes the pen style.\n\nEither a “pen” style or “shape” can be chosen. Choosing a “pen” style draws freehand lines. Choosing a “shape” draws shapes.", penDropdown__autocorrectHelpText: "Converts approximate freehand lines and rectangles to perfect ones.\n\nThe pen must be held stationary at the end of a stroke to trigger a correction.", penDropdown__stabilizationHelpText: "Draws smoother strokes.\n\nThis also adds a short delay between the mouse/stylus and the stroke.", handDropdown__baseHelpText: "This tool is responsible for scrolling, rotating, and zooming the editor.", handDropdown__zoomInHelpText: "Zooms in.", handDropdown__zoomOutHelpText: "Zooms out.", handDropdown__resetViewHelpText: "Resets the zoom level to 100% and resets scroll.", handDropdown__zoomDisplayHelpText: "Shows the current zoom level. 100% shows the image at its actual size.", handDropdown__touchPanningHelpText: "When enabled, touchscreen gestures move the image rather than select or draw.", handDropdown__lockRotationHelpText: "When enabled, prevents touch gestures from rotating the screen.", eraserDropdown__baseHelpText: "This tool removes strokes, images, and text under the cursor.", eraserDropdown__thicknessHelpText: "Changes the size of the eraser.", eraserDropdown__fullStrokeEraserHelpText: "When in full-stroke mode, entire shapes are erased.\n\nWhen not in full-stroke mode, shapes can be partially erased.", selectionDropdown__baseHelpText: "Selects content and manipulates the selection", selectionDropdown__resizeToHelpText: "Crops the drawing to the size of what's currently selected.\n\nIf auto-resize is enabled, it will be disabled.", selectionDropdown__deleteHelpText: "Erases selected items.", selectionDropdown__duplicateHelpText: "Makes a copy of selected items.", selectionDropdown__changeColorHelpText: "Changes the color of selected items.", pageDropdown__baseHelpText: "Controls the drawing canvas' background color, pattern, and size.", pageDropdown__backgroundColorHelpText: "Changes the background color of the drawing canvas.", pageDropdown__gridCheckboxHelpText: "Enables/disables a background grid pattern.", pageDropdown__autoresizeCheckboxHelpText: "When checked, the page grows to fit the drawing.\n\nWhen unchecked, the page is visible and its size can be set manually.", pageDropdown__aboutButtonHelpText: "Shows version, debug, and other information.", colorPickerPipetteHelpText: "Picks a color from the screen.", colorPickerToggleHelpText: "Opens/closes the color picker.", closeSidebar: t => `Close sidebar for ${t}`, dropdownShown: t => `Menu for ${t} shown`, dropdownHidden: t => `Menu for ${t} hidden`, zoomLevel: t => `Zoom: ${t}%`, colorChangedAnnouncement: t => `Color changed to ${t}`, imageSize: (t, e) => `Image size: ${t} ${e}`, imageLoadError: t => `Error loading image: ${t}` } }, 2722: function (t, e, o) { "use strict"; var n, i = this && this.__classPrivateFieldGet || function (t, e, o, n) { if ("a" === o && !n) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === o ? n : "a" === o ? n.call(t) : n ? n.value : e.get(t) }, r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const s = o(5379), a = r(o(1576)), l = o(7988), c = r(o(4339)), d = r(o(3676)); n = new WeakMap, e.default = class { constructor(t, e) { this.createOverlay = t, this.context = e, n.set(this, []) } showHelpOverlay() { const t = document.createElement("dialog"); t.setAttribute("autofocus", "true"), t.classList.add("toolbar-help-overlay"); const e = () => { t.classList.add("-hiding"), setTimeout((() => t.close()), 250) }; let o = 0; const r = () => { performance.now() - o < 100 || e() }, h = (() => { const t = l.MutableReactiveValue.fromInitialValue(0), e = document.createElement("div"); e.classList.add("navigation-content"); const o = ((t, e, o, n) => { const i = document.createElement("div"); i.classList.add("help-page-container"); const r = document.createElement("div"); r.classList.add("label", "-space-above"), r.setAttribute("aria-live", "polite"); let a = 0, l = t[0] ?? null, h = []; i.addEventListener("click", (t => { t.target === i && o() })); const u = () => { if (!l) return s.Rect2.empty; const t = l.targetElements.map((t => s.Rect2.of(t.getBoundingClientRect()))); return s.Rect2.union(...t) }, p = () => { const t = u(); for (let o = 0; o < h.length; o++)for (const { container: n, bbox: i } of h[o]) if (o === a) n.classList.add("-active"), n.classList.remove("-clickable", "-background"), n.onclick = () => { }; else { i.containsRect(t) ? (n.classList.add("-background"), n.classList.remove("-active", "-clickable")) : (n.classList.add("-clickable"), n.classList.remove("-active", "-background")); const r = o; n.onclick = () => { e(r) } } }, f = () => { const t = s.Rect2.of(r.getBoundingClientRect()), e = u(); if (t.intersects(e)) { const o = s.Rect2.of(i.getBoundingClientRect()), n = e.topLeft.y, a = o.bottomLeft.y - e.bottomLeft.y; n > a && n > t.height / 3 && (r.classList.remove("-small-space-above", "-large-space-above"), r.classList.add("-large-space-below")), n < a && a > t.height && (r.classList.add("-large-space-above"), r.classList.remove("-large-space-below")) } }, m = () => { i.replaceChildren(), r.classList.remove("-large-space-above"), r.classList.add("-small-space-above", "-large-space-below"), i.appendChild(r); const e = new s.Rect2(0, 0, window.innerWidth, window.innerHeight); h = []; for (let o = 0; o < t.length; o++) { const n = t[o], r = []; for (const t of n.targetElements) { let o = s.Rect2.of(t.getBoundingClientRect()); if (!e.intersects(o)) { const t = e.bottomLeft.lerp(e.bottomRight, .5), n = o.bottomLeft.lerp(o.bottomRight, .5), i = t.minus(n); o = o.translatedBy(i) } const n = (0, c.default)(t); for (const t of n.querySelectorAll("input")) t.disabled = !0; n.style.margin = "0"; const a = document.createElement("div"); a.classList.add("cloned-element-container"), a.style.position = "absolute", a.style.left = `${o.topLeft.x}px`, a.style.top = `${o.topLeft.y}px`, a.replaceChildren(n), (0, d.default)(a, { timeout: 0 }), r.push({ container: a, bbox: o }), i.appendChild(a) } h.push(r) } p() }, g = () => { const t = document.createElement("div"); t.innerText = l?.helpText ?? "", t.classList.add("current-item-help"); const e = document.createElement("div"); e.innerText = n.localization.helpScreenNavigationHelp, e.classList.add("navigation-help"), r.replaceChildren(t, ...0 === a ? [e] : []), p() }; return g(), { addToParent: t => { m(), t.appendChild(i), f() }, refresh: () => { m(), f() }, setPageIndex: e => { a = e, l = t[e], g() } } })(i(this, n, "f"), (e => t.set(e)), r, this.context); o.addToParent(e); t.onUpdateAndNow((t => { t >= i(this, n, "f").length || t < 0 ? (console.warn("Help screen: Navigated to out-of-bounds page", t), e.style.display = "none") : (e.style.display = "", o.setPageIndex(t)) })); const a = { content: e, currentPage: t, toNext: () => { a.hasNext() && t.set(t.get() + 1) }, toPrevious: () => { a.hasPrevious() && t.set(t.get() - 1) }, hasNext: () => t.get() + 1 < i(this, n, "f").length, hasPrevious: () => t.get() > 0, refreshCurrent: () => { o.refresh() } }; return a })(), u = (t => { const e = document.createElement("div"); e.classList.add("navigation-buttons"); const o = document.createElement("button"), n = document.createElement("button"); o.innerText = this.context.localization.next, n.innerText = this.context.localization.previous, o.classList.add("next"), n.classList.add("previous"); return t.currentPage.onUpdateAndNow((() => { e.classList.remove("-has-next", "-has-previous"), t.hasNext() ? (e.classList.add("-has-next"), o.disabled = !1) : (e.classList.remove("-has-next"), o.disabled = !0), t.hasPrevious() ? (e.classList.add("-has-previous"), n.disabled = !1) : (e.classList.remove("-has-previous"), n.disabled = !0) })), o.onclick = () => { t.toNext() }, n.onclick = () => { t.toPrevious() }, e.replaceChildren(n, o), e })(h); t.replaceChildren((() => { const t = document.createElement("button"); t.classList.add("close-button"), t.appendChild(this.context.icons.makeCloseIcon()); const o = this.context.localization.close; return t.setAttribute("aria-label", o), t.setAttribute("title", o), t.onclick = () => { e() }, t })(), u, h.content), this.createOverlay(t), t.showModal(); const p = 30, f = e => { e > 0 && !h.hasPrevious() && (e = 0), e < 0 && !h.hasNext() && (e = 0), (e > p || e < -30) && (e = p * Math.sign(e)), t.style.transform = `translate(${e}px, 0px)`, e >= p ? u.classList.add("-highlight-previous") : u.classList.remove("-highlight-previous"), e <= -30 ? u.classList.add("-highlight-next") : u.classList.remove("-highlight-next") }, m = (0, a.default)(t, { draggableChildElements: [h.content], onDrag: (e, o, n) => { t.classList.add("-dragging"), f(n.x) }, onDragEnd: e => { if (t.classList.remove("-dragging"), f(0), !e.roughlyClick) { const t = e.displacement.x; t > p ? h.toPrevious() : t < -30 && h.toNext(), o = e.endTimestamp } } }); let g; window.ResizeObserver && (g = new ResizeObserver((() => { h.refreshCurrent() })), g.observe(t)); const b = () => { requestAnimationFrame((() => h.refreshCurrent())) }, y = window.matchMedia?.("(prefers-color-scheme: dark)"); y?.addEventListener("change", b); const v = [h.content, u, t]; t.onclick = t => { v.includes(t.target) && r() }, t.onkeyup = t => { "Escape" === t.code ? (e(), t.preventDefault()) : "ArrowRight" === t.code ? (h.toNext(), t.preventDefault()) : "ArrowLeft" === t.code && (h.toPrevious(), t.preventDefault()) }, t.addEventListener("close", (() => { this.context.announceForAccessibility(this.context.localization.helpHidden), y?.removeEventListener("change", b), m.removeListeners(), g?.disconnect(), t.remove() })) } registerTextHelpForElement(t, e) { this.registerTextHelpForElements([t], e) } registerTextHelpForElements(t, e) { i(this, n, "f").push({ targetElements: [...t], helpText: e }) } hasHelpText() { return i(this, n, "f").length > 0 } createToggleButton() { const t = document.createElement("div"); t.classList.add("toolbar-help-overlay-button"); const e = document.createElement("button"); e.classList.add("button"); const o = this.context.icons.makeHelpIcon(); return o.classList.add("icon"), e.appendChild(o), e.setAttribute("aria-label", this.context.localization.help), e.onclick = () => { this.showHelpOverlay() }, t.appendChild(e), t } } }, 4816: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.defaultToolbarUtilsLocalization = void 0, e.defaultToolbarUtilsLocalization = { help: "Help", helpHidden: "Help hidden", next: "Next", previous: "Previous", close: "Close", helpScreenNavigationHelp: "Click on a control for more information." } }, 1576: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); const n = o(5379); e.default = (t, e) => { const o = [...e.draggableChildElements, t]; let i = 0, r = 0, s = 0, a = 0, l = !1, c = null; const d = [], h = (e, o, n) => { t.addEventListener(e, o, n), d.push((() => { t.removeEventListener(e, o) })) }, u = () => Math.hypot(i - s, r - a) < 5; let p = !1; h("pointerdown", (t => { !t.defaultPrevented && (t => { if (!t) return !1; if (o.includes(t)) return !0; const e = ["INPUT", "SELECT", "IMG"]; let n = !1, i = t.parentElement; for (; i && !e.includes(i.tagName);) { if (o.includes(i)) { n = !0; break } i = i.parentElement } return !e.includes(t.tagName) && n })(t.target) && t.isPrimary && (p = !1, i = t.clientX, r = t.clientY, s = t.clientX, a = t.clientY, c = null, l = !0) }), { passive: !0 }); const f = o => { l && (null !== c && (t.releasePointerCapture(c), c = null), e.onDragEnd({ roughlyClick: u(), endTimestamp: performance.now(), displacement: n.Vec2.of(i - s, r - a) }), l = !1, p = !1) }; return h("pointermove", (o => { if (!o.isPrimary || !l) return; if ("mouse" === o.pointerType && 0 === o.buttons) return void f(); null !== c || u() || (t.setPointerCapture(o.pointerId), c = o.pointerId); const d = o.clientX, h = o.clientY, m = d - i, g = h - r; Math.abs(d - s) <= 5 && Math.abs(h - a) <= 5 && !p || (e.onDrag(m, g, n.Vec2.of(d - s, h - a)), i = d, r = h, p = !0) })), h("pointerleave", (e => { null === c && l && e.isPrimary && (t.setPointerCapture(e.pointerId), c = e.pointerId) })), h("pointerup", f), h("pointercancel", f), { removeListeners: () => { for (const t of d) t() } } } }, 9751: function (t, e, o) { "use strict"; var n, i, r = this && this.__classPrivateFieldSet || function (t, e, o, n, i) { if ("m" === n) throw new TypeError("Private method is not writable"); if ("a" === n && !i) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof e ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === n ? i.call(t, o) : i ? i.value = o : e.set(t, o), o }, s = this && this.__classPrivateFieldGet || function (t, e, o, n) { if ("a" === o && !n) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === o ? n : "a" === o ? n.call(t) : n ? n.value : e.get(t) }, a = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const l = a(o(5068)); class c extends l.default { constructor(t, e, o, s, a, l, c = !1, d = !0) { super(t, e, l), this.makeIcon = o, this.title = s, this.clickAction = a, this.mustBeToplevel = c, n.set(this, void 0), i.set(this, void 0), r(this, n, d, "f") } setHelpText(t) { r(this, i, t, "f") } getHelpText() { return s(this, i, "f") } shouldAutoDisableInReadOnlyEditor() { return s(this, n, "f") } handleClick() { this.clickAction() } getTitle() { return this.title } createIcon() { return this.makeIcon() } fillDropdown(t) { return !1 } mustBeInToplevelMenu() { return this.mustBeToplevel } } n = new WeakMap, i = new WeakMap, e.default = c }, 550: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(5068)), r = o(2034); class s extends i.default { constructor(t, e, o, n) { super(t, o, n), this.targetTool = e, this.targetTool.enabledValue().onUpdateAndNow((t => { t ? (this.setSelected(!0), (() => { const t = [...document.querySelectorAll("*:focus")]; return t.length && t.some((t => t.classList.contains(`${r.toolbarCSSPrefix}button`))) })() && this.focus()) : (this.setSelected(!1), this.setDropdownVisible(!1)) })) } shouldAutoDisableInReadOnlyEditor() { return !this.targetTool.canReceiveInputInReadOnlyEditor() } handleClick() { this.hasDropdown ? this.targetTool.isEnabled() ? this.setDropdownVisible(!this.isDropdownVisible()) : (this.targetTool.setEnabled(!0), this.activateDropdown()) : this.targetTool.setEnabled(!this.targetTool.isEnabled()) } onKeyPress(t) { return !(!this.isSelected() || "Space" !== t.code || !this.hasDropdown) && (this.handleClick(), !0) } addTo(t) { const e = super.addTo(t); return this.setSelected(this.targetTool.isEnabled()), e } } e.default = s }, 5068: function (t, e, o) { "use strict"; var n, i, r, s, a, l, c, d = this && this.__classPrivateFieldSet || function (t, e, o, n, i) { if ("m" === n) throw new TypeError("Private method is not writable"); if ("a" === n && !i) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof e ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === n ? i.call(t, o) : i ? i.value = o : e.set(t, o), o }, h = this && this.__classPrivateFieldGet || function (t, e, o, n) { if ("a" === o && !n) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === o ? n : "a" === o ? n.call(t) : n ? n.value : e.get(t) }, u = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.ToolbarWidgetTag = void 0; const p = u(o(5716)), f = o(7394), m = o(2034), g = u(o(418)), b = u(o(3676)), y = u(o(2722)); var v; !function (t) { t.Save = "save", t.Exit = "exit", t.Undo = "undo", t.Redo = "redo" }(v || (e.ToolbarWidgetTag = v = {})); class x { constructor(t, e, o) { n.add(this), this.editor = t, this.id = e, this.dropdown = null, r.set(this, void 0), this.disabled = !1, s.set(this, !1), a.set(this, []), this.subWidgets = {}, this.toplevel = !0, l.set(this, null), this.localizationTable = o ?? t.localization; const i = new g.default((t => this.editor.announceForAccessibility(t)), this.localizationTable); i.connectToEditorNotifier(t.notifier), this.layoutManager = i, this.icon = null, this.container = document.createElement("div"), this.container.classList.add(`${m.toolbarCSSPrefix}toolContainer`, `${m.toolbarCSSPrefix}toolButtonContainer`, `${m.toolbarCSSPrefix}internalWidgetId--${e.replace(/[^a-zA-Z0-9_]/g, "-")}`), this.dropdownContent = document.createElement("div"), d(this, r, !1, "f"), this.button = document.createElement("div"), this.button.classList.add(`${m.toolbarCSSPrefix}button`), this.label = document.createElement("label"), this.button.setAttribute("role", "button"), this.button.tabIndex = 0, this.button.oncontextmenu = t => { t.preventDefault() }, (0, b.default)(this.button) } shouldAutoDisableInReadOnlyEditor() { return !0 } getId() { return this.id } setTags(t) { const e = t => `toolwidget-tag--${t}`; for (const t of h(this, a, "f")) this.container.classList.remove(e(t)); d(this, a, [...t], "f"); for (const t of h(this, a, "f")) this.container.classList.add(e(t)) } getTags() { return [...h(this, a, "f")] } getUniqueIdIn(t) { let e = this.getId(), o = 0; for (; e in t && t[e] !== this;)e = this.getId() + "-" + o.toString(), o++; return e } fillDropdown(t, e) { if (0 === Object.keys(this.subWidgets).length) return !1; for (const o in this.subWidgets) { const n = this.subWidgets[o], i = n.addTo(t); n.setIsToplevel(!1); const r = n.getHelpText(); r && e?.registerTextHelpForElement(i, r) } return !0 } getHelpText() { } setupActionBtnClickListener(t) { return this.setUpButtonEventListeners(t) } setUpButtonEventListeners(t) { const e = { Enter: !0, " ": !0 }; t.onkeydown = t => { let o = !1; if (t.key in e && (this.disabled || (this.handleClick(), o = !0)), !o) { const e = (0, f.keyPressEventFromHTMLEvent)(t); o = this.editor.toolController.dispatchInputEvent(e) } o && t.preventDefault() }, t.onkeyup = t => { if (t.key in e) return; const o = (0, f.keyUpEventFromHTMLEvent)(t); this.editor.toolController.dispatchInputEvent(o) && t.preventDefault() }, t.onclick = () => { this.disabled || this.handleClick() }, t.ondblclick = t => { t.preventDefault() } } onKeyPress(t) { return !1 } get hasDropdown() { return h(this, r, "f") } addSubWidget(t) { const e = t.getUniqueIdIn(this.subWidgets); this.subWidgets[e] = t } setLayoutManager(t) { t !== this.layoutManager && (this.layoutManager = t, this.container.parentElement && this.addTo(this.container.parentElement)) } addTo(t) { this.icon = null, this.updateIcon(), this.label.innerText = this.getTitle(); const e = "long-label"; this.label.innerText.length > 7 ? this.label.classList.add(e) : this.label.classList.remove(e), this.setUpButtonEventListeners(this.button), this.container.replaceChildren(), this.button.replaceChildren(this.icon, this.label), this.container.appendChild(this.button); const o = new y.default((t => this.editor.createHTMLOverlay(t)), this.editor), i = this.getHelpText(); return i && o.registerTextHelpForElement(this.dropdownContent, [this.getTitle(), i].join("\n\n")), this.dropdownContent.replaceChildren(), d(this, r, this.fillDropdown(this.dropdownContent, o), "f"), h(this, r, "f") && (this.button.classList.add("has-dropdown"), this.dropdown?.destroy(), this.dropdownIcon = this.createDropdownIcon(), this.button.appendChild(this.dropdownIcon), this.dropdown = this.layoutManager.createToolMenu({ target: this.button, getTitle: () => this.getTitle(), isToplevel: () => this.toplevel }), this.dropdown.visible.onUpdate((t => { t ? this.container.classList.add("dropdownVisible") : this.container.classList.remove("dropdownVisible"), t || this.focus() })), o.hasHelpText() && this.dropdown.appendChild(o.createToggleButton()), this.dropdown.appendChild(this.dropdownContent)), this.setDropdownVisible(!1), this.container.parentElement && this.container.remove(), h(this, n, "m", c).call(this), t.appendChild(this.container), this.container } remove() { this.container.remove(), h(this, l, "f")?.call(this) } focus() { this.button.focus() } addCSSClassToContainer(t) { this.container.classList.add(t) } removeCSSClassFromContainer(t) { this.container.classList.remove(t) } updateIcon() { let t = this.createIcon(); t ? this.container.classList.remove("no-icon") : (t = document.createElement("div"), this.container.classList.add("no-icon")), this.icon?.replaceWith(t), this.icon = t, this.icon.classList.add(`${m.toolbarCSSPrefix}icon`) } setDisabled(t) { this.disabled = t, d(this, s, !1, "f"), this.disabled ? (this.button.classList.add("disabled"), this.button.setAttribute("aria-disabled", "true")) : (this.button.classList.remove("disabled"), this.button.removeAttribute("aria-disabled")) } setSelected(t) { this.isSelected() !== t && (this.button.setAttribute("role", "switch"), t ? (this.container.classList.add("selected"), this.button.setAttribute("aria-checked", "true")) : (this.container.classList.remove("selected"), this.button.setAttribute("aria-checked", "false"))) } setDropdownVisible(t) { t ? this.dropdown?.requestShow() : this.dropdown?.requestHide() } activateDropdown() { this.dropdown?.onActivated() } mustBeInToplevelMenu() { return !1 } canBeInOverflowMenu() { return !this.mustBeInToplevelMenu() } getButtonWidth() { return this.button.clientWidth } isHidden() { return "none" === this.container.style.display } setHidden(t) { this.container.style.display = t ? "none" : "" } setIsToplevel(t) { this.toplevel = t } isDropdownVisible() { return this.dropdown?.visible?.get() ?? !1 } isSelected() { return this.container.classList.contains("selected") } createDropdownIcon() { const t = this.editor.icons.makeDropdownIcon(); return t.classList.add(`${m.toolbarCSSPrefix}showHideDropdownIcon`), t } serializeState() { const t = {}; for (const e in this.subWidgets) t[e] = this.subWidgets[e].serializeState(); return { subwidgetState: t } } deserializeFrom(t) { if (t.subwidgetState) for (const e in t.subwidgetState) e in this.subWidgets && this.subWidgets[e].deserializeFrom(t.subwidgetState[e]) } } i = x, r = new WeakMap, s = new WeakMap, a = new WeakMap, l = new WeakMap, n = new WeakSet, c = function () { h(this, l, "f")?.call(this); const t = this.editor.toolController.getMatchingTools(p.default); let e = null; if (t.length > 0 && this.onKeyPress !== i.prototype.onKeyPress) { const o = t => this.onKeyPress(t), n = t[0]; n.registerListener(o), e = () => { n.removeListener(o) } } const o = this.editor.isReadOnlyReactiveValue().onUpdateAndNow((t => { t && this.shouldAutoDisableInReadOnlyEditor() && !this.disabled ? (this.setDisabled(!0), d(this, s, !0, "f"), h(this, r, "f") && this.dropdown?.requestHide()) : !t && h(this, s, "f") && (d(this, s, !1, "f"), this.setDisabled(!1)) })); d(this, l, (() => { o.remove(), e?.(), d(this, l, null, "f") }), "f") }, e.default = x }, 7021: function (t, e, o) { "use strict"; var n, i = this && this.__createBinding || (Object.create ? function (t, e, o, n) { void 0 === n && (n = o); var i = Object.getOwnPropertyDescriptor(e, o); i && !("get" in i ? !e.__esModule : i.writable || i.configurable) || (i = { enumerable: !0, get: function () { return e[o] } }), Object.defineProperty(t, n, i) } : function (t, e, o, n) { void 0 === n && (n = o), t[n] = e[o] }), r = this && this.__setModuleDefault || (Object.create ? function (t, e) { Object.defineProperty(t, "default", { enumerable: !0, value: e }) } : function (t, e) { t.default = e }), s = this && this.__importStar || (n = function (t) { return n = Object.getOwnPropertyNames || function (t) { var e = []; for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[e.length] = o); return e }, n(t) }, function (t) { if (t && t.__esModule) return t; var e = {}; if (null != t) for (var o = n(t), s = 0; s < o.length; s++)"default" !== o[s] && i(e, t, o[s]); return r(e, t), e }), a = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const l = a(o(6188)), c = a(o(2717)), d = s(o(2115)), h = o(7), u = o(5379), p = o(2018), f = o(2034), m = a(o(9943)), g = a(o(5068)); class b extends g.default { constructor(t, e) { super(t, "document-properties-widget", e), this.updateDropdownContent = () => { }, this.dropdownUpdateQueued = !1, this.container.classList.add("dropdownShowable"), this.editor.notifier.on(p.EditorEventType.UndoRedoStackUpdated, (() => { this.queueDropdownUpdate() })), this.editor.image.notifier.on(h.EditorImageEventType.ExportViewportChanged, (() => { this.queueDropdownUpdate() })) } getTitle() { return this.localizationTable.documentProperties } createIcon() { return this.editor.icons.makeConfigureDocumentIcon() } handleClick() { this.setDropdownVisible(!this.isDropdownVisible()), this.queueDropdownUpdate() } queueDropdownUpdate() { this.dropdownUpdateQueued || (requestAnimationFrame((() => this.updateDropdown())), this.dropdownUpdateQueued = !0) } updateDropdown() { this.dropdownUpdateQueued = !1, this.isDropdownVisible() && this.updateDropdownContent() } setBackgroundColor(t) { this.editor.dispatch(this.editor.setBackgroundColor(t)) } getBackgroundColor() { return this.editor.estimateBackgroundColor() } removeBackgroundComponents() { const t = []; for (const e of this.editor.image.getBackgroundComponents()) e instanceof d.default && t.push(e); return new l.default(t) } setBackgroundType(t) { const e = this.editor.estimateBackgroundColor(), o = new d.default(t, e), n = this.editor.image.addElement(o); return (0, c.default)([this.removeBackgroundComponents(), n]) } getBackgroundType() { const t = this.editor.image.getBackgroundComponents(); for (let e = t.length - 1; e >= 0; e--) { const o = t[e]; if (o instanceof d.default) return o.getBackgroundType() } return d.BackgroundType.None } updateImportExportRectSize(t) { const e = t => (void 0 !== t && (!isFinite(t) || t <= 0) && (t = 100), t), o = e(t.width), n = e(t.height), i = this.editor.getImportExportRect(), r = new u.Rect2(i.x, i.y, o ?? i.w, n ?? i.h); this.editor.dispatch(this.editor.image.setImportExportRect(r)), this.editor.queueRerender() } getHelpText() { return this.localizationTable.pageDropdown__baseHelpText } fillDropdown(t, e) { const o = document.createElement("div"); o.classList.add(`${f.toolbarCSSPrefix}spacedList`, `${f.toolbarCSSPrefix}nonbutton-controls-main-list`, `${f.toolbarCSSPrefix}document-properties-widget`); const { backgroundColorRow: n, setBgColorInputValue: i, registerWithHelp: r } = (() => { const t = document.createElement("div"), e = document.createElement("label"); e.innerText = this.localizationTable.backgroundColor; const { input: o, container: n, setValue: i, registerWithHelpTextDisplay: r } = (0, m.default)(this.editor, (t => { t.eq(this.getBackgroundColor()) || this.setBackgroundColor(t) })); o.id = `${f.toolbarCSSPrefix}docPropertiesColorInput-${b.idCounter++}`, e.htmlFor = o.id, t.replaceChildren(e, n); return { setBgColorInputValue: i, backgroundColorRow: t, registerWithHelp: e => { e && (e?.registerTextHelpForElement(t, this.localizationTable.pageDropdown__backgroundColorHelpText), r(e)) } } })(), s = (t, e) => { const o = document.createElement("div"), n = document.createElement("label"), i = document.createElement("input"); return i.id = `${f.toolbarCSSPrefix}docPropertiesCheckbox-${b.idCounter++}`, n.htmlFor = i.id, i.type = "checkbox", n.innerText = t, i.oninput = () => { e(i.checked) }, o.replaceChildren(n, i), { container: o, checkbox: i } }, { container: a, checkbox: l } = s(this.localizationTable.useGridOption, (t => { if (this.getBackgroundType() === d.BackgroundType.Grid === t) return; let e = d.BackgroundType.SolidColor; t && (e = d.BackgroundType.Grid), this.editor.dispatch(this.setBackgroundType(e)) })), c = (t, e) => { const o = document.createElement("div"), n = document.createElement("label"), i = document.createElement("input"); return n.innerText = t, i.type = "number", i.min = "0", i.id = `${f.toolbarCSSPrefix}docPropertiesDimensionRow-${b.idCounter++}`, n.htmlFor = i.id, i.style.flexGrow = "2", i.style.width = "25px", i.oninput = () => { e(parseFloat(i.value)) }, o.classList.add("js-draw-size-input-row"), o.replaceChildren(n, i), { setValue: t => { if (document.activeElement === i && i.value.match(/^0*$/)) { const e = i.value; i.type = "text", i.value = t.toString(); const o = Math.max(1, i.value.length - e.length); i.setSelectionRange(0, o), i.type = "number" } else i.value = t.toString() }, setIsAutomaticSize: t => { i.disabled = t; const e = "size-input-row--automatic-size"; t ? o.classList.add(e) : o.classList.remove(e) }, element: o } }, h = c(this.localizationTable.imageWidthOption, (t => { this.updateImportExportRectSize({ width: t }) })), u = c(this.localizationTable.imageHeightOption, (t => { this.updateImportExportRectSize({ height: t }) })), { container: p, checkbox: g } = s(this.localizationTable.enableAutoresizeOption, (t => { const e = this.editor.image; this.editor.dispatch(e.setAutoresizeEnabled(t)) })), y = document.createElement("button"); return y.classList.add("about-button"), y.innerText = this.localizationTable.about, y.onclick = () => { this.editor.showAboutDialog() }, r(e), e?.registerTextHelpForElement(a, this.localizationTable.pageDropdown__gridCheckboxHelpText), e?.registerTextHelpForElement(p, this.localizationTable.pageDropdown__autoresizeCheckboxHelpText), e?.registerTextHelpForElement(y, this.localizationTable.pageDropdown__aboutButtonHelpText), this.updateDropdownContent = () => { i(this.getBackgroundColor()); const t = this.editor.image.getAutoresizeEnabled(), e = this.editor.getImportExportRect(); h.setValue(e.width), u.setValue(e.height), g.checked = t, h.setIsAutomaticSize(t), u.setIsAutomaticSize(t), l.checked = this.getBackgroundType() === d.BackgroundType.Grid }, this.updateDropdownContent(), o.replaceChildren(n, a, h.element, u.element, p, y), t.replaceChildren(o), !0 } } b.idCounter = 0, e.default = b }, 1295: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = o(1011), r = o(2018), s = o(2034), a = n(o(550)), l = n(o(2059)); class c extends a.default { constructor(t, e, o) { super(t, e, "eraser-tool-widget", o), this.tool = e, this.updateInputs = () => { }, this.editor.notifier.on(r.EditorEventType.ToolUpdated, (t => { t.kind === r.EditorEventType.ToolUpdated && t.tool === this.tool && (this.updateInputs(), this.updateIcon()) })) } getHelpText() { return this.localizationTable.eraserDropdown__baseHelpText } getTitle() { return this.localizationTable.eraser } makeIconForType(t) { return this.editor.icons.makeEraserIcon(this.tool.getThickness(), t) } createIcon() { return this.makeIconForType(this.tool.getModeValue().get()) } makeEraserTypeSelector(t) { const e = document.createElement("div"), o = document.createElement("label"), n = document.createElement("input"); n.id = `${s.toolbarCSSPrefix}eraserToolWidget-${c.idCounter++}`, o.htmlFor = n.id, o.innerText = this.localizationTable.fullStrokeEraser, n.type = "checkbox", n.oninput = () => { this.tool.getModeValue().set(n.checked ? i.EraserMode.FullStroke : i.EraserMode.PartialStroke) }; return e.replaceChildren(o, n), t?.registerTextHelpForElement(e, this.localizationTable.eraserDropdown__fullStrokeEraserHelpText), { addTo: t => { t.appendChild(e) }, updateValue: () => { n.checked = this.tool.getModeValue().get() === i.EraserMode.FullStroke } } } fillDropdown(t, e) { const o = document.createElement("div"); o.classList.add(`${s.toolbarCSSPrefix}spacedList`, `${s.toolbarCSSPrefix}nonbutton-controls-main-list`); const n = (0, l.default)(this.editor, (t => { this.tool.setThickness(t) })); n.setBounds(10, 55), e?.registerTextHelpForElement(n.container, this.localizationTable.eraserDropdown__thicknessHelpText); const i = this.makeEraserTypeSelector(e); return this.updateInputs = () => { n.setValue(this.tool.getThickness()), i.updateValue() }, this.updateInputs(), o.replaceChildren(n.container), i.addTo(o), t.replaceChildren(o), !0 } serializeState() { return { ...super.serializeState(), thickness: this.tool.getThickness(), mode: this.tool.getModeValue().get() } } deserializeFrom(t) { if (super.deserializeFrom(t), t.thickness) { const e = parseFloat(t.thickness); if ("number" != typeof e || !isFinite(e)) throw new Error(`Deserializing property ${e} is not a number or is not finite.`); this.tool.setThickness(e) } if (t.mode) { const e = t.mode; Object.values(i.EraserMode).includes(e) && this.tool.getModeValue().set(e) } } } c.idCounter = 0, e.default = c }, 7855: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(9751)), r = o(5068), s = o(9376); class a extends i.default { constructor(t, e, o, n = {}) { super(t, "exit-button", (() => n.icon ?? t.icons.makeCloseIcon()), n.label ?? e.exit, o), this.setTags([r.ToolbarWidgetTag.Exit]) } shouldAutoDisableInReadOnlyEditor() { return !1 } onKeyPress(t) { return this.editor.shortcuts.matchesShortcut(s.exitKeyboardShortcut, t) ? (this.clickAction(), !0) : super.onKeyPress(t) } mustBeInToplevelMenu() { return !0 } } e.default = a }, 1210: function (t, e, o) { "use strict"; var n, i = this && this.__createBinding || (Object.create ? function (t, e, o, n) { void 0 === n && (n = o); var i = Object.getOwnPropertyDescriptor(e, o); i && !("get" in i ? !e.__esModule : i.writable || i.configurable) || (i = { enumerable: !0, get: function () { return e[o] } }), Object.defineProperty(t, n, i) } : function (t, e, o, n) { void 0 === n && (n = o), t[n] = e[o] }), r = this && this.__setModuleDefault || (Object.create ? function (t, e) { Object.defineProperty(t, "default", { enumerable: !0, value: e }) } : function (t, e) { t.default = e }), s = this && this.__importStar || (n = function (t) { return n = Object.getOwnPropertyNames || function (t) { var e = []; for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[e.length] = o); return e }, n(t) }, function (t) { if (t && t.__esModule) return t; var e = {}; if (null != t) for (var o = n(t), s = 0; s < o.length; s++)"default" !== o[s] && i(e, t, o[s]); return r(e, t), e }), a = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const l = o(5379), c = s(o(7955)), d = o(2018), h = a(o(4093)), u = o(2034), p = a(o(550)), f = a(o(5068)), m = a(o(5007)); class g extends f.default { constructor(t, e, o, n, i, r, s) { super(t, `pan-mode-${o}`, s), this.tool = e, this.flag = o, this.makeIcon = n, this.title = i, this.helpText = r, t.notifier.on(d.EditorEventType.ToolUpdated, (t => { if (t.kind === d.EditorEventType.ToolUpdated && t.tool === e) { const t = !!(e.getMode() & c.PanZoomMode.SinglePointerGestures); this.setSelected(!!(e.getMode() & o) || t), this.setDisabled(t && o !== c.PanZoomMode.SinglePointerGestures) } })), this.setSelected(!1) } shouldAutoDisableInReadOnlyEditor() { return !1 } setModeFlag(t) { this.tool.setModeEnabled(this.flag, t) } handleClick() { this.setModeFlag(!this.isSelected()) } getTitle() { return this.title } createIcon() { return this.makeIcon() } fillDropdown(t) { return !1 } getHelpText() { return this.helpText } } class b extends p.default { constructor(t, e, o) { const n = t.toolController.getPrimaryTools().includes(e), i = (n ? e : b.getPrimaryHandTool(t.toolController)) ?? e; super(t, i, "hand-tool-widget", o), this.overridePanZoomTool = (n ? b.getOverrideHandTool(t.toolController) : e) ?? e, this.allowTogglingBaseTool = null !== i, this.allowTogglingBaseTool || this.container.classList.add("dropdownShowable"); const r = new g(t, this.overridePanZoomTool, c.PanZoomMode.OneFingerTouchGestures, (() => this.editor.icons.makeTouchPanningIcon()), o.touchPanning, o.handDropdown__touchPanningHelpText, o), s = new g(t, this.overridePanZoomTool, c.PanZoomMode.RotationLocked, (() => this.editor.icons.makeRotationLockIcon()), o.lockRotation, o.handDropdown__lockRotationHelpText, o); this.addSubWidget(r), this.addSubWidget(s) } static getPrimaryHandTool(t) { return t.getPrimaryTools().filter((t => t instanceof c.default))[0] } static getOverrideHandTool(t) { return t.getMatchingTools(c.default)[0] } shouldAutoDisableInReadOnlyEditor() { return !1 } getTitle() { return this.localizationTable.handTool } createIcon() { return this.editor.icons.makeHandToolIcon() } handleClick() { this.allowTogglingBaseTool ? super.handleClick() : this.setDropdownVisible(!this.isDropdownVisible()) } getHelpText() { return this.localizationTable.handDropdown__baseHelpText } fillDropdown(t, e) { super.fillDropdown(t, e); const o = document.createElement("div"); o.classList.add(`${u.toolbarCSSPrefix}nonbutton-controls-main-list`), (0, m.default)().addTo(o); const n = ((t, e, o) => { const n = document.createElement("div"), i = document.createElement("button"), r = document.createElement("button"), s = document.createElement("button"), a = document.createElement("span"); let c; i.innerText = "+", r.innerText = "-", s.innerText = t.resetView, n.replaceChildren(a, i, r, s), n.classList.add(`${u.toolbarCSSPrefix}zoomLevelEditor`), a.classList.add("zoomDisplay"); const p = () => { let o = 100 * e.viewport.getScaleFactor(); o = o > .1 ? Math.round(10 * o) / 10 : Math.round(1e3 * o) / 1e3, o !== c && (a.innerText = t.zoomLevel(o), c = o) }; p(), e.notifier.on(d.EditorEventType.ViewportChanged, (t => { t.kind === d.EditorEventType.ViewportChanged && (p(), s.disabled = t.newTransform.eq(l.Mat33.identity)) })); const f = t => { const o = e.viewport.visibleRect.center, n = l.Mat33.scaling2D(t, o); e.dispatch(h.default.transformBy(n), !1) }; return i.onclick = () => { f(5 / 4) }, r.onclick = () => { f(.8) }, s.onclick = () => { e.dispatch(h.default.transformBy(e.viewport.canvasToScreenTransform.inverse()), !1) }, o?.registerTextHelpForElement(i, t.handDropdown__zoomInHelpText), o?.registerTextHelpForElement(r, t.handDropdown__zoomOutHelpText), o?.registerTextHelpForElement(s, t.handDropdown__resetViewHelpText), o?.registerTextHelpForElement(a, t.handDropdown__zoomDisplayHelpText), n })(this.localizationTable, this.editor, e); return o.appendChild(n), t.appendChild(o), !0 } setSelected(t) { this.allowTogglingBaseTool && super.setSelected(t) } serializeState() { const t = this.overridePanZoomTool.getMode(); return { ...super.serializeState(), touchPanning: t & c.PanZoomMode.OneFingerTouchGestures, rotationLocked: t & c.PanZoomMode.RotationLocked } } deserializeFrom(t) { void 0 !== t.touchPanning && this.overridePanZoomTool.setModeEnabled(c.PanZoomMode.OneFingerTouchGestures, t.touchPanning), void 0 !== t.rotationLocked && this.overridePanZoomTool.setModeEnabled(c.PanZoomMode.RotationLocked, t.rotationLocked), super.deserializeFrom(t) } } e.default = b }, 2242: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.ImageWrapper = void 0; class o { constructor(t, e, o) { this.imageBase64Url = t, this.preview = e, this.onUrlUpdate = o, this.originalSrc = t, e.src = t } updateImageData(t) { this.preview.src = t, this.imageBase64Url = t, this.onUrlUpdate() } decreaseSize(t = 3 / 4) { const e = document.createElement("canvas"); e.width = this.preview.naturalWidth * t, e.height = this.preview.naturalHeight * t; const o = e.getContext("2d"); o?.drawImage(this.preview, 0, 0, e.width, e.height); const n = this.originalSrc?.startsWith("data:image/jpeg;") ? "image/jpeg" : "image/png"; this.updateImageData(e.toDataURL(n)) } reset() { this.updateImageData(this.originalSrc) } isChanged() { return this.imageBase64Url !== this.originalSrc } isLarge() { return this.getBase64Url().length > 125829.12 } getBase64Url() { return this.imageBase64Url } getAltText() { return this.altText } setAltText(t) { this.altText = t, this.preview.alt = t } static fromSrcAndPreview(t, e, n) { return new o(t, e, n) } static fromRenderable(t, e) { const n = new Image; n.src = t.base64Url; const i = new o(t.base64Url, n, e), r = t.label ?? t.image.getAttribute("alt"); return r && i.setAltText(r), { wrapper: i, preview: n } } } e.ImageWrapper = o }, 1294: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(4686)), r = n(o(6188)), s = n(o(7)), a = n(o(2717)), l = n(o(1172)), c = o(5379), d = n(o(5068)), h = o(2018), u = o(2034), p = n(o(3634)), f = o(7988), m = n(o(42)), g = o(2242), b = n(o(1265)), y = n(o(7951)); class v extends d.default { constructor(t, e) { e ??= t.localization, super(t, "insert-image-widget", e), this.container.classList.add("dropdownShowable"), t.notifier.on(h.EditorEventType.SelectionUpdated, (t => { t.kind === h.EditorEventType.SelectionUpdated && this.isDropdownVisible() && this.updateInputs() })), this.images = f.MutableReactiveValue.fromInitialValue([]), this.images.onUpdateAndNow((() => { this.onImageDataUpdate() })) } getTitle() { return this.localizationTable.image } createIcon() { return this.editor.icons.makeInsertImageIcon() } setDropdownVisible(t) { super.setDropdownVisible(t), this.isDropdownVisible() ? this.updateInputs() : this.selectedFiles?.set([]) } handleClick() { this.setDropdownVisible(!this.isDropdownVisible()) } fillDropdown(t) { const e = document.createElement("div"); e.classList.add("insert-image-widget-dropdown-content", `${u.toolbarCSSPrefix}spacedList`, `${u.toolbarCSSPrefix}nonbutton-controls-main-list`); const { container: o, selectedFiles: n } = (0, p.default)(this.localizationTable.chooseFile, this.editor, { accepts: "image/*", allowMultiSelect: !0, customPickerAction: this.editor.getCurrentSettings().image?.showImagePicker }), i = document.createElement("div"); this.imagesPreview = (0, b.default)(this.images), this.statusView = document.createElement("div"); const r = document.createElement("div"); r.classList.add("action-button-row"), this.statusView.classList.add("insert-image-image-status-view"), this.submitButton = document.createElement("button"), this.selectedFiles = n, this.imageAltTextInput = document.createElement("input"); const s = document.createElement("label"), a = "insert-image-alt-text-input-" + v.nextInputId++; return this.imageAltTextInput.setAttribute("id", a), s.htmlFor = a, s.innerText = this.localizationTable.inputAltText, this.imageAltTextInput.type = "text", this.imageAltTextInput.placeholder = this.localizationTable.describeTheImage, this.statusView.setAttribute("aria-live", "polite"), this.submitButton.innerText = this.localizationTable.submit, this.imagesPreview.visibleItem.onUpdateAndNow((() => this.onImageDataUpdate())), this.imageAltTextInput.oninput = () => { const t = this.imagesPreview.visibleItem.get(); t && (t.setAltText(this.imageAltTextInput.value), this.submitButton.style.display = "") }, this.selectedFiles.onUpdateAndNow((async t => { if (0 === t.length) return void this.images.set([]); const e = (await Promise.all(t.map((async t => { let e; try { e = await (0, y.default)(t) } catch (t) { console.error("Image load error", t); const e = this.localizationTable.imageLoadError(t); return this.statusView.innerText = e, [] } return e.map((t => { const { wrapper: e, preview: o } = g.ImageWrapper.fromRenderable(t, (() => this.onImageDataUpdate())); return { data: e, element: o } })) })))).flat(); this.images.set(e) })), i.replaceChildren(s, this.imageAltTextInput), r.replaceChildren(this.submitButton), e.replaceChildren(o, i, this.imagesPreview.container, this.statusView, r), t.replaceChildren(e), !0 } onImageDataUpdate() { if (!this.imagesPreview) return; const t = this.imagesPreview.visibleItem.get(), e = t?.getBase64Url(); this.imageAltTextInput.value = t?.getAltText() ?? "", e ? (this.submitButton.disabled = !1, this.submitButton.style.display = "", this.updateImageSizeDisplay()) : (this.submitButton.disabled = !0, this.submitButton.style.display = "none", this.statusView.innerText = "", this.submitButton.disabled = !0), this.images.get().length <= 1 ? this.submitButton.innerText = this.localizationTable.submit : this.submitButton.innerText = this.localizationTable.addAll } hideDialog() { this.setDropdownVisible(!1) } updateImageSizeDisplay() { const t = this.imagesPreview.visibleItem.get(), e = t?.getBase64Url() ?? "", { size: o, units: n } = (0, m.default)(e.length), i = document.createElement("span"); i.innerText = this.localizationTable.imageSize(Math.round(o), n); const r = document.createElement("button"); r.innerText = this.localizationTable.decreaseImageSize, r.onclick = () => { t?.decreaseSize() }; const s = document.createElement("button"); if (s.innerText = this.localizationTable.resetImage, s.onclick = () => { t?.reset() }, this.statusView.replaceChildren(i), t?.isLarge()) this.statusView.appendChild(r); else if (t?.isChanged()) this.statusView.appendChild(s); else { this.images.get().some((t => t.data?.isChanged() || t.data?.isLarge())) && (r.disabled = !0, this.statusView.appendChild(r)) } } updateInputs() { (() => { this.selectedFiles?.set([]), this.imageAltTextInput.value = "", this.submitButton.disabled = !0, this.statusView.innerText = "", this.submitButton.style.display = "" })(); const t = this.editor.toolController.getMatchingTools(l.default), e = t.map((t => t.getSelectedObjects())).flat(); let o = null; if (1 === e.length && e[0] instanceof i.default) { o = e[0]; const t = new Image, n = g.ImageWrapper.fromSrcAndPreview(o.getURL(), t, (() => this.onImageDataUpdate())); n.setAltText(o.getAltText() ?? ""), this.images.set([{ data: n, element: t }]) } else e.length > 0 && t.forEach((t => t.clearSelection())); this.submitButton.style.display = "none", this.submitButton.onclick = async () => { const e = []; let n = c.Mat33.identity, l = null; for (const { data: t } of this.images.get()) { if (!t) continue; const o = new Image; o.src = t.getBase64Url(); const r = t.getAltText(); let s; r && o.setAttribute("alt", r); try { s = await i.default.fromImage(o, n) } catch (t) { return console.error("Error loading image", t), void (this.statusView.innerText = this.localizationTable.imageLoadError(t)) } const a = s.getBBox(); if (0 === a.area) return void (this.statusView.innerText = this.localizationTable.errorImageHasZeroSize); e.push(s), l ??= a, l.union(a); const d = c.Vec2.of(0, a.height); n = n.rightMul(c.Mat33.translation(d)) } if (e.length) { if (!l) throw new Error("Logic error: Full bounding box must be calculated when components are to be added."); if (this.hideDialog(), o) { const n = new r.default([o]), i = o.getTransformation(), d = o.getBBox().width || 1, h = l.transformedBoundingBox(i).width || 1, u = c.Mat33.scaling2D(d / h), p = []; for (const t of e) p.push(s.default.addElement(t), t.transformBy(i.rightMul(u)), t.setZIndex(o.getZIndex())); this.editor.dispatch((0, a.default)([...p, n])), t[0]?.setSelection(e) } else await this.editor.addAndCenterComponents(e) } } } } v.nextInputId = 0, e.default = v }, 7951: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(8733)), r = o(5379); e.default = async t => { const e = [], o = new Image, n = await (0, i.default)(t); return n && e.push({ image: o, base64Url: n, transform: r.Mat33.identity }), e } }, 816: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(5068)); class r extends i.default { constructor(t, e) { super(t, "overflow-widget", e), this.overflowChildren = [], this.container.classList.add("toolbar-overflow-widget"), this.container.classList.add("dropdownShowable"), this.overflowContainer ??= document.createElement("div") } shouldAutoDisableInReadOnlyEditor() { return !1 } getTitle() { return this.localizationTable.toggleOverflow } createIcon() { return this.editor.icons.makeOverflowIcon() } handleClick() { this.setDropdownVisible(!this.isDropdownVisible()) } fillDropdown(t) { return this.overflowContainer ??= document.createElement("div"), this.overflowContainer.parentElement && this.overflowContainer.remove(), this.overflowContainer.classList.add("toolbar-overflow-widget-overflow-list"), t.appendChild(this.overflowContainer), !0 } clearChildren() { this.overflowContainer.replaceChildren(), this.container.classList.remove("horizontal"); const t = this.overflowChildren; return this.overflowChildren = [], t } getChildWidgets() { return [...this.overflowChildren] } hasAsChild(t) { for (const e of this.overflowChildren) if (t === e) return !0; return !1 } addToOverflow(t) { this.overflowChildren.push(t), t.addTo(this.overflowContainer), t.setIsToplevel(!1), this.overflowChildren.length > 2 && this.container.classList.add("horizontal") } canBeInOverflowMenu() { return !1 } } e.default = r }, 9108: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = o(8145), r = o(9177), s = o(14), a = o(9616), l = o(117), c = o(22), d = o(2018), h = n(o(9943)), u = n(o(550)), p = o(5379), f = o(9376), m = o(2034), g = n(o(2059)), b = n(o(3759)), y = o(1342); class v extends u.default { constructor(t, e, o) { super(t, e, "pen", o), this.tool = e, this.updateInputs = () => { }, this.shapelikeIDs = ["pressure-sensitive-pen", "freehand-pen"]; const n = t.getCurrentSettings().pens?.additionalPenTypes ?? [], h = t.getCurrentSettings().pens?.filterPenTypes ?? (() => !0); this.penTypes = [{ name: this.localizationTable.flatTipPen, id: "pressure-sensitive-pen", factory: s.makePressureSensitiveFreehandLineBuilder }, { name: this.localizationTable.roundedTipPen, id: "freehand-pen", factory: r.makeFreehandLineBuilder }, { name: this.localizationTable.roundedTipPen2, id: "polyline-pen", factory: y.makePolylineBuilder }, ...n.filter((t => !t.isShapeBuilder)), { name: this.localizationTable.arrowPen, id: "arrow", isShapeBuilder: !0, factory: i.makeArrowBuilder }, { name: this.localizationTable.linePen, id: "line", isShapeBuilder: !0, factory: a.makeLineBuilder }, { name: this.localizationTable.filledRectanglePen, id: "filled-rectangle", isShapeBuilder: !0, factory: l.makeFilledRectangleBuilder }, { name: this.localizationTable.outlinedRectanglePen, id: "outlined-rectangle", isShapeBuilder: !0, factory: l.makeOutlinedRectangleBuilder }, { name: this.localizationTable.outlinedCirclePen, id: "outlined-circle", isShapeBuilder: !0, factory: c.makeOutlinedCircleBuilder }, ...n.filter((t => t.isShapeBuilder))].filter(h), this.editor.notifier.on(d.EditorEventType.ToolUpdated, (t => { if (t.kind !== d.EditorEventType.ToolUpdated) throw new Error("Invalid event type!"); t.tool === this.tool && (this.updateIcon(), this.updateInputs()) })) } getTitle() { return this.targetTool.description } getCurrentPenTypeIdx() { const t = this.tool.getStrokeFactory(); for (let e = 0; e < this.penTypes.length; e++)if (this.penTypes[e].factory === t) return e; return -1 } getCurrentPenType() { for (const t of this.penTypes) if (t.factory === this.tool.getStrokeFactory()) return t; return null } createIconForRecord(t) { const e = { ...this.tool.getStyleValue().get() }; t?.factory && (e.factory = t.factory); const o = t?.factory; return o && o !== r.makeFreehandLineBuilder && o !== s.makePressureSensitiveFreehandLineBuilder && o !== y.makePolylineBuilder ? this.editor.icons.makeIconFromFactory(e) : this.editor.icons.makePenIcon(e) } createIcon() { return this.createIconForRecord(this.getCurrentPenType()) } createPenTypeSelector(t) { const e = this.penTypes.map(((t, e) => ({ id: e, makeIcon: () => this.createIconForRecord(t), title: t.name, isShapeBuilder: t.isShapeBuilder ?? !1 }))), o = e.filter((t => !t.isShapeBuilder)), n = (0, b.default)(this.localizationTable.selectPenType, this.getCurrentPenTypeIdx(), o), i = e.filter((t => t.isShapeBuilder)), r = (0, b.default)(this.localizationTable.selectShape, this.getCurrentPenTypeIdx(), i), s = t => { this.tool.setStrokeFactory(this.penTypes[t].factory) }; return n.value.onUpdate(s), r.value.onUpdate(s), t?.registerTextHelpForElements([n.getRootElement(), r.getRootElement()], this.localizationTable.penDropdown__penTypeHelpText), { setValue: t => { n.value.set(t), r.value.set(t) }, updateIcons: () => { n.updateIcons(), r.updateIcons() }, addTo: t => { o.length && n.addTo(t), i.length && r.addTo(t) } } } createStrokeCorrectionOptions(t) { const e = document.createElement("div"); e.classList.add("action-button-row", `${m.toolbarCSSPrefix}-pen-tool-toggle-buttons`); const o = (o, n) => { const i = document.createElement("button"); i.classList.add(`${m.toolbarCSSPrefix}-toggle-button`); const r = n.cloneNode(!0); r.classList.add("icon"); const s = document.createElement("span"); s.innerText = o, i.replaceChildren(r, s), i.setAttribute("role", "switch"), e.appendChild(i); let a = !1, l = t => { }; const c = { setChecked(t) { a = t, i.setAttribute("aria-checked", `${a}`), l(a) }, setOnInputListener(t) { l = t }, addHelpText(e) { t?.registerTextHelpForElement(i, e) } }; return i.onclick = () => { c.setChecked(!a) }, c }, n = o(this.localizationTable.inputStabilization, this.editor.icons.makeStrokeSmoothingIcon()); n.setOnInputListener((t => { this.tool.setHasStabilization(t) })); const i = o(this.localizationTable.strokeAutocorrect, this.editor.icons.makeShapeAutocorrectIcon()); return i.setOnInputListener((t => { this.tool.setStrokeAutocorrectEnabled(t) })), i.addHelpText(this.localizationTable.penDropdown__autocorrectHelpText), n.addHelpText(this.localizationTable.penDropdown__stabilizationHelpText), { update: () => { n.setChecked(!!this.tool.getInputMapper()), i.setChecked(this.tool.getStrokeAutocorrectionEnabled()) }, addTo: t => { t.appendChild(e) } } } getHelpText() { return this.localizationTable.penDropdown__baseHelpText } fillDropdown(t, e) { const o = document.createElement("div"); o.classList.add(`${m.toolbarCSSPrefix}spacedList`, `${m.toolbarCSSPrefix}nonbutton-controls-main-list`); const { container: n, setValue: i } = (0, g.default)(this.editor, (t => { this.tool.setThickness(t) })), r = document.createElement("div"), s = document.createElement("label"), a = (0, h.default)(this.editor, (t => { this.tool.setColor(t) })), { input: l, container: c } = a; l.id = `${m.toolbarCSSPrefix}colorInput${v.idCounter++}`, s.innerText = this.localizationTable.colorLabel, s.setAttribute("for", l.id), r.appendChild(s), r.appendChild(c); const d = this.createStrokeCorrectionOptions(e), u = this.createPenTypeSelector(e); return e?.registerTextHelpForElement(r, this.localizationTable.penDropdown__colorHelpText), e && a.registerWithHelpTextDisplay(e), e?.registerTextHelpForElement(n, this.localizationTable.penDropdown__thicknessHelpText), this.updateInputs = () => { a.setValue(this.tool.getColor()), i(this.tool.getThickness()), u.updateIcons(), u.setValue(this.getCurrentPenTypeIdx()), d.update() }, this.updateInputs(), o.replaceChildren(r, n), u.addTo(o), t.replaceChildren(o), d.addTo(t), !0 } onKeyPress(t) { if (!this.isSelected()) return !1; for (let e = 0; e < f.selectStrokeTypeKeyboardShortcutIds.length; e++) { const o = f.selectStrokeTypeKeyboardShortcutIds[e]; if (this.editor.shortcuts.matchesShortcut(o, t)) { const t = e; if (t < this.penTypes.length) return this.tool.setStrokeFactory(this.penTypes[t].factory), !0 } } return !!super.onKeyPress(t) } serializeState() { return { ...super.serializeState(), color: this.tool.getColor().toHexString(), thickness: this.tool.getThickness(), strokeFactoryId: this.getCurrentPenType()?.id, inputStabilization: !!this.tool.getInputMapper(), strokeAutocorrect: this.tool.getStrokeAutocorrectionEnabled() } } deserializeFrom(t) { super.deserializeFrom(t); const e = (e, o) => { const n = typeof t[e]; if (n !== o) throw new Error(`Deserializing property ${e}: Invalid type. Expected ${o}, was ${n}.`) }; if (t.color && (e("color", "string"), this.tool.setColor(p.Color4.fromHex(t.color))), t.thickness && (e("thickness", "number"), this.tool.setThickness(t.thickness)), t.strokeFactoryId) { e("strokeFactoryId", "string"); const o = t.strokeFactoryId; for (const t of this.penTypes) if (o === t.id) { this.tool.setStrokeFactory(t.factory); break } } void 0 !== t.inputStabilization && this.tool.setHasStabilization(!!t.inputStabilization), void 0 !== t.strokeAutocorrect && this.tool.setStrokeAutocorrectEnabled(!!t.strokeAutocorrect) } } v.idCounter = 0, e.default = v }, 8230: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(9751)), r = o(5068), s = o(9376); class a extends i.default { constructor(t, e, o, n = {}) { super(t, "save-button", (() => n.icon ?? t.icons.makeSaveIcon()), n.label ?? e.save, o), this.setTags([r.ToolbarWidgetTag.Save]) } shouldAutoDisableInReadOnlyEditor() { return !1 } onKeyPress(t) { return this.editor.shortcuts.matchesShortcut(s.saveKeyboardShortcut, t) ? (this.clickAction(), !0) : super.onKeyPress(t) } mustBeInToplevelMenu() { return !0 } } e.default = a }, 869: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = o(5379), r = o(486), s = n(o(2717)), a = o(2018), l = n(o(9943)), c = n(o(9751)), d = n(o(550)), h = o(9376), u = n(o(5007)), p = o(2034); class f extends d.default { constructor(t, e, o) { super(t, e, "selection-tool-widget", o), this.tool = e, this.updateFormatMenu = () => { }; const n = new c.default(t, "resize-btn", (() => t.icons.makeResizeImageToSelectionIcon()), this.localizationTable.resizeImageToSelection, (() => { this.resizeImageToSelection() }), o); n.setHelpText(this.localizationTable.selectionDropdown__resizeToHelpText); const i = new c.default(t, "delete-btn", (() => t.icons.makeDeleteSelectionIcon()), this.localizationTable.deleteSelection, (() => { const t = this.tool.getSelection(); this.editor.dispatch(t.deleteSelectedObjects()), this.tool.clearSelection() }), o); i.setHelpText(this.localizationTable.selectionDropdown__deleteHelpText); const r = new c.default(t, "duplicate-btn", (() => t.icons.makeDuplicateSelectionIcon()), this.localizationTable.duplicateSelection, (async () => { const t = this.tool.getSelection(); this.editor.dispatch(await t.duplicateSelectedObjects()), this.setDropdownVisible(!1) }), o); r.setHelpText(this.localizationTable.selectionDropdown__duplicateHelpText), this.addSubWidget(n), this.addSubWidget(i), this.addSubWidget(r); const s = t => { n.setDisabled(t), i.setDisabled(t), r.setDisabled(t) }; s(!0), this.editor.notifier.on(a.EditorEventType.ToolUpdated, (t => { if (t.kind !== a.EditorEventType.ToolUpdated) throw new Error("Invalid event type!"); if (t.tool === this.tool) { const t = this.tool.getSelection(), e = t && t.getSelectedItemCount() > 0; s(!e), this.updateFormatMenu() } })) } resizeImageToSelection() { const t = this.tool.getSelection(); t && this.editor.dispatch(this.editor.setImportExportRect(t.region)) } onKeyPress(t) { return this.editor.shortcuts.matchesShortcut(h.resizeImageToSelectionKeyboardShortcut, t) ? (this.resizeImageToSelection(), !0) : !!super.onKeyPress(t) } getTitle() { return this.localizationTable.select } createIcon() { return this.editor.icons.makeSelectionIcon() } getHelpText() { return this.localizationTable.selectionDropdown__baseHelpText } fillDropdown(t, e) { super.fillDropdown(t, e); const o = document.createElement("div"); o.classList.add(`${p.toolbarCSSPrefix}nonbutton-controls-main-list`), t.appendChild(o), (0, u.default)(this.localizationTable.reformatSelection).addTo(o); const n = ((t, e, o) => { const n = document.createElement("div"); n.classList.add("selection-format-menu", `${p.toolbarCSSPrefix}spacedList`, `${p.toolbarCSSPrefix}indentedList`); const a = document.createElement("div"), c = document.createElement("label"), d = (0, l.default)(t, (o => { const n = e.getSelection(); if (n) { const e = []; for (const t of n.getSelectedObjects()) (0, r.isRestylableComponent)(t) && e.push(t.updateStyle({ color: o })); const i = (0, s.default)(e); t.dispatch(i) } })), { input: h, container: u } = d; return c.innerText = o.colorLabel, a.replaceChildren(c, u), n.replaceChildren(a), { addTo: t => { t.appendChild(n) }, update: () => { const t = e.getSelection(); if (t && t.getSelectedItemCount() > 0) { h.disabled = !1, n.classList.remove("disabled"); const e = []; for (const o of t.getSelectedObjects()) if ((0, r.isRestylableComponent)(o)) { const t = o.getStyle().color; t && e.push(t) } d.setValue(i.Color4.average(e)) } else h.disabled = !0, n.classList.add("disabled"), d.setValue(i.Color4.transparent) }, registerHelpText: t => { t.registerTextHelpForElement(a, o.selectionDropdown__changeColorHelpText), d.registerWithHelpTextDisplay(t) } } })(this.editor, this.tool, this.localizationTable); return n.addTo(o), this.updateFormatMenu = () => n.update(), e && n.registerHelpText(e), n.update(), !0 } } e.default = f }, 5360: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = o(5379), r = o(2018), s = o(2034), a = n(o(9943)), l = n(o(550)); class c extends l.default { constructor(t, e, o) { super(t, e, "text-tool-widget", o), this.tool = e, this.updateDropdownInputs = null, t.notifier.on(r.EditorEventType.ToolUpdated, (t => { t.kind === r.EditorEventType.ToolUpdated && t.tool === e && (this.updateIcon(), this.updateDropdownInputs?.()) })) } getTitle() { return this.targetTool.description } createIcon() { const t = this.tool.getTextStyle(); return this.editor.icons.makeTextIcon(t) } fillDropdown(t) { const e = document.createElement("div"); e.classList.add(`${s.toolbarCSSPrefix}spacedList`, `${s.toolbarCSSPrefix}nonbutton-controls-main-list`); const o = document.createElement("div"), n = document.createElement("div"), i = document.createElement("div"), r = document.createElement("select"), l = document.createElement("label"), d = document.createElement("input"), h = document.createElement("label"), { input: u, container: p, setValue: f } = (0, a.default)(this.editor, (t => { this.tool.setColor(t) })), m = document.createElement("label"), g = new Set, b = t => { const e = document.createElement("option"); e.value = t, e.textContent = t, r.appendChild(e), g.add(t) }; d.setAttribute("type", "number"), d.min = "1", d.max = "128", l.innerText = this.localizationTable.fontLabel, m.innerText = this.localizationTable.colorLabel, h.innerText = this.localizationTable.textSize, u.id = `${s.toolbarCSSPrefix}-text-color-input-${c.idCounter++}`, m.setAttribute("for", u.id), d.id = `${s.toolbarCSSPrefix}-text-size-input-${c.idCounter++}`, h.setAttribute("for", d.id); const y = this.editor.getCurrentSettings().text?.fonts ?? []; for (const t of y) b(t); return r.classList.add("font-selector"), r.id = `${s.toolbarCSSPrefix}-text-font-input-${c.idCounter++}`, l.setAttribute("for", r.id), r.onchange = () => { this.tool.setFontFamily(r.value) }, d.onchange = () => { const t = parseInt(d.value); !isNaN(t) && t > 0 && this.tool.setFontSize(t) }, n.appendChild(m), n.appendChild(p), o.appendChild(l), o.appendChild(r), i.appendChild(h), i.appendChild(d), this.updateDropdownInputs = () => { const t = this.tool.getTextStyle(); f(t.renderingStyle.fill), g.has(t.fontFamily) || b(t.fontFamily), r.value = t.fontFamily, d.value = `${t.size}` }, this.updateDropdownInputs(), e.replaceChildren(n, i, o), t.appendChild(e), !0 } serializeState() { const t = this.tool.getTextStyle(); return { ...super.serializeState(), fontFamily: t.fontFamily, textSize: t.size, color: t.renderingStyle.fill.toHexString() } } deserializeFrom(t) { t.fontFamily && "string" == typeof t.fontFamily && this.tool.setFontFamily(t.fontFamily), t.color && "string" == typeof t.color && this.tool.setColor(i.Color4.fromHex(t.color)), t.textSize && "number" == typeof t.textSize && this.tool.setFontSize(t.textSize), super.deserializeFrom(t) } } c.idCounter = 0, e.default = c }, 9943: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.makeColorInput = void 0; const i = o(5379), r = n(o(2870)), s = o(2018); e.makeColorInput = (t, e) => { const o = document.createElement("span"), n = document.createElement("span"), r = document.createElement("input"); r.type = "button", r.classList.add("coloris_input"), o.classList.add("color-input-container"), n.classList.add("color-input-wrapper"), n.appendChild(r), o.appendChild(n); const l = a(t, o, (t => { r.value = t.toHexString(), h(); const e = r.parentElement; e && e.classList.contains("clr-field") && (e.style.color = r.value) })); let c; const d = () => { c = i.Color4.fromHex(r.value) }, h = () => { d(), c && (t.announceForAccessibility(t.localization.colorChangedAnnouncement(c.toHexString())), e(c), t.notifier.dispatch(s.EditorEventType.ColorPickerColorSelected, { kind: s.EditorEventType.ColorPickerColorSelected, color: c })) }; r.oninput = d; let u = !1; r.addEventListener("open", (() => { u = !0, t.notifier.dispatch(s.EditorEventType.ColorPickerToggled, { kind: s.EditorEventType.ColorPickerToggled, open: !0 }), l.cancel(), o.classList.add("picker-open"); const e = document.querySelector("#clr-picker #clr-hue-slider"); e?.focus() })); r.addEventListener("close", (() => { u = !1, t.notifier.dispatch(s.EditorEventType.ColorPickerToggled, { kind: s.EditorEventType.ColorPickerToggled, open: !1 }), h(), r.focus(), o.classList.remove("picker-open") })); return { input: r, container: o, setValue: t => { "object" == typeof t && (t = t.toHexString()), r.value = t, r.dispatchEvent(new Event("input", { bubbles: !0 })) }, closePicker: () => { u && h() }, registerWithHelpTextDisplay: e => { e.registerTextHelpForElement(n, t.localization.colorPickerToggleHelpText), l.registerWithHelpTextDisplay(e) } } }; const a = (t, e, o) => { const n = document.createElement("button"); n.classList.add("pipetteButton"), n.title = t.localization.pickColorFromScreen, n.setAttribute("alt", n.title); const i = document.createElement("span"); i.classList.add("pickColorInstructions"), i.innerText = t.localization.clickToPickColorAnnouncement; const s = e => { n.replaceChildren(t.icons.makePipetteIcon(e), i) }; s(); const a = t.toolController.getMatchingTools(r.default)[0], l = () => { a?.clearColorListener(), s(), n.classList.remove("active") }, c = t => { l(), t && o(t) }, d = t => { t ? s(t) : s() }; return n.onclick = () => { if (n.classList.contains("active")) return l(), void t.announceForAccessibility(t.localization.colorSelectionCanceledAnnouncement); a?.setColorListener(d, c), a && (n.classList.add("active"), t.announceForAccessibility(t.localization.clickToPickColorAnnouncement)) }, e.appendChild(n), { cancel: () => { l() }, registerWithHelpTextDisplay: e => { e.registerTextHelpForElement(n, t.localization.colorPickerPipetteHelpText) } } }; e.default = e.makeColorInput }, 3634: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(7988)); let r = 0; e.default = (t, e, { accepts: o = "*", allowMultiSelect: n = !1, customPickerAction: s } = {}) => { const a = document.createElement("div"), l = document.createElement("label"), c = document.createElement("input"), d = document.createElement("div"); d.classList.add("toolbar--file-input-description"); const h = document.createElement("span"); a.classList.add("toolbar--file-input-container"), l.appendChild(document.createTextNode(t)), c.accept = o, c.type = s ? "button" : "file", c.classList.add("file-input"), c.multiple = n; const u = "js-draw-file-input-" + r++; c.setAttribute("id", u), l.htmlFor = u; const p = e.icons.makeUploadFileIcon(); p.classList.add("icon"), d.replaceChildren(p, h), l.appendChild(d), a.replaceChildren(l, c); const f = i.default.fromInitialValue([]); let m = !1, g = null; const b = () => { const t = f.get(); if (m) { if (h.textContent = e.localization.fileInput__loading, g) { const t = document.createElement("b"); t.textContent = e.localization.cancel, t.classList.add("cancel-button"), h.appendChild(t) } p.style.display = "none" } else if (t.length > 0) { const o = t.map((t => t.name)), n = 5; if (o.length <= n) h.textContent = o.join("\n"); else { const t = o.slice(0, n - 1); h.textContent = [...t, e.localization.fileInput__andNMoreFiles(o.length - t.length)].join("\n") } p.style.display = "none" } else { p.style.display = ""; const t = e.localization.dragAndDropHereOrBrowse.split(/[{]{2}(.*)[}]{2}/g); h.replaceChildren(); for (let e = 0; e < t.length; e++)if (e % 2 == 1) { const o = document.createElement("b"); o.textContent = t[e], h.appendChild(o) } else h.appendChild(document.createTextNode(t[e])) } }; if (l.addEventListener("dragover", (t => { t.preventDefault(), l.classList.add("drag-target") })), l.addEventListener("dragenter", (t => { t.preventDefault(), l.classList.add("drag-target") })), l.addEventListener("dragleave", (t => { t.preventDefault(); const e = t.relatedTarget; e && l.contains(e) || l.classList.remove("drag-target") })), l.addEventListener("drop", (t => { t.preventDefault(), l.classList.remove("drag-target"); const e = []; t.dataTransfer && e.push(...t.dataTransfer.files), f.set(e) })), c.addEventListener("change", (() => { const t = c.files ?? []; f.set([...t]) })), s) { const t = async () => { if (m) g?.(); else { a.classList.add("-loading"), m = !0, b(); try { const t = await s({ setOnCancelCallback: t => { if (!m) throw new Error("Task already completed. Can't register cancel handler."); g = () => { g = null, b(), t() }, b() } }); t && f.set(t) } finally { a.classList.remove("-loading"), m = !1, b() } } }; c.onclick = t } return f.onUpdate((t => { 0 === t.length && c.files && c.files.length > 0 && (c.value = ""), g?.() })), f.onUpdateAndNow(b), { container: a, input: c, selectedFiles: f, addTo: t => { t.appendChild(a) } } } }, 3759: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = o(7988), r = n(o(9292)), s = n(o(3676)), a = o(2034); let l = 0; e.default = (t, e, o) => { const n = document.createElement("div"); n.classList.add(`${a.toolbarCSSPrefix}grid-selector`); const c = i.MutableReactiveValue.fromInitialValue(e), d = document.createElement("div"); d.setAttribute("role", "menu"), d.id = `${a.toolbarCSSPrefix}-grid-select-id-${l++}`, (0, r.default)(d); const h = document.createElement("label"); h.textContent = t, h.htmlFor = d.id, n.appendChild(h); let u = `${a.toolbarCSSPrefix}-grid-selector-${l++}`; const p = t => { const e = document.createElement("div"); e.classList.add("choice-button"); const o = document.createElement("input"); o.type = "radio", o.id = `${a.toolbarCSSPrefix}-grid-select-button-${l++}`, (0, s.default)(e); const n = document.createElement("label"), i = () => { n.setAttribute("title", t.title); const e = document.createElement("span"); e.classList.add("button-label-text"); const i = t.makeIcon(); i.classList.add("icon"), e.innerText = t.title, n.htmlFor = o.id, n.replaceChildren(i, e) }; i(); const r = () => { o.name = u }; r(); const h = () => { o.checked ? e.classList.add("checked") : e.classList.remove("checked") }; o.oninput = () => { o.checked && c.set(t.id), h() }, o.onfocus = () => { e.querySelector(":focus-visible") && e.classList.add("focus-visible") }, o.onblur = () => { e.classList.remove("focus-visible") }, e.oncontextmenu = t => { t.preventDefault() }, e.replaceChildren(o, n), d.appendChild(e); const p = t => { o.checked = t, h() }; p(!1); return { choiceRecord: t, setChecked: p, updateIcon: () => { i() }, updateButtonRadiogroupName: r } }, f = []; for (const t of o) f.push(p(t)); n.appendChild(d), c.onUpdateAndNow((t => { for (let e = 0; e < f.length; e++)f[e].setChecked(f[e].choiceRecord.id === t) })); const m = { value: c, _radiogroupName: u, linkWith: t => { m._radiogroupName = t._radiogroupName, u = t._radiogroupName; for (const t of f) t.updateButtonRadiogroupName() }, updateIcons: () => { f.forEach((t => t.updateIcon())) }, getRootElement: () => n, addTo: t => { t.appendChild(n) } }; return m } }, 5007: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); e.default = (t = "") => { const e = document.createElement("div"); return e.classList.add("tool-dropdown-separator"), e.innerText = t, { addTo: t => { t.appendChild(e) } } } }, 1265: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(9292)), r = o(7988); e.default = t => { const e = document.createElement("div"); e.classList.add("toolbar-snapped-scroll-list"); const o = document.createElement("div"); o.classList.add("scroller"); const n = r.MutableReactiveValue.fromInitialValue(0); let s = null; const a = r.ReactiveValue.map(t, (t => t.map(((t, e) => { const o = document.createElement("div"); return t.element.parentElement && t.element.remove(), o.appendChild(t.element), o.classList.add("item"), o.setAttribute("data-item-index", `${e}`), { element: o, data: t.data } })))), l = []; a.onUpdateAndNow((t => { n.set(-1); for (const t of l) s?.unobserve(t.element); o.replaceChildren(), t.length > 1 ? s = new IntersectionObserver((t => { for (const e of t) if (e.isIntersecting && e.intersectionRatio > .7) { const t = e.target.getAttribute("data-item-index"); if (null === t) throw new Error("Could not find attribute data-item-index"); const o = Number(t); n.set(o); break } }), { root: o, threshold: .9 }) : s && (s.disconnect(), n.set(0), s = null), 0 === t.length ? e.classList.add("-empty") : e.classList.remove("-empty"); for (const e of t) o.appendChild(e.element); if (n.set(0), s) for (const e of t) s.observe(e.element) })); const c = r.ReactiveValue.map(n, (e => { const o = t.get(); return 0 <= e && e < o.length ? o[e].data : null })); return (0, i.default)(o), e.replaceChildren((() => { const o = document.createElement("div"); o.classList.add("page-markers"), o.setAttribute("tabindex", "-1"); const i = []; return r.ReactiveValue.union([n, t]).onUpdateAndNow((([t, n]) => { let r, s = !1; for (; n.length < i.length;)i.pop(), s = !0; for (let e = 0; e < n.length; e++) { let o; if (e >= i.length) { o = document.createElement("div"); const t = document.createElement("div"); t.classList.add("content"), o.replaceChildren(t), i.push(o), s = !0 } else o = i[e]; o.classList.add("marker"), e === t ? (o.classList.add("-active"), r = o) : o.classList.remove("-active"); const n = e; o.onclick = () => { a.get()[n]?.element?.scrollIntoView({ block: "nearest", behavior: "smooth" }) } } s && o.replaceChildren(...i), r && o.scrollHeight > e.clientHeight && r.scrollIntoView({ block: "nearest" }), 1 === i.length ? o.classList.add("-one-element") : o.classList.remove("-one-element") })), o })(), o), { container: e, visibleItem: c } } }, 2059: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); const n = o(5379), i = o(2034); let r = 0; e.default = (t, e) => { const o = document.createElement("div"), s = document.createElement("label"), a = document.createElement("input"); o.classList.add(`${i.toolbarCSSPrefix}thicknessSliderContainer`), a.id = `${i.toolbarCSSPrefix}thicknessInput${r++}`, s.innerText = t.localization.thicknessLabel, s.setAttribute("for", a.id); const l = t => Math.log10(t); a.type = "range", a.oninput = () => { e((t => 10 ** t)(parseFloat(a.value))) }, o.appendChild(s), o.appendChild(a); const c = (t, e) => { const o = (t, e) => (e ? Math.ceil : Math.floor)(100 * t) / 100, i = o(l(t), !1), r = o(l(e), !0); a.min = `${i}`, a.max = `${r}`, a.step = `${(0, n.toRoundedString)((r - i) / 20)}` }; return c(2, 262), { container: o, addTo: t => { t.appendChild(o) }, setBounds: c, setValue: t => { a.value = l(t).toString() } } } }, 9376: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.exitKeyboardShortcut = e.saveKeyboardShortcut = e.selectStrokeTypeKeyboardShortcutIds = e.resizeImageToSelectionKeyboardShortcut = void 0; const i = n(o(5577)); e.resizeImageToSelectionKeyboardShortcut = "jsdraw.toolbar.SelectionTool.resizeImageToSelection", i.default.registerDefaultKeyboardShortcut(e.resizeImageToSelectionKeyboardShortcut, ["ctrlOrMeta+r"], "Resize image to selection"), e.selectStrokeTypeKeyboardShortcutIds = [1, 2, 3, 4, 5, 6, 7, 8, 9].map((t => `jsdraw.toolbar.PenTool.select-pen-${t}`)); for (let t = 0; t < e.selectStrokeTypeKeyboardShortcutIds.length; t++) { const o = e.selectStrokeTypeKeyboardShortcutIds[t]; i.default.registerDefaultKeyboardShortcut(o, [`CtrlOrMeta+Digit${t + 1}`], "Select pen style " + (t + 1)) } e.saveKeyboardShortcut = "jsdraw.toolbar.SaveActionWidget.save", i.default.registerDefaultKeyboardShortcut(e.saveKeyboardShortcut, ["ctrlOrMeta+KeyS"], "Save"), e.exitKeyboardShortcut = "jsdraw.toolbar.ExitActionWidget.exit", i.default.registerDefaultKeyboardShortcut(e.exitKeyboardShortcut, ["Alt+KeyQ"], "Exit") }, 418: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = o(2018), r = n(o(9118)), s = o(2034), a = o(7988); var l; !function (t) { t[t.DropdownShown = 0] = "DropdownShown", t[t.DropdownHidden = 1] = "DropdownHidden" }(l || (l = {})); class c { constructor(t, e, o) { this.parent = t, this.notifier = e, this.onDestroy = o, this.dropdownToggleListener = null, this.hideDropdownTimeout = null, this.visible = a.ReactiveValue.fromInitialValue(!1), this.dropdownContainer = document.createElement("div"), this.dropdownContainer.classList.add(`${s.toolbarCSSPrefix}dropdown`), this.dropdownContainer.classList.add("hidden"), t.target.insertAdjacentElement("afterend", this.dropdownContainer), this.dropdownToggleListener = this.notifier.on(l.DropdownShown, (t => { t.dropdown !== this && t.fromToplevelDropdown && this.setVisible(!1) })) } onActivated() { } repositionDropdown() { const t = this.dropdownContainer.getBoundingClientRect(), e = document.scrollingElement?.clientWidth ?? document.body.clientHeight, o = document.scrollingElement?.clientHeight ?? document.body.clientHeight; let n, i; if (t.left > e / 2) { n = `calc(${this.parent.target.clientWidth + "px"} - 100%)` } if (t.bottom > o && t.top - t.height > 0) { i = `calc(-${this.parent.target.clientHeight}px - 100%)` } this.dropdownContainer.style.translate = n || i ? `${n ?? "0"} ${i ?? "0"}` : "" } setVisible(t) { if (this.visible.get() === t) return; this.hideDropdownTimeout && (clearTimeout(this.hideDropdownTimeout), this.hideDropdownTimeout = null, this.dropdownContainer.classList.remove("hiding"), this.repositionDropdown()); if (this.visible.set(t), t) this.dropdownContainer.classList.remove("hidden"), this.notifier.dispatch(l.DropdownShown, { dropdown: this, fromToplevelDropdown: this.parent.isToplevel() }), this.repositionDropdown(); else { this.notifier.dispatch(l.DropdownHidden, { dropdown: this, fromToplevelDropdown: this.parent.isToplevel() }), this.dropdownContainer.classList.add("hiding"); const t = 142.5; this.hideDropdownTimeout = setTimeout((() => { this.dropdownContainer.classList.add("hidden"), this.dropdownContainer.classList.remove("hiding"), this.repositionDropdown() }), t) } const e = `var(--dropdown-${t ? "show" : "hide"}-animation)`; this.dropdownContainer.style.animation = `150ms ease ${e}` } requestShow() { this.setVisible(!0) } requestHide() { this.setVisible(!1) } appendChild(t) { this.dropdownContainer.appendChild(t) } clearChildren() { this.dropdownContainer.replaceChildren() } destroy() { this.setVisible(!1), this.dropdownContainer.remove(), this.dropdownToggleListener?.remove(), this.clearChildren(), this.onDestroy() } } e.default = class { constructor(t, e) { this.localization = e, this.dropdowns = new Set, this.listeners = [], this.connectedNotifiers = [], this.notifier = new r.default, this.notifier.on(l.DropdownShown, (({ dropdown: e, fromToplevelDropdown: o }) => { e && (t(this.localization.dropdownShown(e.parent.getTitle())), this.connectedNotifiers.forEach((t => { t.dispatch(i.EditorEventType.ToolbarDropdownShown, { kind: i.EditorEventType.ToolbarDropdownShown, fromToplevelDropdown: o, layoutManager: this }) }))) })), this.notifier.on(l.DropdownHidden, (({ dropdown: e }) => { e && t(this.localization.dropdownHidden(e.parent.getTitle())) })) } connectToEditorNotifier(t) { this.connectedNotifiers.push(t), this.refreshListeners() } createToolMenu(t) { const e = new c(t, this.notifier, (() => { this.dropdowns.delete(e), this.refreshListeners() })); return this.dropdowns.add(e), this.refreshListeners(), e } refreshListeners() { const t = () => { this.listeners.forEach((t => t.remove())), this.listeners = [] }; 0 === this.dropdowns.size ? t() : this.listeners.length !== this.connectedNotifiers.length && (t(), this.listeners = this.connectedNotifiers.map((t => t.on(i.EditorEventType.ToolbarDropdownShown, (t => { t.kind === i.EditorEventType.ToolbarDropdownShown && t.layoutManager !== this && this.notifier.dispatch(l.DropdownShown, { fromToplevelDropdown: t.fromToplevelDropdown }) }))))) } } }, 4175: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); const n = o(7988); e.default = class { constructor(t, e, o, i, r) { this.setSidebarContent = t, this.sidebarTitle = e, this.sidebarVisibility = o, this.announceForAccessibility = i, this.localization = r, this.visibleWidgetContent = n.ReactiveValue.fromInitialValue(null) } createToolMenu(t) { const e = document.createElement("div"); let o = null; const i = n.ReactiveValue.fromCallback((() => this.visibleWidgetContent.get() === o && this.sidebarVisibility.get()), [this.visibleWidgetContent, this.sidebarVisibility]); return o = { visible: i, requestShow: () => { this.setSidebarContent(e), this.sidebarTitle.set(t.getTitle()), this.visibleWidgetContent.set(o), this.sidebarVisibility.set(!0), this.announceForAccessibility(this.localization.dropdownShown(t.getTitle())) }, onActivated: () => { }, requestHide: () => { i.get() && this.sidebarVisibility.set(!1) }, appendChild: t => { e.appendChild(t) }, clearChildren: () => { e.replaceChildren() }, destroy: () => { o?.requestHide(), e.parentElement && e.remove(), this.visibleWidgetContent.get() === o && this.visibleWidgetContent.set(null) } }, o } } }, 6006: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.DocumentPropertiesWidget = e.InsertImageWidget = e.EraserToolWidget = e.SelectionToolWidget = e.HandToolWidget = e.TextToolWidget = e.PenToolWidget = e.ToolbarWidgetTag = e.BaseWidget = e.BaseToolWidget = e.ActionButtonWidget = void 0; var i = o(9751); Object.defineProperty(e, "ActionButtonWidget", { enumerable: !0, get: function () { return n(i).default } }); var r = o(550); Object.defineProperty(e, "BaseToolWidget", { enumerable: !0, get: function () { return n(r).default } }); var s = o(5068); Object.defineProperty(e, "BaseWidget", { enumerable: !0, get: function () { return n(s).default } }), Object.defineProperty(e, "ToolbarWidgetTag", { enumerable: !0, get: function () { return s.ToolbarWidgetTag } }); var a = o(9108); Object.defineProperty(e, "PenToolWidget", { enumerable: !0, get: function () { return n(a).default } }); var l = o(5360); Object.defineProperty(e, "TextToolWidget", { enumerable: !0, get: function () { return n(l).default } }); var c = o(1210); Object.defineProperty(e, "HandToolWidget", { enumerable: !0, get: function () { return n(c).default } }); var d = o(869); Object.defineProperty(e, "SelectionToolWidget", { enumerable: !0, get: function () { return n(d).default } }); var h = o(1295); Object.defineProperty(e, "EraserToolWidget", { enumerable: !0, get: function () { return n(h).default } }); var u = o(1294); Object.defineProperty(e, "InsertImageWidget", { enumerable: !0, get: function () { return n(u).default } }); var p = o(7021); Object.defineProperty(e, "DocumentPropertiesWidget", { enumerable: !0, get: function () { return n(p).default } }) }, 8836: function (t, e, o) { "use strict"; var n, i, r, s, a = this && this.__classPrivateFieldSet || function (t, e, o, n, i) { if ("m" === n) throw new TypeError("Private method is not writable"); if ("a" === n && !i) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof e ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === n ? i.call(t, o) : i ? i.value = o : e.set(t, o), o }, l = this && this.__classPrivateFieldGet || function (t, e, o, n) { if ("a" === o && !n) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === o ? n : "a" === o ? n.call(t) : n ? n.value : e.get(t) }; Object.defineProperty(e, "__esModule", { value: !0 }); const c = o(2018), d = o(7394), h = o(7988); n = new WeakMap, i = new WeakMap, r = new WeakMap, s = new WeakMap, e.default = class { constructor(t, e) { this.notifier = t, this.description = e, n.set(this, void 0), i.set(this, null), r.set(this, null), s.set(this, null), a(this, n, h.ReactiveValue.fromInitialValue(!0), "f"), l(this, n, "f").onUpdate((t => { t ? (l(this, i, "f")?.notifyEnabled(this), this.notifier.dispatch(c.EditorEventType.ToolEnabled, { kind: c.EditorEventType.ToolEnabled, tool: this })) : this.notifier.dispatch(c.EditorEventType.ToolDisabled, { kind: c.EditorEventType.ToolDisabled, tool: this }) })) } canReceiveInputInReadOnlyEditor() { return !1 } setInputMapper(t) { a(this, r, t, "f"), t && t.setEmitListener((t => this.dispatchEventToCallback(t))) } getInputMapper() { return l(this, r, "f") } dispatchEventToCallback(t) { let e; switch (t.kind) { case d.InputEvtType.PointerDownEvt: return this.onPointerDown(t); case d.InputEvtType.PointerMoveEvt: this.onPointerMove(t); break; case d.InputEvtType.PointerUpEvt: return this.onPointerUp(t) ?? !1; case d.InputEvtType.GestureCancelEvt: this.onGestureCancel(t); break; case d.InputEvtType.WheelEvt: return this.onWheel(t); case d.InputEvtType.KeyPressEvent: return this.onKeyPress(t); case d.InputEvtType.KeyUpEvent: return this.onKeyUp(t); case d.InputEvtType.CopyEvent: return this.onCopy(t); case d.InputEvtType.PasteEvent: return this.onPaste(t); case d.InputEvtType.ContextMenu: return this.onContextMenu(t); default: return e = t, e }return !0 } onEvent(t) { return l(this, r, "f") ? l(this, r, "f").onEvent(t) : this.dispatchEventToCallback(t) } onPointerDown(t) { return !1 } onPointerMove(t) { } onPointerUp(t) { } onGestureCancel(t) { } onWheel(t) { return !1 } onCopy(t) { return !1 } onPaste(t) { return !1 } onKeyPress(t) { return !1 } onKeyUp(t) { return !1 } onContextMenu(t) { return !1 } eventCanBeDeliveredToNonActiveTool(t) { return !0 } setEnabled(t) { l(this, n, "f").set(t) } isEnabled() { return l(this, n, "f").get() } enabledValue() { return l(this, n, "f") } setToolGroup(t) { this.isEnabled() && t.notifyEnabled(this), a(this, i, t, "f") } getToolGroup() { return l(this, i, "f") ? l(this, i, "f") : null } onDestroy() { l(this, s, "f")?.remove(), a(this, s, null, "f"), a(this, i, null, "f") } } }, 1011: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.EraserMode = void 0; const i = o(2018), r = n(o(8836)), s = o(5379), a = n(o(6188)), l = o(578), c = o(6362), d = o(7988), h = n(o(7)), u = n(o(2717)), p = o(8258); var f; !function (t) { t.PartialStroke = "partial-stroke", t.FullStroke = "full-stroke" }(f || (e.EraserMode = f = {})); class m extends r.default { constructor(t, e) { super(t.notifier, t.localization.changeTool), this.editor = t, this.eraser = e } onPointerDown(t) { if (1 === t.allPointers.length && t.current.device === l.PointerDevice.Eraser) { const e = this.editor.toolController.getPrimaryTools().filter((t => t.isEnabled())); if (e.length ? this.previousEnabledTool = e[0] : this.previousEnabledTool = null, this.previousEraserEnabledState = this.eraser.isEnabled(), this.eraser.setEnabled(!0), this.eraser.onPointerDown(t)) return !0; this.restoreOriginalTool() } return !1 } onPointerMove(t) { this.eraser.onPointerMove(t) } restoreOriginalTool() { this.eraser.setEnabled(this.previousEraserEnabledState), this.previousEnabledTool && this.previousEnabledTool.setEnabled(!0) } onPointerUp(t) { this.eraser.onPointerUp(t), this.restoreOriginalTool() } onGestureCancel(t) { this.eraser.onGestureCancel(t), this.restoreOriginalTool() } } class g extends r.default { constructor(t, e, o) { super(t.notifier, e), this.editor = t, this.lastPoint = null, this.isFirstEraseEvt = !0, this.toAdd = new Set, this.eraseCommands = [], this.addCommands = [], this.thickness = o?.thickness ?? 10, this.thicknessValue = d.ReactiveValue.fromInitialValue(this.thickness), this.thicknessValue.onUpdate((t => { this.thickness = t, this.editor.notifier.dispatch(i.EditorEventType.ToolUpdated, { kind: i.EditorEventType.ToolUpdated, tool: this }) })), this.modeValue = d.ReactiveValue.fromInitialValue(o?.mode ?? f.FullStroke), this.modeValue.onUpdate((t => { this.editor.notifier.dispatch(i.EditorEventType.ToolUpdated, { kind: i.EditorEventType.ToolUpdated, tool: this }) })) } makeEraserSwitcherTool() { return new m(this.editor, this) } clearPreview() { this.editor.clearWetInk() } getSizeOnCanvas() { return this.thickness / this.editor.viewport.getScaleFactor() } drawPreviewAt(t) { this.clearPreview(); const e = this.getSizeOnCanvas(), o = this.editor.display.getWetInkRenderer(), n = this.getEraserRect(t), i = this.getEraserRect(this.lastPoint ?? t), r = { fill: s.Color4.transparent, stroke: { width: e / 10, color: s.Color4.gray } }; o.drawPath((0, p.pathToRenderable)(s.Path.fromConvexHullOf([...n.corners, ...i.corners]), r)) } getEraserRect(t) { const e = this.getSizeOnCanvas(), o = s.Vec2.of(e / 2, e / 2); return s.Rect2.fromCorners(t.minus(o), t.plus(o)) } eraseTo(t) { if (!this.isFirstEraseEvt && 0 === t.distanceTo(this.lastPoint)) return; this.isFirstEraseEvt = !1; const e = this.getEraserRect(t), o = new s.LineSegment2(this.lastPoint, t), n = s.Rect2.union(o.bbox, e), i = this.editor.image.getElementsIntersectingRegion(n).filter((t => t.intersects(o) || t.intersectsRect(e))).filter((t => t.isSelectable())); if (this.modeValue.get() === f.FullStroke) { this.toRemove.push(...i); const t = i.map((t => new a.default([t]))); t.forEach((t => t.apply(this.editor))), this.eraseCommands.push(...t) } else { const o = [], n = []; for (const r of i) { if (o.push(r), !r.withRegionErased) continue; if (e.grownBy(e.maxDimension / 3).containsRect(r.getExactBBox())) continue; const i = s.Path.fromConvexHullOf([...e.corners, ...this.getEraserRect(this.lastPoint ?? t).corners].map((t => this.editor.viewport.roundPoint(t)))); n.push(...r.withRegionErased(i, this.editor.viewport)) } const r = new a.default(o), l = n.map((t => h.default.addElement(t))); r.apply(this.editor), l.forEach((t => t.apply(this.editor))); const c = []; for (const t of o) this.toAdd.has(t) ? this.toAdd.delete(t) : c.push(t); this.toRemove.push(...c); for (const t of n) this.toAdd.add(t); this.eraseCommands.push(new a.default(c)), this.addCommands.push(...l) } this.drawPreviewAt(t), this.lastPoint = t } onPointerDown(t) { return (1 === t.allPointers.length || t.current.device === l.PointerDevice.Eraser) && (this.lastPoint = t.current.canvasPos, this.toRemove = [], this.toAdd.clear(), this.isFirstEraseEvt = !0, this.drawPreviewAt(t.current.canvasPos), !0) } onPointerMove(t) { const e = t.current.canvasPos; this.eraseTo(e) } onPointerUp(t) { this.eraseTo(t.current.canvasPos); const e = []; if (this.addCommands.length > 0) { this.addCommands.forEach((t => t.unapply(this.editor))); for (const t of this.toAdd) this.toRemove.includes(t) && (this.toAdd.delete(t), this.toRemove = this.toRemove.filter((e => e !== t))); for (const t of this.toRemove) this.toAdd.has(t) && (this.toAdd.delete(t), this.toRemove = this.toRemove.filter((e => e !== t))); e.push(...[...this.toAdd].map((t => h.default.addElement(t)))), this.addCommands = [] } if (this.eraseCommands.length > 0) { this.eraseCommands.forEach((t => t.unapply(this.editor))), this.eraseCommands = []; const t = new a.default(this.toRemove); e.push(t) } 1 === e.length ? this.editor.dispatch(e[0]) : this.editor.dispatch((0, u.default)(e)), this.clearPreview() } onGestureCancel(t) { this.addCommands.forEach((t => t.unapply(this.editor))), this.eraseCommands.forEach((t => t.unapply(this.editor))), this.eraseCommands = [], this.addCommands = [], this.clearPreview() } onKeyPress(t) { const e = this.editor.shortcuts; let o; return e.matchesShortcut(c.decreaseSizeKeyboardShortcutId, t) ? o = 2 * this.getThickness() / 3 : e.matchesShortcut(c.increaseSizeKeyboardShortcutId, t) && (o = 3 * this.getThickness() / 2), void 0 !== o && (o = Math.min(Math.max(1, o), 200), this.setThickness(o), !0) } getThickness() { return this.thickness } setThickness(t) { this.thicknessValue.set(t) } getThicknessValue() { return this.thicknessValue } getModeValue() { return this.modeValue } } e.default = g }, 8402: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(2170)), r = n(o(4686)), s = n(o(8836)), a = o(6362), l = "find-tool"; class c extends s.default { constructor(t) { super(t.notifier, t.localization.findLabel), this.editor = t, this.currentMatchIdx = 0, this.overlay = document.createElement("div"), this.fillOverlay(), t.createHTMLOverlay(this.overlay), this.overlay.style.display = "none", this.overlay.classList.add(`${l}-overlay`) } canReceiveInputInReadOnlyEditor() { return !0 } getMatches(t) { const e = t.toLocaleLowerCase(); return this.editor.image.getAllElements().filter((o => { let n = ""; if (o instanceof i.default) n = o.getText(); else { if (!(o instanceof r.default)) return !1; n = o.getAltText() ?? "" } const s = -1 !== n.toLocaleLowerCase().indexOf(e), a = -1 !== n.indexOf(t); return s || a })).map((t => t.getBBox())) } focusCurrentMatch() { const t = this.getMatches(this.searchInput.value); let e = this.currentMatchIdx % t.length; if (e < 0 && (e = t.length + e), e < t.length) { const o = !1; this.editor.dispatch(this.editor.viewport.zoomTo(t[e], !0, !0), o), this.editor.announceForAccessibility(this.editor.localization.focusedFoundText(e + 1, t.length)) } } toNextMatch() { this.currentMatchIdx++, this.focusCurrentMatch() } toPrevMatch() { this.currentMatchIdx--, this.focusCurrentMatch() } fillOverlay() { const t = document.createElement("label"); this.searchInput = document.createElement("input"); const e = document.createElement("button"), o = document.createElement("button"); this.searchInput.setAttribute("id", `${l}-searchInput-${Math.random()}`), t.htmlFor = this.searchInput.getAttribute("id"), t.innerText = this.editor.localization.findLabel, e.innerText = this.editor.localization.toNextMatch, o.innerText = this.editor.localization.closeDialog, this.searchInput.onkeydown = t => { "Enter" === t.key ? t.shiftKey ? this.toPrevMatch() : this.toNextMatch() : "Escape" === t.key ? this.setVisible(!1) : this.editor.shortcuts.matchesShortcut(a.toggleFindVisibleShortcutId, t) && (t.preventDefault(), this.toggleVisible()) }, e.onclick = () => { this.toNextMatch() }, o.onclick = () => { this.setVisible(!1) }, this.overlay.replaceChildren(t, this.searchInput, e, o) } isVisible() { return "none" !== this.overlay.style.display } setVisible(t) { t !== this.isVisible() && (this.overlay.style.display = t ? "block" : "none", t ? (this.searchInput.focus(), this.editor.announceForAccessibility(this.editor.localization.findDialogShown)) : (this.editor.focus(), this.editor.announceForAccessibility(this.editor.localization.findDialogHidden))) } toggleVisible() { this.setVisible(!this.isVisible()) } onKeyPress(t) { return !!this.editor.shortcuts.matchesShortcut(a.toggleFindVisibleShortcutId, t) && (this.toggleVisible(), !0) } setEnabled(t) { super.setEnabled(t), this.isEnabled() && this.setVisible(!1) } } e.default = c }, 272: function (t, e, o) { "use strict"; var n, i = this && this.__createBinding || (Object.create ? function (t, e, o, n) { void 0 === n && (n = o); var i = Object.getOwnPropertyDescriptor(e, o); i && !("get" in i ? !e.__esModule : i.writable || i.configurable) || (i = { enumerable: !0, get: function () { return e[o] } }), Object.defineProperty(t, n, i) } : function (t, e, o, n) { void 0 === n && (n = o), t[n] = e[o] }), r = this && this.__setModuleDefault || (Object.create ? function (t, e) { Object.defineProperty(t, "default", { enumerable: !0, value: e }) } : function (t, e) { t.default = e }), s = this && this.__importStar || (n = function (t) { return n = Object.getOwnPropertyNames || function (t) { var e = []; for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[e.length] = o); return e }, n(t) }, function (t) { if (t && t.__esModule) return t; var e = {}; if (null != t) for (var o = n(t), s = 0; s < o.length; s++)"default" !== o[s] && i(e, t, o[s]); return r(e, t), e }), a = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const l = o(7394), c = a(o(2388)), d = s(o(5043)), h = o(578); class u extends c.default { constructor() { super(), this.canShowContextMenu = !1, this.stationaryDetector = null, this.clickTolerance = 12 } canMakeLongPressMenuEvent(t) { const e = [h.PointerDevice.Touch]; return 1 === t.allPointers.length && e.includes(t.current.device) } onEvent(t) { const e = () => { if (!(0, l.isPointerEvt)(t)) return !1; if (this.canShowContextMenu) { if (this.emit({ kind: l.InputEvtType.ContextMenu, screenPos: t.current.screenPos, canvasPos: t.current.canvasPos })) return this.emit({ kind: l.InputEvtType.GestureCancelEvt }), !0 } return !1 }; if (t.kind === l.InputEvtType.PointerDownEvt) 1 === t.allPointers.length ? (this.canShowContextMenu = !0, this.contextMenuTriggerPointer = t.current, this.contextMenuStartPoint = t.current.screenPos, this.canMakeLongPressMenuEvent(t) && (this.stationaryDetector = new d.default(t.current, d.defaultStationaryDetectionConfig, e))) : this.canShowContextMenu = !1; else if (t.kind === l.InputEvtType.PointerMoveEvt) { if (this.canShowContextMenu) { this.stationaryDetector?.onPointerMove(t.current); const e = t.current.screenPos.minus(this.contextMenuStartPoint), o = this.clickTolerance; e.length() > o && (this.canShowContextMenu = !1) } } else if (t.kind === l.InputEvtType.PointerUpEvt && (this.stationaryDetector?.destroy(), this.contextMenuTriggerPointer?.id === t.current.id && this.contextMenuTriggerPointer.device === h.PointerDevice.RightButtonMouse && e())) return !0; return this.emit(t) } } e.default = u }, 2388: function (t, e) { "use strict"; var o, n = this && this.__classPrivateFieldSet || function (t, e, o, n, i) { if ("m" === n) throw new TypeError("Private method is not writable"); if ("a" === n && !i) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof e ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === n ? i.call(t, o) : i ? i.value = o : e.set(t, o), o }, i = this && this.__classPrivateFieldGet || function (t, e, o, n) { if ("a" === o && !n) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === o ? n : "a" === o ? n.call(t) : n ? n.value : e.get(t) }; Object.defineProperty(e, "__esModule", { value: !0 }); o = new WeakMap, e.default = class { constructor() { o.set(this, null) } setEmitListener(t) { n(this, o, t && "object" == typeof t ? e => t.onEvent(e) ?? !1 : t, "f") } emit(t) { return i(this, o, "f")?.call(this, t) ?? !1 } } }, 960: function (t, e, o) { "use strict"; var n, i, r = this && this.__classPrivateFieldGet || function (t, e, o, n) { if ("a" === o && !n) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === o ? n : "a" === o ? n.call(t) : n ? n.value : e.get(t) }, s = this && this.__classPrivateFieldSet || function (t, e, o, n, i) { if ("m" === n) throw new TypeError("Private method is not writable"); if ("a" === n && !i) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof e ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === n ? i.call(t, o) : i ? i.value = o : e.set(t, o), o }, a = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const l = a(o(2388)); class c extends l.default { constructor() { super(...arguments), n.set(this, null), i.set(this, null) } onEvent(t) { return null === r(this, n, "f") ? this.emit(t) : r(this, n, "f").onEvent(t) } addToTail(t) { r(this, i, "f") ? (r(this, i, "f").setEmitListener(t), s(this, i, t, "f")) : (s(this, n, t, "f"), s(this, i, r(this, n, "f"), "f")), r(this, i, "f").setEmitListener((t => this.emit(t))) } } n = new WeakMap, i = new WeakMap, e.default = c }, 3343: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = o(7394), r = n(o(2388)), s = o(5379), a = n(o(6398)); var l; !function (t) { t[t.IntertialStabilizer = 0] = "IntertialStabilizer" }(l || (l = {})); const c = { kind: l.IntertialStabilizer, mass: .4, springConstant: 100, frictionCoefficient: .28, maxPointDist: 10, inertiaFraction: .75, minSimilarityToFinalize: 0, velocityDecayFactor: .1 }; class d { constructor(t, e, o) { this.updatePointer = e, this.options = o, this.runLoop = !0, this.lastUpdateTime = 0, this.velocity = s.Vec2.zero, this.strokePoint = t, this.targetPoint = t, this.targetInterval = 10, this.loop() } async loop() { for (this.lastUpdateTime = performance.now(); this.runLoop;)this.update(!1), await (0, a.default)() } setTarget(t) { this.targetPoint = t } getNextVelocity(t) { const e = this.targetPoint.minus(this.strokePoint), o = e.times(this.options.springConstant), n = 10 * this.options.mass, i = this.velocity.normalizedOrZero().times(-this.options.frictionCoefficient * n), r = o.plus(i).times(1 / this.options.mass), s = this.options.velocityDecayFactor, a = this.velocity.times(1 - s).plus(r.times(t / 1e3)); return e.normalizedOrZero().times(a.length()).lerp(a, this.options.inertiaFraction) } update(t) { const e = performance.now(), o = e - this.lastUpdateTime, n = this.strokePoint.eq(this.targetPoint); if (o > this.targetInterval || t) { if (!n) { let t, n, i = 1; do { t = this.getNextVelocity(o / i), n = t.times(o / 1e3), i++ } while (n.magnitude() > this.options.maxPointDist && i < 10); for (let t = 0; t < i; t++)this.velocity = this.getNextVelocity(o / i), n = this.velocity.times(o / 1e3), this.strokePoint = this.strokePoint.plus(n), t < i - 1 && this.updatePointer(this.strokePoint, e) } if (this.lastUpdateTime = e, t || !n) return this.updatePointer(this.strokePoint, e) } return !1 } finish() { this.runLoop = !1; const t = this.targetPoint.minus(this.strokePoint); this.velocity.dot(t) > this.options.minSimilarityToFinalize && this.updatePointer(this.targetPoint, performance.now()) } cancel() { this.runLoop = !1 } } class h extends r.default { constructor(t, e = c) { super(), this.viewport = t, this.options = e, this.stabilizer = null, this.lastPointerEvent = null } mapPointerEvent(t) { return (0, i.isPointerEvt)(t) && t.kind !== i.InputEvtType.PointerUpEvt && (this.lastPointerEvent = t), t.kind === i.InputEvtType.GestureCancelEvt || t.allPointers.length > 1 || null === this.stabilizer ? this.emit(t) : (this.stabilizer.setTarget(t.current.screenPos), t.kind === i.InputEvtType.PointerMoveEvt ? this.stabilizer.update(!0) : t.kind === i.InputEvtType.PointerUpEvt ? (this.stabilizer.finish(), this.emit(t)) : this.emit(t)) } emitPointerMove(t, e) { if (!this.lastPointerEvent) return !1; const o = this.lastPointerEvent.current.withScreenPosition(t, this.viewport).withTimestamp(e), n = { kind: i.InputEvtType.PointerMoveEvt, current: o, allPointers: [o] }; return this.emit(n) } onEvent(t) { if ((0, i.isPointerEvt)(t) || t.kind === i.InputEvtType.GestureCancelEvt) { t.kind === i.InputEvtType.PointerDownEvt && (null === this.stabilizer ? this.stabilizer = new d(t.current.screenPos, ((t, e) => this.emitPointerMove(t, e)), this.options) : t.allPointers.length > 1 && (this.stabilizer.cancel(), this.stabilizer = null)); const e = this.mapPointerEvent(t); return t.kind !== i.InputEvtType.PointerUpEvt && t.kind !== i.InputEvtType.GestureCancelEvt || (this.stabilizer?.cancel(), this.stabilizer = null), e } return this.emit(t) } static fromEditor(t) { return new h(t.viewport) } } e.default = h }, 4212: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = o(7394), r = n(o(2388)), s = o(6362); class a extends r.default { constructor(t, e) { super(), this.shortcuts = t, this.viewport = e, this.snapToGridEnabled = !1, this.angleLockEnabled = !1, this.startPointCanvas = null } xyAxesSnap(t) { if (!this.startPointCanvas) return t; const e = this.viewport.canvasToScreen(this.startPointCanvas); return t.lockedToXYAxesScreen(e, this.viewport) } mapPointerEvent(t) { const e = e => t.allPointers.length > 1 ? e : this.snapToGridEnabled ? e.snappedToGrid(this.viewport) : this.angleLockEnabled && this.startPointCanvas ? this.xyAxesSnap(e) : e; return { kind: t.kind, current: e(t.current), allPointers: t.allPointers.map(e) } } onEvent(t) { const e = this.shortcuts; t.kind !== i.InputEvtType.PointerDownEvt && t.kind !== i.InputEvtType.PointerMoveEvt && t.kind !== i.InputEvtType.PointerUpEvt || (t.kind === i.InputEvtType.PointerDownEvt && (this.startPointCanvas = t.current.canvasPos), t = this.mapPointerEvent(t)); let o = this.emit(t); if (t.kind === i.InputEvtType.KeyUpEvent || !o && t.kind === i.InputEvtType.KeyPressEvent) { const n = t.kind === i.InputEvtType.KeyPressEvent; e.matchesShortcut(s.snapToGridKeyboardShortcutId, t) && (this.snapToGridEnabled = n, o = !0), e.matchesShortcut(s.lineLockKeyboardShortcutId, t) && (this.angleLockEnabled = n, o = !0) } return o } static fromEditor(t) { return new a(t.shortcuts, t.viewport) } } e.default = a }, 7955: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.PanZoomMode = void 0; const i = o(5379), r = o(578), s = o(2018), a = n(o(6398)), l = o(4093), c = n(o(8836)), d = o(6362); var h; !function (t) { t[t.OneFingerTouchGestures = 1] = "OneFingerTouchGestures", t[t.TwoFingerTouchGestures = 2] = "TwoFingerTouchGestures", t[t.RightClickDrags = 4] = "RightClickDrags", t[t.SinglePointerGestures = 8] = "SinglePointerGestures", t[t.Keyboard = 16] = "Keyboard", t[t.RotationLocked = 32] = "RotationLocked" }(h || (e.PanZoomMode = h = {})); class u { constructor(t, e, o) { this.initialVelocity = t, this.scrollBy = e, this.onComplete = o, this.running = !1, this.start() } async start() { if (this.running) return; this.currentVelocity = this.initialVelocity; let t = performance.now(); this.running = !0; for (this.currentVelocity.magnitude() > 5e3 && (this.currentVelocity = this.currentVelocity.normalized().times(5e3)); this.running && this.currentVelocity.magnitude() > 200;) { const e = performance.now(), o = (e - t) / 1e3; this.currentVelocity = this.currentVelocity.times(Math.pow(1 / 8, o)), this.scrollBy(this.currentVelocity.times(o)), await (0, a.default)(), t = e } this.running && this.stop() } getCurrentVelocity() { return this.running ? this.currentVelocity : null } stop() { this.running && (this.running = !1, this.onComplete()) } } class p extends c.default { constructor(t, e, o) { super(t.notifier, o), this.editor = t, this.mode = e, this.transform = null, this.initialRotationSnapAngle = .22, this.afterRotationStartSnapAngle = .07, this.pinchZoomStartThreshold = 1.08, this.lastPointerDownTimestamp = 0, this.initialTouchAngle = 0, this.initialViewportRotation = 0, this.initialViewportScale = 0, this.isScaling = !1, this.isRotating = !1, this.inertialScroller = null, this.velocity = null } canReceiveInputInReadOnlyEditor() { return !0 } computePinchData(t, e) { if (t.id < e.id) { const o = t; t = e, e = o } const o = e.screenPos.minus(t.screenPos), n = o.angle(), i = o.magnitude(); return { canvasCenter: e.canvasPos.plus(t.canvasPos).times(.5), screenCenter: e.screenPos.plus(t.screenPos).times(.5), angle: n, dist: i } } allPointersAreOfType(t, e) { return t.every((t => t.device === e)) } onPointerDown({ allPointers: t, current: e }) { let o = !1; const n = this.inertialScroller?.getCurrentVelocity() ?? i.Vec2.zero; this.inertialScroller?.stop(), this.velocity = n, this.lastPointerDownTimestamp = e.timeStamp; const s = this.allPointersAreOfType(t, r.PointerDevice.Touch), a = this.allPointersAreOfType(t, r.PointerDevice.RightButtonMouse); if (s && 2 === t.length && this.mode & h.TwoFingerTouchGestures) { const { screenCenter: e, angle: n, dist: i } = this.computePinchData(t[0], t[1]); this.lastTouchDist = i, this.startTouchDist = i, this.lastScreenCenter = e, this.initialTouchAngle = n, this.initialViewportRotation = this.editor.viewport.getRotationAngle(), this.initialViewportScale = this.editor.viewport.getScaleFactor(), this.isScaling = !1, this.isRotating = Math.abs(Math.sin(2 * this.initialViewportRotation)) > .001, o = !0 } else 1 === t.length && (this.mode & h.OneFingerTouchGestures && s || a && this.mode & h.RightClickDrags || this.mode & h.SinglePointerGestures) && (this.lastScreenCenter = t[0].screenPos, this.isScaling = !1, o = !0); return o && (this.lastTimestamp = performance.now(), this.transform ??= l.Viewport.transformBy(i.Mat33.identity), this.editor.display.setDraftMode(!0)), o } updateVelocity(t) { const e = t.minus(this.lastScreenCenter); let o = (performance.now() - this.lastTimestamp) / 1e3; if (0 === e.magnitude() && o < .1) return; if (0 === o) return; o = Math.max(o, .01); const n = e.times(1 / o); let i = n; this.velocity && (i = this.velocity.lerp(n, .5)), this.velocity = i } getCenterDelta(t) { return this.editor.viewport.screenToCanvasTransform.transformVec3(t.minus(this.lastScreenCenter)) } toSnappedRotationDelta(t) { let e = t - this.initialTouchAngle + this.initialViewportRotation; const o = Math.PI / 2, n = Math.round(e / o) * o, i = this.isRotating ? this.afterRotationStartSnapAngle : this.initialRotationSnapAngle; return Math.abs(e - n) < i && (e = n, 0 !== e && (e += 1e-4)), e - this.editor.viewport.getRotationAngle() } toSnappedScaleFactor(t) { const e = this.initialViewportScale * t / this.startTouchDist, o = this.editor.viewport.getScaleFactor(), n = Math.log(e) / Math.log(10), i = Math.round(n); return Math.abs(i - n) < .04 ? Math.pow(10, i) / o : t / this.lastTouchDist } handleTwoFingerMove(t) { const { screenCenter: e, canvasCenter: o, angle: n, dist: r } = this.computePinchData(t[0], t[1]), s = this.getCenterDelta(e); let a; if (a = this.isRotationLocked() ? 0 : this.toSnappedRotationDelta(n), Math.abs(a) > 1e-8 && (this.isRotating = !0), this.updateVelocity(e), !this.isScaling) { const t = r / this.startTouchDist, e = this.pinchZoomStartThreshold, o = 1 / this.pinchZoomStartThreshold; (t > e || t < o) && (this.isScaling = !0) } let c = 1; this.isScaling && (c = this.toSnappedScaleFactor(r), this.lastTouchDist = r); const d = i.Mat33.translation(s).rightMul(i.Mat33.scaling2D(c, o)).rightMul(i.Mat33.zRotation(a, o)); return this.lastScreenCenter = e, this.transform = l.Viewport.transformBy(this.transform.transform.rightMul(d)), d } handleOneFingerMove(t) { const e = this.getCenterDelta(t.screenPos), o = i.Mat33.translation(e); return this.transform = l.Viewport.transformBy(this.transform.transform.rightMul(o)), this.updateVelocity(t.screenPos), this.lastScreenCenter = t.screenPos, o } onPointerMove({ allPointers: t }) { this.transform ??= l.Viewport.transformBy(i.Mat33.identity); let e = i.Mat33.identity; 2 === t.length ? e = this.handleTwoFingerMove(t) : 1 === t.length && (e = this.handleOneFingerMove(t[0])), l.Viewport.transformBy(e).apply(this.editor), this.lastTimestamp = performance.now() } onPointerUp(t) { const e = () => { this.transform && (this.transform.unapply(this.editor), this.editor.dispatch(this.transform, !1)), this.editor.display.setDraftMode(!1), this.transform = null, this.velocity = i.Vec2.zero }; if (t.current.device === r.PointerDevice.Touch && 1 === t.allPointers.length && null !== this.velocity && t.current.timeStamp - this.lastPointerDownTimestamp > 30 && null !== this.velocity) { const o = this.velocity; this.updateVelocity(t.current.screenPos), o.magnitude() < this.velocity.magnitude() && (this.velocity = o), this.inertialScroller?.stop(), this.inertialScroller = new u(this.velocity, (t => { if (!this.transform) return; const e = this.editor.viewport.screenToCanvasTransform.transformVec3(t); this.transform.unapply(this.editor), this.transform = l.Viewport.transformBy(this.transform.transform.rightMul(i.Mat33.translation(e))), this.transform.apply(this.editor) }), e) } else e() } onGestureCancel() { this.inertialScroller?.stop(), this.velocity = i.Vec2.zero, this.transform?.unapply(this.editor), this.editor.display.setDraftMode(!1), this.transform = null } updateTransform(t, e = !1) { let o = t; this.transform && (o = this.transform.transform.rightMul(t)), this.transform?.unapply(this.editor), this.transform = l.Viewport.transformBy(o), this.transform.apply(this.editor), e && this.editor.announceForAccessibility(this.transform.description(this.editor, this.editor.localization)) } applyAndFinalizeTransform(t) { this.updateTransform(t, !0), this.transform = null } onWheel({ delta: t, screenPos: e }) { this.inertialScroller?.stop(), this.transform = l.Viewport.transformBy(i.Mat33.identity); const o = this.editor.viewport.screenToCanvas(e), n = this.editor.viewport.screenToCanvasTransform.transformVec3(i.Vec3.of(-t.x, -t.y, 0)); let r = t.z; r = 2 * Math.atan(r / 2); const s = i.Mat33.scaling2D(Math.max(.4, Math.min(Math.pow(1.04, -r), 4)), o).rightMul(i.Mat33.translation(n)); return this.applyAndFinalizeTransform(s), !0 } onKeyPress(t) { if (this.inertialScroller?.stop(), !(this.mode & h.Keyboard)) return !1; this.transform = l.Viewport.transformBy(i.Mat33.identity); let e = i.Vec2.zero, o = 1, n = 0; const r = this.editor.shortcuts; if (r.matchesShortcut(d.moveLeftKeyboardShortcutId, t)) e = i.Vec2.of(-1, 0); else if (r.matchesShortcut(d.moveRightKeyboardShortcutId, t)) e = i.Vec2.of(1, 0); else if (r.matchesShortcut(d.moveUpKeyboardShortcutId, t)) e = i.Vec2.of(0, -1); else if (r.matchesShortcut(d.moveDownKeyboardShortcutId, t)) e = i.Vec2.of(0, 1); else if (r.matchesShortcut(d.zoomInKeyboardShortcutId, t)) o = .5; else if (r.matchesShortcut(d.zoomOutKeyboardShortcutId, t)) o = 2; else if (r.matchesShortcut(d.rotateClockwiseKeyboardShortcutId, t)) n = 1; else { if (!r.matchesShortcut(d.rotateCounterClockwiseKeyboardShortcutId, t)) return !1; n = -1 } e = e.times(30), n *= Math.PI / 8, e = e.times(-1), n *= -1, o = 1 / o, 0 !== n && (n += 1e-4), this.isRotationLocked() && (n = 0); e = this.editor.viewport.screenToCanvasTransform.transformVec3(e); const s = this.editor.viewport.visibleRect.center, a = i.Mat33.scaling2D(o, s).rightMul(i.Mat33.zRotation(n, s)).rightMul(i.Mat33.translation(e)); return this.applyAndFinalizeTransform(a), !0 } isRotationLocked() { return !!(this.mode & h.RotationLocked) } setModeEnabled(t, e) { let o = this.mode; e ? o |= t : o &= ~t, this.setMode(o) } setMode(t) { t !== this.mode && (this.mode = t, this.editor.notifier.dispatch(s.EditorEventType.ToolUpdated, { kind: s.EditorEventType.ToolUpdated, tool: this })) } getMode() { return this.mode } } e.default = p }, 166: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(2170)), r = n(o(3604)), s = o(5379), a = n(o(8836)), l = n(o(7686)), c = n(o(4686)); class d extends a.default { constructor(t) { super(t.notifier, t.localization.pasteHandler), this.editor = t } onPaste(t) { const e = t.mime.toLowerCase(), o = (() => { if ("image/svg+xml" === e) return t.data; if ("text/html" !== e) return !1; if (!t.data.match(/^[^]{0,200}<svg.*/i)) return !1; let o = t.data.toLowerCase().lastIndexOf("</svg>"); return -1 === o && (o = t.data.length), t.data.substring(t.data.search(/<svg/i), o) })(); return o ? (this.doSVGPaste(o), !0) : "text/plain" === e ? (this.doTextPaste(t.data), !0) : ("image/png" === e || "image/jpeg" === e) && (this.doImagePaste(t.data), !0) } async addComponentsFromPaste(t) { await this.editor.addAndCenterComponents(t, !0, this.editor.localization.pasted(t.length)) } async doSVGPaste(t) { this.editor.showLoadingWarning(0); try { const e = r.default.fromString(t, !0), o = []; await e.start((t => { o.push(t) }), ((t, e) => null)), await this.addComponentsFromPaste(o) } finally { this.editor.hideLoadingWarning() } } async doTextPaste(t) { const e = this.editor.toolController.getMatchingTools(l.default); e.sort(((t, e) => !t.isEnabled() && e.isEnabled() ? -1 : !e.isEnabled() && t.isEnabled() ? 1 : 0)); const o = { size: 12, fontFamily: "sans", renderingStyle: { fill: s.Color4.red } }, n = e[0]?.getTextStyle() ?? o; if ("" === t.trim()) return; const r = t.split("\n"); await this.addComponentsFromPaste([i.default.fromLines(r, s.Mat33.identity, n)]) } async doImagePaste(t) { const e = new Image; e.src = t; const o = await c.default.fromImage(e, s.Mat33.identity); await this.addComponentsFromPaste([o]) } } e.default = d }, 9392: function (t, e, o) { "use strict"; var n, i = this && this.__createBinding || (Object.create ? function (t, e, o, n) { void 0 === n && (n = o); var i = Object.getOwnPropertyDescriptor(e, o); i && !("get" in i ? !e.__esModule : i.writable || i.configurable) || (i = { enumerable: !0, get: function () { return e[o] } }), Object.defineProperty(t, n, i) } : function (t, e, o, n) { void 0 === n && (n = o), t[n] = e[o] }), r = this && this.__setModuleDefault || (Object.create ? function (t, e) { Object.defineProperty(t, "default", { enumerable: !0, value: e }) } : function (t, e) { t.default = e }), s = this && this.__importStar || (n = function (t) { return n = Object.getOwnPropertyNames || function (t) { var e = []; for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[e.length] = o); return e }, n(t) }, function (t) { if (t && t.__esModule) return t; var e = {}; if (null != t) for (var o = n(t), s = 0; s < o.length; s++)"default" !== o[s] && i(e, t, o[s]); return r(e, t), e }), a = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const l = o(5379), c = a(o(7)), d = o(578), h = o(9177), u = o(2018), p = a(o(8836)), f = o(6362), m = o(6362), g = a(o(3343)), b = o(7988), y = s(o(5043)); class v extends p.default { constructor(t, e, o) { super(t.notifier, e), this.editor = t, this.builder = null, this.lastPoint = null, this.startPoint = null, this.currentDeviceType = null, this.currentPointerId = null, this.shapeAutocompletionEnabled = !1, this.autocorrectedShape = null, this.lastAutocorrectedShape = null, this.removedAutocorrectedShapeTime = 0, this.stationaryDetector = null, this.styleValue = b.ReactiveValue.fromInitialValue({ factory: h.makeFreehandLineBuilder, color: l.Color4.blue, thickness: 4, ...o }), this.styleValue.onUpdateAndNow((t => { this.style = t, this.noteUpdated() })) } getPressureMultiplier() { const t = this.style.thickness; return 1 / this.editor.viewport.getScaleFactor() * t } toStrokePoint(t) { let e = Math.max(t.pressure ?? 1, .3); isFinite(e) || (console.warn("Non-finite pressure!", t), e = .3), console.assert(isFinite(t.canvasPos.length()), "Non-finite canvas position!"), console.assert(isFinite(t.screenPos.length()), "Non-finite screen position!"), console.assert(isFinite(t.timeStamp), "Non-finite timeStamp on pointer!"); return { pos: t.canvasPos, width: e * this.getPressureMultiplier(), color: this.style.color, time: t.timeStamp } } previewStroke() { this.editor.clearWetInk(); const t = this.editor.display.getWetInkRenderer(); if (this.autocorrectedShape) { const e = this.editor.viewport.visibleRect; this.autocorrectedShape.render(t, e) } else this.builder?.preview(t) } addPointToStroke(t) { if (!this.builder) throw new Error("No stroke is currently being generated."); this.builder.addPoint(t), this.lastPoint = t, this.previewStroke() } onPointerDown(t) { if (this.builder && !this.eventCanCancelStroke(t)) return !0; const { current: e, allPointers: o } = t, n = e.device === d.PointerDevice.Eraser, i = e.device === d.PointerDevice.Pen; return !((1 !== o.length || n) && !i) && (this.startPoint = this.toStrokePoint(e), this.builder = this.style.factory(this.startPoint, this.editor.viewport), this.currentDeviceType = e.device, this.currentPointerId = e.id, this.shapeAutocompletionEnabled ? this.stationaryDetector = new y.default(e, y.defaultStationaryDetectionConfig, (t => this.autocorrectShape(t))) : this.stationaryDetector = null, this.lastAutocorrectedShape = null, this.removedAutocorrectedShapeTime = 0, !0) } eventCanCancelStroke(t) { const e = this.lastPoint?.time ?? 0; if (t.current.timeStamp - e > 1e3) return !0; const o = this.currentDeviceType === d.PointerDevice.Pen, n = t.current.device === d.PointerDevice.Touch; return !o || !n } eventCanBeDeliveredToNonActiveTool(t) { return this.eventCanCancelStroke(t) } onPointerMove({ current: t }) { if (!this.builder) return; if (t.device !== this.currentDeviceType) return; if (t.id !== this.currentPointerId) return; const e = this.stationaryDetector?.onPointerMove(t); e || (this.addPointToStroke(this.toStrokePoint(t)), this.autocorrectedShape && (this.removedAutocorrectedShapeTime = performance.now(), this.autocorrectedShape = null, this.editor.announceForAccessibility(this.editor.localization.autocorrectionCanceled))) } onPointerUp({ current: t }) { if (!this.builder) return !1; if (t.id !== this.currentPointerId) return !0; this.stationaryDetector?.onPointerUp(t); const e = this.toStrokePoint(t), o = { ...e, width: this.lastPoint?.width ?? e.width }; return this.addPointToStroke(o), this.finalizeStroke(), !1 } onGestureCancel() { this.builder = null, this.editor.clearWetInk(), this.stationaryDetector?.destroy(), this.stationaryDetector = null } removedAutocorrectedShapeRecently() { return this.removedAutocorrectedShapeTime > performance.now() - 320 } async autocorrectShape(t) { if (!this.builder || !this.builder.autocorrectShape) return; if (!this.shapeAutocompletionEnabled) return; if (this.autocorrectedShape) return; const e = await this.builder.autocorrectShape(); if (!this.builder || !e) return; const o = e.getBBox().area; if (0 === o || !isFinite(o)) return; const n = e.description(this.editor.localization); this.editor.announceForAccessibility(this.editor.localization.autocorrectedTo(n)), this.autocorrectedShape = e, this.lastAutocorrectedShape = e, this.previewStroke() } finalizeStroke() { if (this.builder) { this.lastAutocorrectedShape && this.removedAutocorrectedShapeRecently() && (this.autocorrectedShape = this.lastAutocorrectedShape); const t = this.autocorrectedShape ?? this.builder.build(); if (this.previewStroke(), t.getBBox().area > 0) { t === this.autocorrectedShape && this.editor.announceForAccessibility(this.editor.localization.autocorrectedTo(t.description(this.editor.localization))); const e = !0, o = c.default.addElement(t, e); this.editor.dispatch(o) } else console.warn("Pen: Not adding empty stroke", t, "to the canvas.") } this.builder = null, this.lastPoint = null, this.autocorrectedShape = null, this.lastAutocorrectedShape = null, this.editor.clearWetInk(), this.stationaryDetector?.destroy(), this.stationaryDetector = null } noteUpdated() { this.editor.notifier.dispatch(u.EditorEventType.ToolUpdated, { kind: u.EditorEventType.ToolUpdated, tool: this }) } setColor(t) { t.toHexString() !== this.style.color.toHexString() && this.styleValue.set({ ...this.style, color: t }) } setThickness(t) { t !== this.style.thickness && this.styleValue.set({ ...this.style, thickness: t }) } setStrokeFactory(t) { t !== this.style.factory && this.styleValue.set({ ...this.style, factory: t }) } setHasStabilization(t) { const e = !!this.getInputMapper(); t !== e && (e ? this.setInputMapper(null) : this.setInputMapper(new g.default(this.editor.viewport)), this.noteUpdated()) } setStrokeAutocorrectEnabled(t) { t !== this.shapeAutocompletionEnabled && (this.shapeAutocompletionEnabled = t, this.noteUpdated()) } getStrokeAutocorrectionEnabled() { return this.shapeAutocompletionEnabled } getThickness() { return this.style.thickness } getColor() { return this.style.color } getStrokeFactory() { return this.style.factory } getStyleValue() { return this.styleValue } onKeyPress(t) { const e = this.editor.shortcuts, o = e.matchesShortcut(f.undoKeyboardShortcutId, t); if (this.builder && o) return this.finalizeStroke(), !1; let n; return e.matchesShortcut(m.decreaseSizeKeyboardShortcutId, t) ? n = 2 * this.getThickness() / 3 : e.matchesShortcut(m.increaseSizeKeyboardShortcutId, t) && (n = 3 * this.getThickness() / 2), void 0 !== n && (n = Math.min(Math.max(1, n), 256), this.setThickness(n), !0) } } e.default = v }, 2870: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(8836)); class r extends i.default { constructor(t, e) { super(t.notifier, e), this.editor = t, this.colorPreviewListener = null, this.colorSelectListener = null, this.enabledValue().onUpdateAndNow((() => { this.updateSelectingStatus() })) } canReceiveInputInReadOnlyEditor() { return !0 } updateSelectingStatus() { const t = "pipette--color-selection-in-progress"; this.isEnabled() && this.colorSelectListener && this.colorPreviewListener ? this.editor.getRootElement().classList.add(t) : this.editor.getRootElement().classList.remove(t) } setColorListener(t, e) { this.colorPreviewListener = t, this.colorSelectListener = e, this.updateSelectingStatus() } clearColorListener() { this.colorPreviewListener = null, this.colorSelectListener = null, this.updateSelectingStatus() } onPointerDown({ current: t, allPointers: e }) { return !(!this.colorPreviewListener || 1 !== e.length) && (this.colorPreviewListener(this.editor.display.getColorAt(t.screenPos)), !0) } onPointerMove({ current: t }) { this.colorPreviewListener?.(this.editor.display.getColorAt(t.screenPos)) } onPointerUp({ current: t }) { this.colorSelectListener?.(this.editor.display.getColorAt(t.screenPos)) } onGestureCancel() { this.colorSelectListener?.(null) } } e.default = r }, 915: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = o(5379), r = o(2018), s = n(o(8836)); class a extends s.default { constructor(t) { super(t.notifier, "scrollbar"), this.editor = t, this.fadeOutTimeout = null, this.scrollbarOverlay = document.createElement("div"), this.scrollbarOverlay.classList.add("ScrollbarTool-overlay"), this.verticalScrollbar = document.createElement("div"), this.verticalScrollbar.classList.add("vertical-scrollbar"), this.horizontalScrollbar = document.createElement("div"), this.horizontalScrollbar.classList.add("horizontal-scrollbar"), this.scrollbarOverlay.replaceChildren(this.verticalScrollbar, this.horizontalScrollbar); let e = null, o = null; this.enabledValue().onUpdateAndNow((n => { e?.remove(), o?.remove(), o = null, e = null, n && (o = t.notifier.on(r.EditorEventType.ViewportChanged, (t => { this.updateScrollbars() })), this.updateScrollbars(), e = t.createHTMLOverlay(this.scrollbarOverlay)) })) } updateScrollbars() { const t = this.editor.viewport, e = t.getScreenRectSize(), o = new i.Rect2(0, 0, e.x, e.y), n = this.editor.getImportExportRect().transformedBoundingBox(t.canvasToScreenTransform).union(o), r = o.width / n.width * e.x, s = o.height / n.height * e.y, a = (o.x - n.x) / n.width * e.x, l = (o.y - n.y) / n.height * e.y; this.horizontalScrollbar.style.width = `${r}px`, this.verticalScrollbar.style.height = `${s}px`, this.horizontalScrollbar.style.marginLeft = `${a}px`, this.verticalScrollbar.style.marginTop = `${l}px`; const c = (t, e, o) => { const n = "represents-no-scroll"; Math.abs(e - o) < 1e-8 ? t.classList.add(n) : t.classList.remove(n) }; c(this.horizontalScrollbar, r, e.x), c(this.verticalScrollbar, s, e.y), null !== this.fadeOutTimeout && clearTimeout(this.fadeOutTimeout); this.fadeOutTimeout = setTimeout((() => { this.scrollbarOverlay.classList.remove("just-updated") }), 3e3), this.scrollbarOverlay.classList.add("just-updated") } } e.default = a }, 4209: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(8836)), r = o(6362), s = n(o(1172)); class a extends i.default { constructor(t) { super(t.notifier, t.localization.selectAllTool), this.editor = t } canReceiveInputInReadOnlyEditor() { return !0 } onKeyPress(t) { if (this.editor.shortcuts.matchesShortcut(r.selectAllKeyboardShortcut, t)) { const t = this.editor.toolController.getMatchingTools(s.default); if (t.length > 0) { const e = t[0]; return e.setEnabled(!0), e.setSelection(this.editor.image.getAllElements()), !0 } } return !1 } } e.default = a }, 5834: function (t, e, o) { "use strict"; var n, i, r = this && this.__createBinding || (Object.create ? function (t, e, o, n) { void 0 === n && (n = o); var i = Object.getOwnPropertyDescriptor(e, o); i && !("get" in i ? !e.__esModule : i.writable || i.configurable) || (i = { enumerable: !0, get: function () { return e[o] } }), Object.defineProperty(t, n, i) } : function (t, e, o, n) { void 0 === n && (n = o), t[n] = e[o] }), s = this && this.__setModuleDefault || (Object.create ? function (t, e) { Object.defineProperty(t, "default", { enumerable: !0, value: e }) } : function (t, e) { t.default = e }), a = this && this.__importStar || (n = function (t) { return n = Object.getOwnPropertyNames || function (t) { var e = []; for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[e.length] = o); return e }, n(t) }, function (t) { if (t && t.__esModule) return t; var e = {}; if (null != t) for (var o = n(t), i = 0; i < o.length; i++)"default" !== o[i] && r(e, t, o[i]); return s(e, t), e }), l = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const c = l(o(1434)), d = o(5379), h = a(o(5900)), u = o(1172), p = l(o(4093)), f = l(o(6188)), m = l(o(1247)), g = o(3615), b = o(6757), y = l(o(7)), v = l(o(2717)), x = l(o(8047)); class w { constructor(t, e, o) { this.editor = e, this.selectionTightBoundingBox = null, this.transform = d.Mat33.identity, this.selectedElems = [], this.hasParent = !0, this.removedFromImage = {}, this.activeHandle = null, this.backgroundDragging = !1, this.selectionDuplicatedAnimationTimeout = null, this.originalRegion = new d.Rect2(t.x, t.y, 0, 0), this.transformers = { drag: new g.DragTransformer(e, this), resize: new g.ResizeTransformer(e, this), rotate: new g.RotateTransformer(e, this) }, this.outerContainer = document.createElement("div"), this.outerContainer.classList.add(`${u.cssPrefix}selection-outer-container`), this.innerContainer = document.createElement("div"), this.innerContainer.classList.add(`${u.cssPrefix}selection-inner-container`), this.backgroundElem = document.createElement("div"), this.backgroundElem.classList.add(`${u.cssPrefix}selection-background`), this.innerContainer.appendChild(this.backgroundElem), this.outerContainer.appendChild(this.innerContainer); const n = (t, e) => { const o = { [b.ResizeMode.Both]: h.HandleAction.ResizeXY, [b.ResizeMode.HorizontalOnly]: h.HandleAction.ResizeX, [b.ResizeMode.VerticalOnly]: h.HandleAction.ResizeY }; return new h.default({ action: o[t], side: e }, this, this.editor.viewport, (e => this.transformers.resize.onDragStart(e, t)), (t => this.transformers.resize.onDragUpdate(t)), (() => this.transformers.resize.onDragEnd())) }, i = [n(b.ResizeMode.HorizontalOnly, d.Vec2.of(0, .5)), n(b.ResizeMode.HorizontalOnly, d.Vec2.of(1, .5))], r = n(b.ResizeMode.VerticalOnly, d.Vec2.of(.5, 1)), s = n(b.ResizeMode.Both, d.Vec2.of(1, 1)), a = new h.default({ action: h.HandleAction.Rotate, side: d.Vec2.of(.5, 0), icon: this.editor.icons.makeRotateIcon() }, this, this.editor.viewport, (t => this.transformers.rotate.onDragStart(t)), (t => this.transformers.rotate.onDragUpdate(t)), (() => this.transformers.rotate.onDragEnd())), l = new x.default(this, this.editor.viewport, o, this.editor.localization); this.childwidgets = [s, ...i, r, a, l]; for (const t of this.childwidgets) t.addTo(this.backgroundElem); this.updateUI() } getBackgroundElem() { return this.backgroundElem } getTransform() { return this.transform } get preTransformRegion() { return this.originalRegion } get region() { const t = d.Mat33.zRotation(this.regionRotation, this.originalRegion.center), e = this.transform.rightMul(t.inverse()); return this.originalRegion.transformedBoundingBox(e) } computeTightBoundingBox() { return this.selectedElems.reduce(((t, e) => (t ?? e.getBBox()).union(e.getBBox())), null) ?? d.Rect2.empty } get regionRotation() { return this.transform.transformVec3(d.Vec2.unitX).angle() } get preTransformedScreenRegion() { const t = t => this.editor.viewport.canvasToScreen(t); return d.Rect2.fromCorners(t(this.preTransformRegion.topLeft), t(this.preTransformRegion.bottomRight)) } get preTransformedScreenRegionRotation() { return this.editor.viewport.getRotationAngle() } getScreenRegion() { const t = this.editor.viewport.canvasToScreenTransform, e = this.editor.viewport.getScaleFactor(), o = t.transformVec2(this.region.center); return new d.Rect2(o.x, o.y, e * this.region.width, e * this.region.height).translatedBy(this.region.size.times(-e / 2)) } get screenRegionRotation() { return this.regionRotation + this.editor.viewport.getRotationAngle() } setTransform(t, e = !0) { this.transform = t, e && this.hasParent && this.previewTransformCmds() } getDeltaZIndexToMoveSelectionToTop() { if (0 === this.selectedElems.length) return 0; const t = this.selectedElems[0].getZIndex(), e = this.editor.image.getElementsIntersectingRegion(this.region); return (e[e.length - 1]?.getZIndex() ?? t) + 1 - t } finalizeTransform() { const t = this.transform, e = this.selectedElems; let o; if (this.originalRegion = this.originalRegion.transformedBoundingBox(this.transform), this.transform = d.Mat33.identity, this.scrollTo(), this.selectedElems.length > 0) { const n = this.getDeltaZIndexToMoveSelectionToTop(); o = this.editor.dispatch(new i.ApplyTransformationCommand(this, e, t, n)) } return o } sendToBack() { const t = this.editor.image.getElementsIntersectingRegion(this.editor.viewport.visibleRect), e = (t[0]?.getZIndex() ?? 0) - 1 - (this.selectedElems[this.selectedElems.length - 1]?.getZIndex() ?? 0); if (0 !== e) { const t = this.selectedElems.map((t => t.setZIndex(t.getZIndex() + e))); return (0, v.default)(t, 100) } return null } previewTransformCmds() { if (0 === this.selectedElems.length) return; if (this.selectedElems.length > 500) return void this.updateUI(); const t = this.editor.display.getWetInkRenderer(); t.clear(), t.pushTransform(this.transform); const e = this.editor.viewport.visibleRect.union(this.region).transformedBoundingBox(this.transform.inverse()); for (const o of this.selectedElems) o.render(t, e); t.popTransform(), this.updateUI() } resolveToObjects() { let t = !1; if (this.transform = d.Mat33.identity, 0 === this.region.w || 0 === this.region.h) { const e = this.editor.viewport.visibleRect.maxDimension / 200; this.originalRegion = d.Rect2.bboxOf(this.region.corners, e), t = !0 } return this.selectedElems = this.editor.image.getElementsIntersectingRegion(this.region).filter((t => t.intersectsRect(this.region) && t.isSelectable())), t && this.selectedElems.length > 0 && (this.selectedElems = [this.selectedElems[this.selectedElems.length - 1]]), !!this.recomputeRegion() && (this.updateUI(), !0) } recomputeRegion() { const t = this.computeTightBoundingBox(); return this.selectionTightBoundingBox = t, t ? (this.originalRegion = t, this.padRegion(), !0) : (this.cancelSelection(), !1) } padRegion() { const t = this.selectionTightBoundingBox ?? this.originalRegion, e = this.getMinCanvasSize(); if (t.w < e || t.h < e) { const o = e / 2; this.originalRegion = d.Rect2.bboxOf(t.corners, o), this.updateUI() } } getMinCanvasSize() { return 2 * (h.handleSize / this.editor.viewport.getScaleFactor()) } getSelectedItemCount() { return this.selectedElems.length } updateUI() { if (!this.hasParent) return; const t = this.getScreenRegion(); this.backgroundElem.style.marginLeft = `${t.topLeft.x}px`, this.backgroundElem.style.marginTop = `${t.topLeft.y}px`, this.backgroundElem.style.width = `${t.width}px`, this.backgroundElem.style.height = `${t.height}px`; const e = 180 * this.screenRegionRotation / Math.PI; this.backgroundElem.style.transform = `rotate(${e}deg)`, this.backgroundElem.style.transformOrigin = "center"; const o = `${u.cssPrefix}rotated-near-perpendicular`; Math.abs(Math.sin(this.screenRegionRotation)) > .5 ? this.innerContainer.classList.add(o) : this.innerContainer.classList.remove(o), 0 === t.width && 0 === t.height ? this.innerContainer.classList.add("-empty") : this.innerContainer.classList.remove("-empty"); for (const t of this.childwidgets) t.updatePosition(this.getScreenRegion()) } addRemoveSelectionFromImage(t) { if (t || !(this.selectedElems.length > 500)) { for (const e of this.selectedElems) { const o = this.editor.image.findParent(e); !t && o ? (this.removedFromImage[e.getId()] = !0, o.remove()) : !o && this.removedFromImage[e.getId()] && (y.default.addElement(e).apply(this.editor), this.removedFromImage[e.getId()] = !1, delete this.removedFromImage[e.getId()]) } this.editor.queueRerender().then((() => { if (t) { this.editor.display.getWetInkRenderer().clear() } else this.previewTransformCmds() })) } } removeDeletedElemsFromSelection() { this.selectedElems = this.selectedElems.filter((t => { const e = !!this.editor.image.findParent(t), o = this.removedFromImage[t.getId()]; return e || o })) } onDragStart(t) { document.getSelection()?.removeAllRanges(), this.activeHandle = null; let e = !1; this.backgroundDragging = !1, this.region.containsPoint(t.canvasPos) && (this.backgroundDragging = !0, e = !0); for (const o of this.childwidgets) o.containsPoint(t.canvasPos) && (this.activeHandle = o, this.backgroundDragging = !1, e = !0); return e && (this.removeDeletedElemsFromSelection(), this.addRemoveSelectionFromImage(!1)), this.activeHandle && this.activeHandle.handleDragStart(t), this.backgroundDragging && this.transformers.drag.onDragStart(t.canvasPos), e } onDragUpdate(t) { this.backgroundDragging && this.transformers.drag.onDragUpdate(t.canvasPos), this.activeHandle && this.activeHandle.handleDragUpdate(t) } onDragEnd() { this.backgroundDragging ? this.transformers.drag.onDragEnd() : this.activeHandle && this.activeHandle.handleDragEnd(), this.addRemoveSelectionFromImage(!0), this.backgroundDragging = !1, this.activeHandle = null, this.updateUI() } onDragCancel() { this.backgroundDragging = !1, this.activeHandle = null, this.setTransform(d.Mat33.identity), this.addRemoveSelectionFromImage(!0), this.updateUI() } scrollTo() { if (0 === this.selectedElems.length) return !1; const t = this.editor.viewport.getScreenRectSize(), e = new d.Rect2(0, 0, t.x, t.y), o = this.getScreenRegion(); if (!e.containsPoint(o.center)) { const t = o.center, n = e.getClosestPointOnBoundaryTo(t), i = this.editor.viewport.screenToCanvas(n), r = this.region.center, s = i.minus(r); return this.editor.dispatchNoAnnounce(p.default.transformBy(d.Mat33.translation(s.times(.5))), !1), this.editor.queueRerender().then((() => { this.previewTransformCmds() })), !0 } return !1 } deleteSelectedObjects() { return (this.backgroundDragging || this.activeHandle) && this.onDragEnd(), new f.default(this.selectedElems) } runSelectionDuplicatedAnimation() { this.selectionDuplicatedAnimationTimeout && clearTimeout(this.selectionDuplicatedAnimationTimeout); this.backgroundElem.style.animation = "400ms ease selection-duplicated-animation", this.selectionDuplicatedAnimationTimeout = setTimeout((() => { this.backgroundElem.style.animation = "", this.selectionDuplicatedAnimationTimeout = null }), 400) } async duplicateSelectedObjects() { const t = this.backgroundDragging || this.activeHandle; let e = null; if (t || this.runSelectionDuplicatedAnimation(), t) { const t = null, o = this.getDeltaZIndexToMoveSelectionToTop(); e = new i.ApplyTransformationCommand(t, this.selectedElems, this.transform, o), await e.apply(this.editor), this.addRemoveSelectionFromImage(!0) } const o = new m.default(this.selectedElems); return t && (await (e?.unapply(this.editor)), this.addRemoveSelectionFromImage(!1), this.previewTransformCmds(), this.updateUI()), o } setHandlesVisible(t) { t ? this.innerContainer.classList.remove("-hide-handles") : this.innerContainer.classList.add("-hide-handles") } addTo(t) { this.outerContainer.parentElement && this.outerContainer.remove(), t.appendChild(this.outerContainer), this.hasParent = !0 } setToPoint(t) { this.originalRegion = this.originalRegion.grownToPoint(t), this.selectionTightBoundingBox = null, this.updateUI() } cancelSelection() { this.outerContainer.parentElement && this.outerContainer.remove(), this.originalRegion = d.Rect2.empty, this.selectionTightBoundingBox = null, this.hasParent = !1 } setSelectedObjects(t, e) { this.addRemoveSelectionFromImage(!0), this.originalRegion = e, this.selectionTightBoundingBox = e, this.selectedElems = t.filter((t => t.isSelectable())), this.selectedElems.sort(((t, e) => t.getZIndex() - e.getZIndex())), this.padRegion(), this.updateUI() } getSelectedObjects() { return [...this.selectedElems] } } i = w, c.default.register("selection-tool-transform", ((t, e) => { const o = new d.Mat33(...t.transform), n = t.elems ?? [], r = parseInt(t.deltaZIndex ?? 0); return new i.ApplyTransformationCommand(null, n, o, r) })), w.ApplyTransformationCommand = class extends c.default { constructor(t, e, o, n) { super("selection-tool-transform"), this.selection = t, this.fullTransform = o, this.deltaZIndex = n; "string" == typeof e[0] ? this.selectedElemIds = e : (this.selectedElemIds = e.map((t => t.getId())), this.transformCommands = e.map((t => t.setZIndexAndTransformBy(this.fullTransform, t.getZIndex() + n)))) } resolveToElems(t, e) { this.transformCommands || (this.transformCommands = this.selectedElemIds.map((o => { const n = t.image.lookupElement(o); if (!n) return console.warn(`Unable to find element with ID, ${o}.`), null; let i = n.getZIndex(), r = n.getZIndex() + this.deltaZIndex; return e && (r = n.getZIndex(), i = n.getZIndex() - this.deltaZIndex), n.setZIndexAndTransformBy(this.fullTransform, r, i) })).filter((t => null !== t))) } async apply(t) { this.resolveToElems(t, !1), this.selection?.setTransform(this.fullTransform, !1), this.selection?.updateUI(), await t.asyncApplyCommands(this.transformCommands, 100), this.selection?.setTransform(d.Mat33.identity, !1), this.selection?.recomputeRegion(), this.selection?.updateUI() } async unapply(t) { this.resolveToElems(t, !0), this.selection?.setTransform(this.fullTransform.inverse(), !1), this.selection?.updateUI(), await t.asyncUnapplyCommands(this.transformCommands, 100, !0), this.selection?.setTransform(d.Mat33.identity, !1), this.selection?.recomputeRegion(), this.selection?.updateUI() } serializeToJSON() { return { elems: this.selectedElemIds, transform: this.fullTransform.toArray(), deltaZIndex: this.deltaZIndex } } description(t, e) { return e.transformedElements(this.selectedElemIds.length) } }, e.default = w }, 5900: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.handleSize = e.HandleAction = void 0; const n = o(7571), i = o(5379), r = o(1172); var s, a; !function (t) { t[t.Circle = 0] = "Circle", t[t.Square = 1] = "Square" }(s || (s = {})), function (t) { t.ResizeXY = "resize-xy", t.Rotate = "rotate", t.ResizeX = "resize-x", t.ResizeY = "resize-y" }(a || (e.HandleAction = a = {})), e.handleSize = 30; e.default = class { constructor(t, e, o, i, l, c) { this.presentation = t, this.parent = e, this.viewport = o, this.onDragStart = i, this.onDragUpdate = l, this.onDragEnd = c, this.dragLastPos = null, this.element = document.createElement("div"), this.element.classList.add(`${r.cssPrefix}handle`, `${r.cssPrefix}${t.action}`); const d = document.createElement("div"); d.classList.add(`${r.cssPrefix}content`), this.element.appendChild(d), this.parentSide = t.side; const h = t.icon; switch (h && (d.appendChild(h), h.classList.add("icon")), t.action === a.Rotate ? this.shape = s.Circle : this.shape = s.Square, this.shape) { case s.Circle: this.element.classList.add(`${r.cssPrefix}circle`); break; case s.Square: this.element.classList.add(`${r.cssPrefix}square`); break; default: (0, n.assertUnreachable)(this.shape) }this.updatePosition() } addTo(t) { t.appendChild(this.element) } remove() { this.element.remove() } getBBoxParentCoords() { const t = this.parent.getScreenRegion(), o = i.Vec2.of(e.handleSize, e.handleSize), n = t.size.scale(this.parentSide).minus(o.times(.5)); return new i.Rect2(n.x, n.y, o.x, o.y) } getBBoxCanvasCoords() { const t = this.parent.region, o = i.Vec2.of(e.handleSize, e.handleSize).times(1 / this.viewport.getScaleFactor()), n = t.size.scale(this.parentSide).minus(o.times(.5)); return new i.Rect2(n.x, n.y, o.x, o.y).translatedBy(t.topLeft) } updatePosition() { const t = this.getBBoxParentCoords(); this.element.style.marginLeft = `${t.topLeft.x}px`, this.element.style.marginTop = `${t.topLeft.y}px`, this.element.style.width = `${t.w}px`, this.element.style.height = `${t.h}px` } containsPoint(t) { const e = this.getBBoxCanvasCoords(), o = t.minus(e.center), n = e.size.x / 2; let i; return i = this.shape === s.Circle ? o.magnitude() <= n : Math.abs(o.x) <= n && Math.abs(o.y) <= n, i } handleDragStart(t) { return this.onDragStart(t.canvasPos), this.dragLastPos = t.canvasPos, !0 } handleDragUpdate(t) { this.dragLastPos && this.onDragUpdate(t.canvasPos) } handleDragEnd() { if (this.dragLastPos) return this.onDragEnd() } setSnapToGrid(t) { this.snapToGrid = t } isSnappingToGrid() { return this.snapToGrid } } }, 8047: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); const n = o(5379), i = o(1172); e.default = class { constructor(t, e, o, n) { this.parent = t, this.viewport = e, this.localization = n, this.lastDragPointer = null, this.element = document.createElement("div"), this.element.classList.add(`${i.cssPrefix}handle`, `${i.cssPrefix}selection-menu`), this.element.style.setProperty("--vertical-offset", "40px"), this.onClick = () => { const t = this.getBBoxCanvasCoords().center; o(t) }, this.initUI(), this.updatePosition() } initUI() { const t = document.createElement("button"); t.textContent = "...", t.ariaLabel = this.localization.selectionMenu__show, t.title = t.ariaLabel, t.onkeydown = t => { "Enter" === t.key && this.onClick() }, this.element.appendChild(t), requestAnimationFrame((() => { this.updatePosition() })) } addTo(t) { t.appendChild(this.element) } remove() { this.element.remove() } getElementScreenSize() { return n.Vec2.of(this.element.clientWidth, this.element.clientHeight) } getBBoxParentCoords() { const t = n.Vec2.of(0, -40), e = this.getElementScreenSize(); return new n.Rect2(t.x, t.y, e.x, e.y) } getBBoxCanvasCoords() { const t = this.parent.region, e = this.viewport.getSizeOfPixelOnCanvas(), o = this.getElementScreenSize().times(e), i = 40 / this.viewport.getScaleFactor(), r = n.Vec2.of(t.x, t.y - i); return new n.Rect2(r.x, r.y, o.x, o.y) } updatePosition() { const t = this.getBBoxParentCoords(); this.element.style.marginLeft = `${t.topLeft.x}px`, this.element.style.marginTop = `${t.topLeft.y}px` } containsPoint(t) { return this.getBBoxCanvasCoords().containsPoint(t) } handleDragStart(t) { return this.lastDragPointer = t, !0 } handleDragUpdate(t) { this.lastDragPointer = t } handleDragEnd() { this.lastDragPointer && this.containsPoint(this.lastDragPointer.canvasPos) && this.onClick(), this.lastDragPointer = null } } }, 1172: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.cssPrefix = void 0; const i = o(5379), r = o(2018), s = n(o(4093)), a = n(o(8836)), l = n(o(8748)), c = n(o(1598)), d = n(o(5834)), h = n(o(2170)), u = o(6362), p = n(o(7275)), f = n(o(5426)); e.cssPrefix = "selection-tool-"; class m extends a.default { constructor(t, e) { super(t.notifier, e), this.editor = t, this.rebuildSelectionScheduled = !1, this.startPoint = null, this.expandingSelectionBox = !1, this.shiftKeyPressed = !1, this.snapToGrid = !1, this.lastPointer = null, this.showContextMenu = async (t, e = !0) => { await (0, f.default)(this.selectionBox, this.editor, t, e, (() => this.clearSelection())) }, this.selectionBoxHandlingEvt = !1, this.lastSelectedObjects = [], this.hasUnfinalizedTransformFromKeyPress = !1, this.autoscroller = new p.default(t.viewport, (e => { if (t.dispatch(s.default.transformBy(i.Mat33.translation(e)), !1), this.lastPointer) { const e = this.lastPointer.withScreenPosition(this.lastPointer.screenPos, t.viewport); this.onMainPointerUpdated(e) } })), this.handleOverlay = document.createElement("div"), t.createHTMLOverlay(this.handleOverlay), this.handleOverlay.style.display = "none", this.handleOverlay.classList.add("handleOverlay"), t.notifier.on(r.EditorEventType.ViewportChanged, (t => { this.editor.clearWetInk(), this.expandingSelectionBox || this.selectionBox?.padRegion(), this.selectionBox?.updateUI() })), this.editor.handleKeyEventsFrom(this.handleOverlay), this.editor.handlePointerEventsFrom(this.handleOverlay) } makeSelectionBox(t) { this.prevSelectionBox = this.selectionBox, this.selectionBox = new d.default(t, this.editor, this.showContextMenu), this.expandingSelectionBox || this.prevSelectionBox?.cancelSelection(), this.selectionBox.addTo(this.handleOverlay) } snapSelectionToGrid() { if (!this.selectionBox) throw new Error("No selection to snap!"); const t = this.selectionBox.computeTightBoundingBox().topLeft, e = this.editor.viewport.snapToGrid(t).minus(t), o = this.selectionBox.getTransform(); this.selectionBox.setTransform(o.rightMul(i.Mat33.translation(e))), this.selectionBox.finalizeTransform() } onContextMenu(t) { const e = this.selectionBox?.getScreenRegion()?.containsPoint(t.screenPos); return this.showContextMenu(t.canvasPos, e), !0 } onPointerDown({ allPointers: t, current: e }) { const o = this.snapToGrid; if (o && (e = e.snappedToGrid(this.editor.viewport)), 1 === t.length) { this.startPoint = e.canvasPos; let t = !1; if (this.selectionBox) { o && this.snapSelectionToGrid(); this.selectionBox.onDragStart(e) && (t = !0, this.selectionBoxHandlingEvt = !0, this.expandingSelectionBox = !1) } return t ? this.autoscroller.start() : (this.expandingSelectionBox = this.shiftKeyPressed, this.rebuildSelectionScheduled = !0), !0 } return !1 } onPointerMove(t) { this.onMainPointerUpdated(t.current) } onMainPointerUpdated(t) { if (this.lastPointer = t, this.rebuildSelectionScheduled && (this.rebuildSelectionScheduled = !1, this.makeSelectionBox(this.startPoint ?? t.canvasPos), this.selectionBox?.setHandlesVisible(!1)), this.selectionBox) { if (this.autoscroller.onPointerMove(t.screenPos), !this.expandingSelectionBox && this.shiftKeyPressed && this.startPoint) { const e = this.editor.viewport.canvasToScreen(this.startPoint); t = t.lockedToXYAxesScreen(e, this.editor.viewport) } this.snapToGrid && (t = t.snappedToGrid(this.editor.viewport)), this.selectionBoxHandlingEvt ? this.selectionBox.onDragUpdate(t) : this.selectionBox.setToPoint(t.canvasPos) } } onPointerUp(t) { this.onMainPointerUpdated(t.current), this.autoscroller.stop(), this.selectionBox && (this.selectionBox.setHandlesVisible(!0), this.expandingSelectionBox && this.prevSelectionBox ? (this.expandingSelectionBox = !1, this.selectionBox.resolveToObjects(), this.setSelection([...this.selectionBox.getSelectedObjects(), ...this.prevSelectionBox.getSelectedObjects()])) : (this.selectionBoxHandlingEvt ? this.selectionBox.onDragEnd() : (this.selectionBox.resolveToObjects(), this.onSelectionUpdated()), this.selectionBoxHandlingEvt = !1, this.lastPointer = null)) } onGestureCancel() { this.autoscroller.stop(), this.selectionBoxHandlingEvt ? this.selectionBox?.onDragCancel() : this.rebuildSelectionScheduled || (this.selectionBox?.cancelSelection(), this.selectionBox = this.prevSelectionBox, this.selectionBox?.addTo(this.handleOverlay), this.selectionBox?.recomputeRegion(), this.prevSelectionBox = null), this.rebuildSelectionScheduled = !1, this.expandingSelectionBox = !1, this.lastPointer = null, this.selectionBoxHandlingEvt = !1 } onSelectionUpdated() { const t = this.selectionBox?.getSelectedItemCount() ?? 0, e = this.selectionBox?.getSelectedObjects() ?? []; (this.lastSelectedObjects.length !== t || e.some(((t, e) => this.lastSelectedObjects[e] !== t))) && (this.lastSelectedObjects = e, this.editor.notifier.dispatch(r.EditorEventType.ToolUpdated, { kind: r.EditorEventType.ToolUpdated, tool: this }), this.editor.notifier.dispatch(r.EditorEventType.SelectionUpdated, { kind: r.EditorEventType.SelectionUpdated, selectedComponents: e, tool: this }), t > 0 && (this.editor.announceForAccessibility(this.editor.localization.selectedElements(t)), this.zoomToSelection())), 0 === t && this.selectionBox && (this.selectionBox.cancelSelection(), this.prevSelectionBox = this.selectionBox, this.selectionBox = null) } zoomToSelection() { if (this.selectionBox) { const t = this.selectionBox.region; this.editor.dispatchNoAnnounce(this.editor.viewport.zoomTo(t, !1), !1) } } onKeyPress(t) { const e = this.editor.shortcuts; if (e.matchesShortcut(u.snapToGridKeyboardShortcutId, t)) return this.snapToGrid = !0, !0; if (this.selectionBox && (e.matchesShortcut(u.duplicateSelectionShortcut, t) || e.matchesShortcut(u.sendToBackSelectionShortcut, t))) return !0; if (e.matchesShortcut(u.selectAllKeyboardShortcut, t)) return this.setSelection(this.editor.image.getAllElements()), !0; if (t.ctrlKey) return !1; if ((t.shiftKey || "Shift" === t.key) && (this.shiftKeyPressed = !0, "Shift" === t.key)) return !0; let o = 0, n = 0, r = 0, a = 0, l = 0; e.matchesShortcut(u.translateLeftSelectionShortcutId, t) ? n -= 1 : e.matchesShortcut(u.translateRightSelectionShortcutId, t) ? n += 1 : e.matchesShortcut(u.translateUpSelectionShortcutId, t) ? r -= 1 : e.matchesShortcut(u.translateDownSelectionShortcutId, t) ? r += 1 : e.matchesShortcut(u.rotateClockwiseSelectionShortcutId, t) ? o += 1 : e.matchesShortcut(u.rotateCounterClockwiseSelectionShortcutId, t) ? o -= 1 : e.matchesShortcut(u.shrinkXSelectionShortcutId, t) ? a -= 1 : e.matchesShortcut(u.stretchXSelectionShortcutId, t) ? a += 1 : e.matchesShortcut(u.shrinkYSelectionShortcutId, t) ? l -= 1 : e.matchesShortcut(u.stretchYSelectionShortcutId, t) ? l += 1 : e.matchesShortcut(u.shrinkXYSelectionShortcutId, t) ? (a -= 1, l -= 1) : e.matchesShortcut(u.stretchXYSelectionShortcutId, t) && (a += 1, l += 1); let c = 0 !== n || 0 !== r || 0 !== o || 0 !== a || 0 !== l; if (this.selectionBox) { if (c) { const t = 10 * this.editor.viewport.getSizeOfPixelOnCanvas(), e = Math.PI / 8, c = 5 / 4, d = this.selectionBox.region, h = i.Vec2.of(c ** a, c ** l), u = i.Mat33.zRotation(o * e).mapEntries((t => s.default.roundScaleRatio(t))), p = this.editor.viewport.roundPoint(d.center), f = i.Mat33.scaling2D(h, this.editor.viewport.roundPoint(d.topLeft)).rightMul(i.Mat33.translation(p).rightMul(u).rightMul(i.Mat33.translation(p.times(-1)))).rightMul(i.Mat33.translation(this.editor.viewport.roundPoint(i.Vec2.of(n, r).times(t)))), m = this.selectionBox.getTransform(); this.selectionBox.setTransform(m.rightMul(f)), this.selectionBox.scrollTo(), this.hasUnfinalizedTransformFromKeyPress = !0 } } else c = !1; return !this.selectionBox || c || "Delete" !== t.key && "Backspace" !== t.key || (this.editor.dispatch(this.selectionBox.deleteSelectedObjects()), this.clearSelection(), c = !0), c } onKeyUp(t) { const e = this.editor.shortcuts; if (e.matchesShortcut(u.snapToGridKeyboardShortcutId, t)) return this.snapToGrid = !1, !0; if (e.matchesShortcut(u.selectAllKeyboardShortcut, t)) return !0; if (this.selectionBox && e.matchesShortcut(u.duplicateSelectionShortcut, t)) return this.selectionBox.duplicateSelectedObjects().then((t => { this.editor.dispatch(t) })), !0; if (this.selectionBox && e.matchesShortcut(u.sendToBackSelectionShortcut, t)) { const t = this.selectionBox.sendToBack(); return t && this.editor.dispatch(t), !0 } return !1 === t.shiftKey && (this.shiftKeyPressed = !1), "Shift" === t.key ? (this.shiftKeyPressed = !1, !0) : !this.hasUnfinalizedTransformFromKeyPress || !!this.selectionBox && (this.selectionBox.finalizeTransform(), this.hasUnfinalizedTransformFromKeyPress = !1, !0) } onCopy(t) { if (!this.selectionBox) return !1; const e = this.selectionBox.getSelectedObjects(), o = this.selectionBox.region; if (0 === e.length) return !1; const n = new s.default((() => { })); let r = this.selectionBox.getScreenRegion().size.times(this.editor.display.getDevicePixelRatio()).maximumEntryMagnitude() / (o.size.maximumEntryMagnitude() || 1); r = Math.pow(2, Math.ceil(Math.log2(r))), n.updateScreenSize(o.size.times(r)), n.resetTransform(i.Mat33.scaling2D(r).rightMul(i.Mat33.translation(o.topLeft.times(-1)))); const { element: a, renderer: d } = c.default.fromViewport(n, { sanitize: !0, useViewBoxForPositioning: !0 }), { element: u, renderer: p } = l.default.fromViewport(n, { maxCanvasDimen: 4096 }), f = []; for (const t of e) t.render(d), t.render(p), t instanceof h.default && f.push(t.getText()); return t.setData("image/svg+xml", a.outerHTML), t.setData("text/html", a.outerHTML), t.setData("image/png", new Promise(((t, e) => { u.toBlob((o => { o ? t(o) : e(new Error("Failed to convert canvas to blob.")) }), "image/png") }))), f.length > 0 && t.setData("text/plain", f.join("\n")), !0 } setEnabled(t) { const e = this.isEnabled(); super.setEnabled(t), e !== t && (this.selectionBox?.cancelSelection(), this.onSelectionUpdated(), this.handleOverlay.replaceChildren(), this.selectionBox = null, this.shiftKeyPressed = !1, this.snapToGrid = !1, this.handleOverlay.style.display = t ? "block" : "none", t ? (this.handleOverlay.tabIndex = 0, this.handleOverlay.setAttribute("aria-label", this.editor.localization.selectionToolKeyboardShortcuts)) : this.handleOverlay.tabIndex = -1) } getSelection() { return this.selectionBox } getSelectedObjects() { return this.selectionBox?.getSelectedObjects() ?? [] } setSelection(t) { (t = t.filter((t => t.isSelectable()))).sort(((t, e) => t.getZIndex() - e.getZIndex())), t = t.filter(((e, o) => !(o > 0) || e !== t[o - 1])); let e = null; for (const o of t) e = e ? e.union(o.getBBox()) : o.getBBox(); e && (this.clearSelection(), this.selectionBox || this.makeSelectionBox(e.topLeft), this.selectionBox.setSelectedObjects(t, e), this.onSelectionUpdated()) } clearSelection() { this.handleOverlay.replaceChildren(), this.prevSelectionBox = this.selectionBox, this.selectionBox = null, this.onSelectionUpdated() } } e.default = m }, 7275: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = o(5379), r = n(o(6398)); e.default = class { constructor(t, e) { this.viewport = t, this.scrollByCanvasDelta = e, this.started = !1, this.updateLoopId = 0, this.updateLoopRunning = !1, this.targetPoint = null, this.scrollRate = 1e3 } getScrollForPoint(t) { const e = this.viewport.getScreenRectSize(), o = new i.Rect2(0, 0, e.x, e.y).grownBy(-44); if (o.containsPoint(t)) return i.Vec2.zero; const n = o.getClosestPointOnBoundaryTo(t), r = n.distanceTo(t), s = n.minus(t), a = Math.min(r / 44, 1.25); return s.normalizedOrZero().times(a) } start() { this.started = !0 } onPointerMove(t) { this.started && (this.getScrollForPoint(t) === i.Vec2.zero ? this.stopUpdateLoop() : (this.targetPoint = t, this.startUpdateLoop())) } stop() { this.targetPoint = null, this.started = !1, this.stopUpdateLoop() } startUpdateLoop() { this.updateLoopRunning || (async () => { this.updateLoopId++; const t = this.updateLoopId; let e = performance.now(); for (; this.updateLoopId === t && this.targetPoint;) { this.updateLoopRunning = !0; const t = performance.now(), o = t - e, n = this.getScrollForPoint(this.targetPoint).times(this.scrollRate * o / 1e3); this.scrollByCanvasDelta(this.viewport.screenToCanvasTransform.transformVec3(n)), e = t, await (0, r.default)() } this.updateLoopRunning = !1 })() } stopUpdateLoop() { this.updateLoopId++ } } }, 3615: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.RotateTransformer = e.ResizeTransformer = e.DragTransformer = void 0; const i = o(5379), r = n(o(4093)), s = o(6757); e.DragTransformer = class { constructor(t, e) { this.editor = t, this.selection = e } onDragStart(t) { this.selection.setTransform(i.Mat33.identity), this.dragStartPoint = t } onDragUpdate(t) { const e = this.editor.viewport.roundPoint(t.minus(this.dragStartPoint)); this.selection.setTransform(i.Mat33.translation(e)) } onDragEnd() { return this.selection.finalizeTransform() } }; e.ResizeTransformer = class { constructor(t, e) { this.editor = t, this.selection = e, this.mode = s.ResizeMode.Both } onDragStart(t, e) { this.selection.setTransform(i.Mat33.identity), this.mode = e, this.dragStartPoint = t, this.computeOriginAndScaleRate() } computeOriginAndScaleRate() { const t = this.selection.preTransformRegion, e = t.corners; let o = 0; for (let t = 0; t < e.length; t++) { const n = e[t], i = this.dragStartPoint.minus(n).magnitudeSquared(); i > o && (o = i, this.transformOrigin = n) } let n = 1, r = 1; this.transformOrigin.x > t.center.x && (n = -1), this.transformOrigin.y > t.center.y && (r = -1), this.scaleRate = i.Vec2.of(n, r) } onDragUpdate(t) { const e = t.minus(this.dragStartPoint), o = this.selection.preTransformRegion.width, n = this.selection.preTransformRegion.height; let a = i.Vec2.of(1, 1); if (this.mode === s.ResizeMode.HorizontalOnly) { const t = o + e.x * this.scaleRate.x; a = i.Vec2.of(t / o, a.y) } if (this.mode === s.ResizeMode.VerticalOnly) { const t = n + e.y * this.scaleRate.y; a = i.Vec2.of(a.x, t / n) } if (this.mode === s.ResizeMode.Both) { const t = o + (Math.abs(e.x) > Math.abs(e.y) ? e.x : e.y); a = i.Vec2.of(t / o, t / o) } if (a = a.map((t => r.default.roundScaleRatio(t, 2))), 0 !== a.x && 0 !== a.y) { const t = this.editor.viewport.roundPoint(this.transformOrigin); this.selection.setTransform(i.Mat33.scaling2D(a, t)) } } onDragEnd() { return this.selection.finalizeTransform() } }; e.RotateTransformer = class { constructor(t, e) { this.editor = t, this.selection = e, this.startAngle = 0, this.targetRotation = 0, this.maximumDistFromStart = 0 } getAngle(t) { const e = this.selection.preTransformRegion.center; return t.minus(e).angle() } roundAngle(t) { const e = 8 / Math.PI; return Math.round(t * e) / e } onDragStart(t) { this.startPoint = t, this.selection.setTransform(i.Mat33.identity), this.startAngle = this.getAngle(t), this.targetRotation = 0, this.maximumDistFromStart = 0, this.startTime = performance.now() } setRotationTo(t) { const e = this.editor.viewport.roundPoint(this.selection.preTransformRegion.center), o = i.Mat33.zRotation(t).mapEntries((t => r.default.roundScaleRatio(t))), n = i.Mat33.translation(e).rightMul(o).rightMul(i.Mat33.translation(e.times(-1))); this.selection.setTransform(n) } onDragUpdate(t) { this.targetRotation = this.roundAngle(this.getAngle(t) - this.startAngle), this.setRotationTo(this.targetRotation); const e = t.minus(this.startPoint).magnitude(); e > this.maximumDistFromStart && (this.maximumDistFromStart = e) } onDragEnd() { return (performance.now() - this.startTime) / 1e3 < .4 && this.maximumDistFromStart < 10 && 0 === this.targetRotation && this.setRotationTo(-Math.PI / 2), this.selection.finalizeTransform() } } }, 8561: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.stretchXYSelectionShortcutId = e.shrinkXYSelectionShortcutId = e.stretchYSelectionShortcutId = e.shrinkYSelectionShortcutId = e.stretchXSelectionShortcutId = e.shrinkXSelectionShortcutId = e.rotateClockwiseSelectionShortcutId = e.rotateCounterClockwiseSelectionShortcutId = e.translateDownSelectionShortcutId = e.translateUpSelectionShortcutId = e.translateRightSelectionShortcutId = e.translateLeftSelectionShortcutId = e.sendToBackSelectionShortcut = e.duplicateSelectionShortcut = e.selectAllKeyboardShortcut = void 0; const i = n(o(5577)); e.selectAllKeyboardShortcut = "jsdraw.tools.SelectionTool.selectAll", i.default.registerDefaultKeyboardShortcut(e.selectAllKeyboardShortcut, ["CtrlOrMeta+KeyA"], "Select all"), e.duplicateSelectionShortcut = "jsdraw.tools.SelectionTool.duplicateSelection", i.default.registerDefaultKeyboardShortcut(e.duplicateSelectionShortcut, ["CtrlOrMeta+KeyD"], "Duplicate selection"), e.sendToBackSelectionShortcut = "jsdraw.tools.SelectionTool.sendToBack", i.default.registerDefaultKeyboardShortcut(e.sendToBackSelectionShortcut, ["End"], "Send to back"), e.translateLeftSelectionShortcutId = "jsdraw.tools.SelectionTool.translateLeft", i.default.registerDefaultKeyboardShortcut(e.translateLeftSelectionShortcutId, ["KeyA", "KeyH", "ArrowLeft"], "Move selection left"), e.translateRightSelectionShortcutId = "jsdraw.tools.SelectionTool.translateRight", i.default.registerDefaultKeyboardShortcut(e.translateRightSelectionShortcutId, ["KeyD", "KeyL", "ArrowRight"], "Move selection right"), e.translateUpSelectionShortcutId = "jsdraw.tools.SelectionTool.translateUp", i.default.registerDefaultKeyboardShortcut(e.translateUpSelectionShortcutId, ["KeyQ", "KeyK", "ArrowUp"], "Move selection up"), e.translateDownSelectionShortcutId = "jsdraw.tools.SelectionTool.translateDown", i.default.registerDefaultKeyboardShortcut(e.translateDownSelectionShortcutId, ["KeyE", "KeyJ", "ArrowDown"], "Move selection down"), e.rotateCounterClockwiseSelectionShortcutId = "jsdraw.tools.SelectionTool.rotateCCW", i.default.registerDefaultKeyboardShortcut(e.rotateCounterClockwiseSelectionShortcutId, ["Shift+KeyR"], "Rotate selection counter clockwise"), e.rotateClockwiseSelectionShortcutId = "jsdraw.tools.SelectionTool.rotateCW", i.default.registerDefaultKeyboardShortcut(e.rotateClockwiseSelectionShortcutId, ["KeyR"], "Rotate selection clockwise"), e.shrinkXSelectionShortcutId = "jsdraw.tools.SelectionTool.shrink.x", i.default.registerDefaultKeyboardShortcut(e.shrinkXSelectionShortcutId, ["KeyI"], "Decrease width"), e.stretchXSelectionShortcutId = "jsdraw.tools.SelectionTool.stretch.x", i.default.registerDefaultKeyboardShortcut(e.stretchXSelectionShortcutId, ["Shift+KeyI"], "Increase width"), e.shrinkYSelectionShortcutId = "jsdraw.tools.SelectionTool.shrink.y", i.default.registerDefaultKeyboardShortcut(e.shrinkYSelectionShortcutId, ["KeyO"], "Decrease height"), e.stretchYSelectionShortcutId = "jsdraw.tools.SelectionTool.stretch.y", i.default.registerDefaultKeyboardShortcut(e.stretchYSelectionShortcutId, ["Shift+KeyO"], "Increase height"), e.shrinkXYSelectionShortcutId = "jsdraw.tools.SelectionTool.shrink.xy", i.default.registerDefaultKeyboardShortcut(e.shrinkXYSelectionShortcutId, ["Comma"], "Decrease selection size"), e.stretchXYSelectionShortcutId = "jsdraw.tools.SelectionTool.stretch.xy", i.default.registerDefaultKeyboardShortcut(e.stretchXYSelectionShortcutId, ["Period"], "Increase selection size") }, 6757: (t, e) => { "use strict"; var o, n; Object.defineProperty(e, "__esModule", { value: !0 }), e.TransformMode = e.ResizeMode = void 0, function (t) { t[t.Both = 0] = "Both", t[t.HorizontalOnly = 1] = "HorizontalOnly", t[t.VerticalOnly = 2] = "VerticalOnly" }(o || (e.ResizeMode = o = {})), function (t) { t[t.Snap = 0] = "Snap", t[t.NoSnap = 1] = "NoSnap" }(n || (e.TransformMode = n = {})) }, 9854: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(8816)), r = n(o(9988)); e.default = t => { const e = e => { const o = (0, i.default)(t, { title: t.localization.copyPasteError__heading, classNames: ["clipboard-error-dialog"] }); o.appendChild(document.createTextNode(t.localization.copyPasteError__description)); const n = document.createElement("details"), r = document.createElement("summary"); return r.textContent = t.localization.copyPasteError__errorDetails, n.appendChild(r), n.appendChild(document.createTextNode(`Error: ${e}`)), o.appendChild(n), o }; return { onCopyError(o) { const n = e(o), i = document.createElement("label"); i.textContent = t.localization.copyPasteError__copyRetry; const s = document.createElement("textarea"); i.appendChild(s); const a = new r.default(t), l = t => (t.preventDefault(), a.copy(t).then((() => { n.close() }))); s.oncopy = l, s.ondragstart = l, s.value = t.localization.copyPasteError__copyMe, n.appendChild(i), s.select(), document.execCommand("copy") }, onPasteError(o) { const n = e(o), i = document.createElement("label"); i.textContent = t.localization.copyPasteError__pasteRetry; const s = document.createElement("textarea"); i.appendChild(s); const a = new r.default(t), l = t => (t.preventDefault(), a.paste(t).then((t => { t && n.close() }))); s.onpaste = l, s.ondrop = l, n.appendChild(i), s.focus(), document.execCommand("paste") } } } }, 5426: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(6665)), r = n(o(9988)), s = n(o(9854)); e.default = async (t, e, o, n, a) => { const l = e.localization, c = t?.getSelectedItemCount() && n, d = [{ text: l.selectionMenu__paste, icon: () => e.icons.makePasteIcon(), key: () => { new r.default(e, (0, s.default)(e)).paste() } }], h = await (0, i.default)(e, o, c ? [{ text: l.selectionMenu__duplicate, icon: () => e.icons.makeDuplicateSelectionIcon(), key: async () => { await e.dispatch(await t.duplicateSelectedObjects()) } }, { text: l.selectionMenu__delete, icon: () => e.icons.makeDeleteSelectionIcon(), key: async () => { await e.dispatch(t.deleteSelectedObjects()), a() } }, { text: l.selectionMenu__copyToClipboard, icon: () => e.icons.makeCopyIcon(), key: () => { new r.default(e, (0, s.default)(e)).copy() } }, ...d] : d); h?.() } }, 340: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = o(5379), r = n(o(8836)); class s { constructor() { if (this.closed = !1, !window.AudioContext) return console.warn("Accessibility sound UI: Unable to open AudioContext."), void (this.closed = !0); this.ctx = new AudioContext, this.colorOscHue = this.ctx.createOscillator(), this.colorOscValue = this.ctx.createOscillator(), this.colorOscSaturation = this.ctx.createOscillator(), this.colorOscHue.type = "triangle", this.colorOscSaturation.type = "sine", this.colorOscValue.type = "sawtooth", this.valueGain = this.ctx.createGain(), this.colorOscValue.connect(this.valueGain), this.valueGain.gain.setValueAtTime(.18, this.ctx.currentTime), this.colorGain = this.ctx.createGain(), this.colorOscHue.connect(this.colorGain), this.valueGain.connect(this.colorGain), this.colorOscSaturation.connect(this.colorGain), this.colorGain.connect(this.ctx.destination), this.boundaryGain = this.ctx.createGain(), this.boundaryOsc = this.ctx.createOscillator(), this.boundaryOsc.type = "sawtooth", this.boundaryGain.gain.setValueAtTime(0, this.ctx.currentTime), this.boundaryOsc.connect(this.boundaryGain), this.boundaryGain.connect(this.ctx.destination), this.colorOscHue.start(), this.colorOscSaturation.start(), this.colorOscValue.start(), this.boundaryOsc.start(), this.pause() } pause() { this.closed || (this.colorGain.gain.setValueAtTime(0, this.ctx.currentTime), this.ctx.suspend()) } play() { this.closed || this.ctx.resume() } setColor(t) { const e = t.asHSV(), o = 220 * -Math.cos(e.x / 2) + 440, n = 440 * e.y + 220, i = 440 * (e.z + .1), r = .25 * Math.min(1, t.a) / (1 + Math.exp(3 * -(e.z - .5))); this.colorOscHue.frequency.setValueAtTime(o, this.ctx.currentTime), this.colorOscSaturation.frequency.setValueAtTime(n, this.ctx.currentTime), this.colorOscValue.frequency.setValueAtTime(i, this.ctx.currentTime), this.valueGain.gain.setValueAtTime(.4 * (1 - e.z), this.ctx.currentTime), this.colorGain.gain.setValueAtTime(r, this.ctx.currentTime) } announceBoundaryCross(t) { this.boundaryGain.gain.cancelScheduledValues(this.ctx.currentTime), this.boundaryGain.gain.setValueAtTime(0, this.ctx.currentTime), this.boundaryGain.gain.linearRampToValueAtTime(.018, this.ctx.currentTime + .1), this.boundaryOsc.frequency.setValueAtTime(440 + 100 * Math.atan(t / 2), this.ctx.currentTime), this.boundaryGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + .25) } close() { this.ctx.close(), this.closed = !0 } } class a extends r.default { constructor(t, e) { super(t.notifier, e), this.editor = t, this.soundFeedback = null, this.toggleButtonContainer = document.createElement("div"), this.toggleButtonContainer.classList.add("js-draw-sound-ui-toggle"), this.toggleButton = document.createElement("button"), this.toggleButton.onclick = () => { this.setEnabled(!this.isEnabled()) }, this.toggleButtonContainer.appendChild(this.toggleButton), this.updateToggleButtonText(), t.createHTMLOverlay(this.toggleButtonContainer) } canReceiveInputInReadOnlyEditor() { return !0 } updateToggleButtonText() { const t = "sound-ui-tool-enabled"; this.isEnabled() ? (this.toggleButton.innerText = this.editor.localization.disableAccessibilityExploreTool, this.toggleButtonContainer.classList.add(t)) : (this.toggleButton.innerText = this.editor.localization.enableAccessibilityExploreTool, this.toggleButtonContainer.classList.remove(t)) } setEnabled(t) { super.setEnabled(t), this.isEnabled() ? this.editor.announceForAccessibility(this.editor.localization.soundExplorerUsageAnnouncement) : (this.soundFeedback?.close(), this.soundFeedback = null), this.updateToggleButtonText() } onKeyPress(t) { return "Escape" === t.code && (this.setEnabled(!1), !0) } onPointerDown({ current: t, allPointers: e }) { return this.soundFeedback || (this.soundFeedback = new s), !(e.length >= 2) && (this.soundFeedback?.play(), this.soundFeedback?.setColor(this.editor.display.getColorAt(t.screenPos) ?? i.Color4.black), this.lastPointerPos = t.canvasPos, !0) } onPointerMove({ current: t }) { this.soundFeedback?.setColor(this.editor.display.getColorAt(t.screenPos) ?? i.Color4.black); const e = new i.LineSegment2(this.lastPointerPos, t.canvasPos), o = this.editor.image.getElementsIntersectingRegion(e.bbox).filter((t => t.intersects(e))); this.lastPointerPos = t.canvasPos, o.length > 0 && this.soundFeedback?.announceBoundaryCross(o.length) } onPointerUp(t) { this.soundFeedback?.pause() } onGestureCancel() { this.soundFeedback?.pause() } } e.default = a }, 7686: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(2170)), r = n(o(7)), s = o(5379), a = o(578), l = o(2018), c = n(o(8836)), d = n(o(6188)), h = n(o(2717)), u = o(7988), p = "textEditorOverlay"; class f extends c.default { constructor(t, e, o) { super(t.notifier, e), this.editor = t, this.localizationTable = o, this.textInputElem = null, this.textMeasuringCtx = null, this.removeExistingCommand = null; const n = t.getCurrentSettings().text?.fonts ?? []; this.textStyleValue = u.ReactiveValue.fromInitialValue({ size: 32, fontFamily: n.length > 0 ? n[0] : "sans-serif", renderingStyle: { fill: s.Color4.purple } }), this.textStyleValue.onUpdateAndNow((() => { this.textStyle = this.textStyleValue.get(), this.updateTextInput(), this.editor.notifier.dispatch(l.EditorEventType.ToolUpdated, { kind: l.EditorEventType.ToolUpdated, tool: this }) })), this.contentTransform = u.ReactiveValue.fromInitialValue(s.Mat33.identity), this.textEditOverlay = document.createElement("div"), this.textEditOverlay.classList.add(p), this.editor.addStyleSheet(`\n\t\t\t.${p} textarea {\n\t\t\t\tbackground-color: rgba(0, 0, 0, 0);\n\n\t\t\t\twhite-space: pre;\n\t\t\t\toverflow: hidden;\n\n\t\t\t\tpadding: 0;\n\t\t\t\tmargin: 0;\n\t\t\t\tborder: none;\n\t\t\t\tpadding: 0;\n\n\t\t\t\tmin-width: 100px;\n\t\t\t\tmin-height: 1.1em;\n\t\t\t}\n\t\t`), this.anchorControl = this.editor.anchorElementToCanvas(this.textEditOverlay, this.contentTransform) } initTextMeasuringCanvas() { this.textMeasuringCtx ??= document.createElement("canvas").getContext("2d") } getTextAscent(t, e) { if (this.initTextMeasuringCanvas(), this.textMeasuringCtx) { this.textMeasuringCtx.textBaseline = "alphabetic", i.default.applyTextStyles(this.textMeasuringCtx, e); const o = this.textMeasuringCtx.measureText(t); return o.fontBoundingBoxAscent ?? o.actualBoundingBoxAscent } return 2 * e.size / 3 } flushInput(t = !0) { if (!this.textInputElem) return; const e = this.textEditOverlay.parentElement, o = s.Vec2.of(e?.scrollLeft ?? 0, e?.scrollTop ?? 0), n = this.textInputElem.value.trimEnd(); if (this.textInputElem.value = "", t) { const t = this.textInputElem; this.textInputElem = null, t.remove() } if ("" !== n) { const t = o.times(-1), e = this.editor.viewport.screenToCanvasTransform.transformVec3(t), a = s.Mat33.translation(e), l = i.default.fromLines(n.split("\n"), a.rightMul(this.contentTransform.get()), this.textStyle), c = r.default.addElement(l); this.removeExistingCommand ? (this.removeExistingCommand.unapply(this.editor), this.editor.dispatch((0, h.default)([this.removeExistingCommand, c])), this.removeExistingCommand = null) : this.editor.dispatch(c) } } updateTextInput() { if (!this.textInputElem) return; this.textInputElem.placeholder = this.localizationTable.enterTextToInsert, this.textInputElem.style.fontFamily = this.textStyle.fontFamily, this.textInputElem.style.fontStyle = this.textStyle.fontStyle ?? "", this.textInputElem.style.fontVariant = this.textStyle.fontVariant ?? "", this.textInputElem.style.fontWeight = this.textStyle.fontWeight ?? "", this.textInputElem.style.fontSize = `${this.textStyle.size}px`, this.textInputElem.style.color = this.textStyle.renderingStyle.fill.toHexString(), this.textInputElem.style.margin = "0", this.textInputElem.style.width = `${this.textInputElem.scrollWidth}px`, this.textInputElem.style.height = `${this.textInputElem.scrollHeight}px`; const t = this.getTextAscent("Testing!", this.textStyle); this.textInputElem.style.transform = `translate(0, ${-t}px)`, this.textInputElem.style.transformOrigin = "top left"; const e = Math.floor(this.textStyle.size); this.textInputElem.style.lineHeight = `${e}px` } startTextInput(t, e) { this.flushInput(), this.textInputElem = document.createElement("textarea"), this.textInputElem.value = e, this.textInputElem.style.display = "inline-block"; const o = this.editor.viewport.roundPoint(t), n = -this.editor.viewport.getRotationAngle(), i = s.Vec2.of(1, 1).times(this.editor.viewport.getSizeOfPixelOnCanvas()); this.contentTransform.set(s.Mat33.translation(o).rightMul(s.Mat33.zRotation(n)).rightMul(s.Mat33.scaling2D(i))), this.updateTextInput(), setTimeout((() => this.updateTextInput()), 0), this.textInputElem.oninput = () => { this.textInputElem && (this.textInputElem.style.width = `${this.textInputElem.scrollWidth}px`, this.textInputElem.style.height = `${this.textInputElem.scrollHeight}px`) }, this.textInputElem.onblur = () => { const t = this.textInputElem; this.flushInput(!1), this.textInputElem = null, setTimeout((() => { t?.remove() }), 0) }, this.textInputElem.onkeyup = t => { "Enter" !== t.key || t.shiftKey ? "Escape" === t.key && (this.textInputElem?.remove(), this.textInputElem = null, this.editor.focus(), this.removeExistingCommand?.unapply(this.editor), this.removeExistingCommand = null) : (this.flushInput(), this.editor.focus()) }, this.textEditOverlay.replaceChildren(this.textInputElem), setTimeout((() => this.textInputElem?.focus()), 0) } setEnabled(t) { super.setEnabled(t), this.isEnabled() || this.flushInput(), this.textEditOverlay.style.display = t ? "block" : "none" } onPointerDown({ current: t, allPointers: e }) { if (t.device === a.PointerDevice.Eraser) return !1; if (1 === e.length) { const e = t.canvasPos, o = s.Vec2.of(2.5, 2.5).times(this.editor.viewport.getSizeOfPixelOnCanvas()), n = s.Rect2.fromCorners(e.minus(o), e.plus(o)); let r = this.editor.image.getElementsIntersectingRegion(n).filter((t => t instanceof i.default)); const a = this.editor.viewport.visibleRect; if (r = r.filter((t => !t.getBBox().containsRect(a))), this.flushInput(), r.length > 0) { const t = r[r.length - 1]; this.setTextStyle(t.getTextStyle()), this.removeExistingCommand = new d.default([t]), this.removeExistingCommand.apply(this.editor), this.startTextInput(t.getBaselinePos(), t.getText()), this.contentTransform.set(t.getTransform()), this.updateTextInput() } else this.removeExistingCommand = null, this.startTextInput(t.canvasPos, ""); return !0 } return !1 } onGestureCancel() { this.flushInput(), this.editor.focus() } setFontFamily(t) { t !== this.textStyle.fontFamily && this.textStyleValue.set({ ...this.textStyle, fontFamily: t }) } setColor(t) { t.eq(this.textStyle.renderingStyle.fill) || this.textStyleValue.set({ ...this.textStyle, renderingStyle: { ...this.textStyle.renderingStyle, fill: t } }) } setFontSize(t) { t !== this.textStyle.size && this.textStyleValue.set({ ...this.textStyle, size: t }) } getTextStyle() { return this.textStyle } getStyleValue() { return this.textStyleValue } setTextStyle(t) { this.textStyleValue.set(t) } onDestroy() { super.onDestroy(), this.anchorControl.remove() } } e.default = f }, 4641: function (t, e, o) { "use strict"; var n, i = this && this.__createBinding || (Object.create ? function (t, e, o, n) { void 0 === n && (n = o); var i = Object.getOwnPropertyDescriptor(e, o); i && !("get" in i ? !e.__esModule : i.writable || i.configurable) || (i = { enumerable: !0, get: function () { return e[o] } }), Object.defineProperty(t, n, i) } : function (t, e, o, n) { void 0 === n && (n = o), t[n] = e[o] }), r = this && this.__setModuleDefault || (Object.create ? function (t, e) { Object.defineProperty(t, "default", { enumerable: !0, value: e }) } : function (t, e) { t.default = e }), s = this && this.__importStar || (n = function (t) { return n = Object.getOwnPropertyNames || function (t) { var e = []; for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[e.length] = o); return e }, n(t) }, function (t) { if (t && t.__esModule) return t; var e = {}; if (null != t) for (var o = n(t), s = 0; s < o.length; s++)"default" !== o[s] && i(e, t, o[s]); return r(e, t), e }), a = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const l = o(2018), c = o(5379), d = s(o(7955)), h = a(o(9392)), u = a(o(9873)), p = a(o(1011)), f = a(o(1172)), m = a(o(903)), g = a(o(7686)), b = a(o(2870)), y = a(o(5192)), v = a(o(166)), x = a(o(5716)), w = o(14), S = a(o(8402)), T = a(o(4209)), C = a(o(340)), P = o(7394), k = a(o(960)), E = a(o(3343)), z = a(o(915)); e.default = class { constructor(t, e) { this.activeTool = null, this.isEditorReadOnly = t.isReadOnlyReactiveValue(), this.inputPipeline = new k.default, this.inputPipeline.setEmitListener((t => this.onEventInternal(t))); const o = new u.default; this.primaryToolGroup = o; const n = new d.default(t, d.PanZoomMode.TwoFingerTouchGestures | d.PanZoomMode.RightClickDrags, e.touchPanTool), i = new d.default(t, d.PanZoomMode.Keyboard, e.keyboardPanZoom), r = new h.default(t, e.penTool(1), { color: c.Color4.purple, thickness: 8 }), s = new h.default(t, e.penTool(2), { color: c.Color4.clay, thickness: 4 }); s.setInputMapper(new E.default(t.viewport)); const a = new p.default(t, e.eraserTool), P = [r, s, new h.default(t, e.penTool(3), { color: c.Color4.ofRGBA(1, 1, 0, .5), thickness: 40, factory: w.makePressureSensitiveFreehandLineBuilder }), a, new f.default(t, e.selectionTool), new g.default(t, e.textTool, e), new d.default(t, d.PanZoomMode.SinglePointerGestures, e.anyDevicePanning)], M = new C.default(t, e.soundExplorer); M.setEnabled(!1), this.tools = [new z.default(t), new b.default(t, e.pipetteTool), M, n, ...P, i, new m.default(t), new x.default(t), new y.default(t), a.makeEraserSwitcherTool(), new S.default(t), new v.default(t), new T.default(t)], P.forEach((t => t.setToolGroup(o))), n.setEnabled(!0), r.setEnabled(!0), t.notifier.on(l.EditorEventType.ToolEnabled, (o => { o.kind === l.EditorEventType.ToolEnabled && t.announceForAccessibility(e.toolEnabledAnnouncement(o.tool.description)) })), t.notifier.on(l.EditorEventType.ToolDisabled, (o => { o.kind === l.EditorEventType.ToolDisabled && t.announceForAccessibility(e.toolDisabledAnnouncement(o.tool.description)) })), this.activeTool = null } setTools(t, e) { this.tools = t, this.primaryToolGroup = e ?? new u.default } addPrimaryTool(t) { t.setToolGroup(this.primaryToolGroup), t.isEnabled() && this.primaryToolGroup.notifyEnabled(t), this.tools.includes(t) || this.addTool(t) } getPrimaryTools() { return this.tools.filter((t => t.getToolGroup() === this.primaryToolGroup)) } addTool(t, e) { this.tools.includes(t) || (e?.addToFront ? this.tools.splice(0, 0, t) : this.tools.push(t)) } removeAndDestroyTools(t) { const e = []; for (const o of this.tools) t.includes(o) ? (this.activeTool === o && (this.activeTool = null), o.onDestroy()) : e.push(o); this.tools = e } insertTools(t, e, o) { this.tools = this.tools.filter((t => !e.includes(t))); const n = []; for (const i of this.tools) "after" === o && n.push(i), i === t && n.push(...e), "before" === o && n.push(i); this.tools = n } insertToolsAfter(t, e) { this.insertTools(t, e, "after") } insertToolsBefore(t, e) { this.insertTools(t, e, "before") } onEventInternal(t) { const e = this.isEditorReadOnly.get(), o = t => t.isEnabled() && (!e || t.canReceiveInputInReadOnlyEditor()); let n = !1; if (t.kind === P.InputEvtType.PointerDownEvt) { let e = !1; this.activeTool && !this.activeTool.eventCanBeDeliveredToNonActiveTool(t) && (e = !0); for (const i of this.tools) if ((!e || i === this.activeTool) && o(i) && i.onEvent(t)) { this.activeTool !== i && this.activeTool?.onEvent({ kind: P.InputEvtType.GestureCancelEvt }), this.activeTool = i, n = !0; break } } else if (t.kind === P.InputEvtType.PointerUpEvt) { const e = this.activeTool?.onEvent(t); e && t.allPointers.length > 1 || (this.activeTool = null), n = !0 } else if (t.kind === P.InputEvtType.PointerMoveEvt) null !== this.activeTool && (this.activeTool.onEvent(t), n = !0); else if (t.kind === P.InputEvtType.GestureCancelEvt) null !== this.activeTool && (this.activeTool.onEvent(t), this.activeTool = null); else for (const e of this.tools) if (o(e) && (n = e.onEvent(t), n)) break; return n } onEvent(t) { return this.dispatchInputEvent(t) } dispatchInputEvent(t) { return this.inputPipeline.onEvent(t) } addInputMapper(t) { this.inputPipeline.addToTail(t) } getMatchingTools(t) { return this.tools.filter((e => e instanceof t)) } onEditorDestroyed() { for (const t of this.tools) t.onDestroy() } } }, 9873: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); e.default = class { constructor() { } notifyEnabled(t) { t !== this.activeTool && (this.activeTool?.setEnabled(!1), this.activeTool = t) } } }, 5192: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(8836)); class r extends i.default { constructor(t) { super(t.notifier, t.localization.changeTool), this.editor = t } canReceiveInputInReadOnlyEditor() { return !0 } onKeyPress({ key: t }) { const e = this.editor.toolController.getPrimaryTools(), o = /^[0-9]$/.exec(t); let n; if (o) { n = e[parseInt(o[0], 10) - 1] } return !!n && (n.setEnabled(!0), !0) } } e.default = r }, 5716: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(8836)); class r extends i.default { constructor(t) { super(t.notifier, t.localization.changeTool), this.listeners = new Set([]) } registerListener(t) { this.listeners.add(t) } removeListener(t) { this.listeners.delete(t) } onKeyPress(t) { const e = Array.from(this.listeners.values()); for (const o of e) if (o(t)) return !0; return !1 } } e.default = r }, 903: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(8836)), r = o(6362); class s extends i.default { constructor(t) { super(t.notifier, t.localization.undoRedoTool), this.editor = t } onKeyPress(t) { return this.editor.shortcuts.matchesShortcut(r.undoKeyboardShortcutId, t) ? (this.editor.history.undo(), !0) : !!this.editor.shortcuts.matchesShortcut(r.redoKeyboardShortcutId, t) && (this.editor.history.redo(), !0) } } e.default = s }, 6362: function (t, e, o) { "use strict"; var n = this && this.__createBinding || (Object.create ? function (t, e, o, n) { void 0 === n && (n = o); var i = Object.getOwnPropertyDescriptor(e, o); i && !("get" in i ? !e.__esModule : i.writable || i.configurable) || (i = { enumerable: !0, get: function () { return e[o] } }), Object.defineProperty(t, n, i) } : function (t, e, o, n) { void 0 === n && (n = o), t[n] = e[o] }), i = this && this.__exportStar || function (t, e) { for (var o in t) "default" === o || Object.prototype.hasOwnProperty.call(e, o) || n(e, t, o) }, r = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.zoomOutKeyboardShortcutId = e.zoomInKeyboardShortcutId = e.rotateCounterClockwiseKeyboardShortcutId = e.rotateClockwiseKeyboardShortcutId = e.moveDownKeyboardShortcutId = e.moveUpKeyboardShortcutId = e.moveRightKeyboardShortcutId = e.moveLeftKeyboardShortcutId = e.toggleFindVisibleShortcutId = e.lineLockKeyboardShortcutId = e.snapToGridKeyboardShortcutId = e.decreaseSizeKeyboardShortcutId = e.increaseSizeKeyboardShortcutId = e.redoKeyboardShortcutId = e.undoKeyboardShortcutId = void 0; const s = r(o(5577)); e.undoKeyboardShortcutId = "jsdraw.tools.undo", e.redoKeyboardShortcutId = "jsdaw.tools.redo", s.default.registerDefaultKeyboardShortcut(e.undoKeyboardShortcutId, ["CtrlOrMeta+KeyZ"], "Undo"), s.default.registerDefaultKeyboardShortcut(e.redoKeyboardShortcutId, ["CtrlOrMeta+Shift+KeyZ", "CtrlOrMeta+KeyY"], "Redo"), e.increaseSizeKeyboardShortcutId = "jsdraw.tools.increaseSize", s.default.registerDefaultKeyboardShortcut(e.increaseSizeKeyboardShortcutId, ["Equal", "Shift+Equal"], "Increase pen/eraser size"), e.decreaseSizeKeyboardShortcutId = "jsdraw.tools.decreaseSize", s.default.registerDefaultKeyboardShortcut(e.decreaseSizeKeyboardShortcutId, ["Minus", "Shift+Minus"], "Decrease pen/eraser size"), e.snapToGridKeyboardShortcutId = "jsdraw.tools.snapToGrid", s.default.registerDefaultKeyboardShortcut(e.snapToGridKeyboardShortcutId, ["Control", "Meta"], "Snap to grid (press and hold)"), e.lineLockKeyboardShortcutId = "jsdraw.tools.lockToLine", s.default.registerDefaultKeyboardShortcut(e.lineLockKeyboardShortcutId, ["Shift"], "Snap to XY axes (press and hold)"), e.toggleFindVisibleShortcutId = "js-draw.tools.FindTool.toggleVisible", s.default.registerDefaultKeyboardShortcut(e.toggleFindVisibleShortcutId, ["CtrlOrMeta+KeyF"], "Shows/hides the find tool"), e.moveLeftKeyboardShortcutId = "jsdraw.tools.PanZoom.moveLeft", s.default.registerDefaultKeyboardShortcut(e.moveLeftKeyboardShortcutId, ["ArrowLeft", "KeyH", "KeyA"], "Pan left"), e.moveRightKeyboardShortcutId = "jsdraw.tools.PanZoom.moveRight", s.default.registerDefaultKeyboardShortcut(e.moveRightKeyboardShortcutId, ["ArrowRight", "KeyL", "KeyD"], "Pan right"), e.moveUpKeyboardShortcutId = "jsdraw.tools.PanZoom.moveUp", s.default.registerDefaultKeyboardShortcut(e.moveUpKeyboardShortcutId, ["ArrowUp", "KeyK", "KeyQ"], "Pan up"), e.moveDownKeyboardShortcutId = "jsdraw.tools.PanZoom.moveDown", s.default.registerDefaultKeyboardShortcut(e.moveDownKeyboardShortcutId, ["ArrowDown", "KeyJ", "KeyE"], "Pan down"), e.rotateClockwiseKeyboardShortcutId = "jsdraw.tools.PanZoom.rotateViewClockwise", s.default.registerDefaultKeyboardShortcut(e.rotateClockwiseKeyboardShortcutId, ["Shift+KeyR"], "Rotate viewport clockwise"), e.rotateCounterClockwiseKeyboardShortcutId = "jsdraw.tools.PanZoom.rotateViewCounterClockwise", s.default.registerDefaultKeyboardShortcut(e.rotateCounterClockwiseKeyboardShortcutId, ["KeyR"], "Rotate viewport counter-clockwise"), e.zoomInKeyboardShortcutId = "jsdraw.tools.PanZoom.zoomIn", s.default.registerDefaultKeyboardShortcut(e.zoomInKeyboardShortcutId, ["KeyW"], "Zoom in"), e.zoomOutKeyboardShortcutId = "jsdraw.tools.PanZoom.zoomOut", s.default.registerDefaultKeyboardShortcut(e.zoomOutKeyboardShortcutId, ["KeyS"], "Zoom out"), i(o(8561), e) }, 6532: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.ToolbarShortcutHandler = e.SoundUITool = e.PasteHandler = e.EraserMode = e.EraserTool = e.SelectAllShortcutHandler = e.SelectionTool = e.TextTool = e.PenTool = e.PanZoomMode = e.PanZoomTool = e.ToolSwitcherShortcut = e.UndoRedoShortcut = e.ToolEnabledGroup = e.ToolController = e.BaseTool = e.InputMapper = void 0; var i = o(2388); Object.defineProperty(e, "InputMapper", { enumerable: !0, get: function () { return n(i).default } }); var r = o(8836); Object.defineProperty(e, "BaseTool", { enumerable: !0, get: function () { return n(r).default } }); var s = o(4641); Object.defineProperty(e, "ToolController", { enumerable: !0, get: function () { return n(s).default } }); var a = o(9873); Object.defineProperty(e, "ToolEnabledGroup", { enumerable: !0, get: function () { return n(a).default } }); var l = o(903); Object.defineProperty(e, "UndoRedoShortcut", { enumerable: !0, get: function () { return n(l).default } }); var c = o(5192); Object.defineProperty(e, "ToolSwitcherShortcut", { enumerable: !0, get: function () { return n(c).default } }); var d = o(7955); Object.defineProperty(e, "PanZoomTool", { enumerable: !0, get: function () { return n(d).default } }), Object.defineProperty(e, "PanZoomMode", { enumerable: !0, get: function () { return d.PanZoomMode } }); var h = o(9392); Object.defineProperty(e, "PenTool", { enumerable: !0, get: function () { return n(h).default } }); var u = o(7686); Object.defineProperty(e, "TextTool", { enumerable: !0, get: function () { return n(u).default } }); var p = o(1172); Object.defineProperty(e, "SelectionTool", { enumerable: !0, get: function () { return n(p).default } }); var f = o(4209); Object.defineProperty(e, "SelectAllShortcutHandler", { enumerable: !0, get: function () { return n(f).default } }); var m = o(1011); Object.defineProperty(e, "EraserTool", { enumerable: !0, get: function () { return n(m).default } }), Object.defineProperty(e, "EraserMode", { enumerable: !0, get: function () { return m.EraserMode } }); var g = o(166); Object.defineProperty(e, "PasteHandler", { enumerable: !0, get: function () { return n(g).default } }); var b = o(340); Object.defineProperty(e, "SoundUITool", { enumerable: !0, get: function () { return n(b).default } }); var y = o(5716); Object.defineProperty(e, "ToolbarShortcutHandler", { enumerable: !0, get: function () { return n(y).default } }) }, 8658: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.defaultToolLocalization = void 0, e.defaultToolLocalization = { penTool: t => `Pen ${t}`, selectionTool: "Selection", selectAllTool: "Select all shortcut", eraserTool: "Eraser", touchPanTool: "Touch panning", twoFingerPanZoomTool: "Panning and zooming", undoRedoTool: "Undo/Redo", rightClickDragPanTool: "Right-click drag", pipetteTool: "Pick color from screen", keyboardPanZoom: "Keyboard pan/zoom shortcuts", selectionMenu__show: "Show selection menu", selectionMenu__copyToClipboard: "Copy to clipboard", selectionMenu__duplicate: "Duplicate", selectionMenu__delete: "Delete", selectionMenu__paste: "Paste", copyPasteError__heading: "Copy/paste", copyPasteError__description: "Something went wrong — this tool may not have clipboard access.", copyPasteError__errorDetails: "Show error", copyPasteError__pasteRetry: "To retry, please paste into the input box below:", copyPasteError__copyRetry: "To retry, please copy the text in the input box below:", copyPasteError__copyMe: "Copy me!", autocorrectedTo: t => `Autocorrected to ${t}`, autocorrectionCanceled: "Autocorrect cancelled", textTool: "Text", enterTextToInsert: "Text to insert", changeTool: "Change tool", pasteHandler: "Copy paste handler", soundExplorer: "Sound-based image exploration", disableAccessibilityExploreTool: "Disable sound-based exploration", enableAccessibilityExploreTool: "Enable sound-based exploration", soundExplorerUsageAnnouncement: "Sound-based image exploration enabled: Click/drag the screen to play a sound representation of different parts of the image.", findLabel: "Find", toNextMatch: "Next", closeDialog: "Close", findDialogShown: "Find dialog shown", findDialogHidden: "Find dialog hidden", focusedFoundText: (t, e) => `Viewing match ${t} of ${e}`, anyDevicePanning: "Any device panning", copied: t => `Copied ${t} item(s)`, pasted: t => `Pasted ${t} item(s)`, toolEnabledAnnouncement: t => `${t} enabled`, toolDisabledAnnouncement: t => `${t} disabled` } }, 5043: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.defaultStationaryDetectionConfig = void 0; const n = o(5379); e.defaultStationaryDetectionConfig = { maxSpeed: 8.5, maxRadius: 11, minTimeSeconds: .5 }; e.default = class { constructor(t, e, o) { this.config = e, this.onStationary = o, this.timeout = null, this.stationaryStartPointer = t, this.lastPointer = t, this.averageVelocity = n.Vec2.zero, this.setStationaryTimeout(1e3 * this.config.minTimeSeconds) } onPointerMove(t) { if (!this.stationaryStartPointer) return; if (t.id !== this.stationaryStartPointer.id) return !1; const e = t.screenPos.minus(this.lastPointer.screenPos), o = t.screenPos.minus(this.stationaryStartPointer.screenPos); let n = (t.timeStamp - this.lastPointer.timeStamp) / 1e3; 0 === n && (n = 1); const i = e.times(1 / n); this.averageVelocity = this.averageVelocity.lerp(i, .5); const r = t.timeStamp - this.stationaryStartPointer.timeStamp, s = o.length() > this.config.maxRadius; if (this.hasMovedOutOfRadius ||= s, s || this.averageVelocity.length() > this.config.maxSpeed || r < this.config.minTimeSeconds) return this.stationaryStartPointer = t, this.lastPointer = t, this.setStationaryTimeout(1e3 * this.config.minTimeSeconds), !1; const a = 1e3 * this.config.minTimeSeconds - r; return this.lastPointer = t, a <= 0 } onPointerUp(t) { t.id !== this.stationaryStartPointer?.id && this.cancelStationaryTimeout() } destroy() { this.cancelStationaryTimeout(), this.stationaryStartPointer = null } getHasMovedOutOfRadius() { return this.hasMovedOutOfRadius } cancelStationaryTimeout() { null !== this.timeout && (clearTimeout(this.timeout), this.timeout = null) } setStationaryTimeout(t) { null === this.timeout && (t <= 0 ? this.onStationary(this.lastPointer) : this.timeout = setTimeout((() => { if (this.timeout = null, !this.stationaryStartPointer) return; const t = performance.now() - this.stationaryStartPointer.timeStamp, e = 1e3 * this.config.minTimeSeconds - t; e <= 0 ? this.onStationary(this.lastPointer) : this.setStationaryTimeout(e) }), t)) } } }, 6665: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(6453)), r = o(2018); let s = 0; e.default = async (t, e, o) => { const n = document.createElement("div"), { remove: a } = t.createHTMLOverlay(n), l = document.createElement("dialog"); l.classList.add("editor-popup-menu"); l.style.setProperty("--hide-menu-animation-timeout", "240ms"); const c = () => { const o = t.getOutputBBoxInDOM(), n = t.viewport.canvasToScreen(e).plus(o.topLeft); l.style.setProperty("--anchor-x", `${n.x}px`), l.style.setProperty("--anchor-y", `${n.y}px`) }; c(); const d = t.notifier.on(r.EditorEventType.ViewportChanged, c); n.appendChild(l); let h = !1; const u = async () => { h || (h = !0, d.remove(), l.classList.add("-hide"), await (0, i.default)(240), l.close()) }; return new Promise((e => { let n = !1, i = null; const r = () => { n || (e(i), n = !0) }; l.onclose = () => { a(), r() }; t.handlePointerEventsExceptClicksFrom(l, ((t, e) => e.target === l && "pointerdown" === t ? (u(), !0) : !!h), ((t, e) => e.target === l)); const c = document.createElement("div"); c.classList.add("content"), c.role = "menu"; const d = []; c.addEventListener("keydown", (t => { const e = d.findIndex((t => t === document.activeElement)); if (-1 === e) return; let o = e; "ArrowDown" === t.key ? o++ : "ArrowUp" === t.key ? o-- : "End" === t.key ? o = d.length - 1 : "Home" === t.key && (o = 0), o < 0 && (o += d.length), o %= d.length, o !== e && (t.preventDefault(), d[o].focus()) })); for (const t of o) { const e = document.createElement("button"); e.id = "menu-overlay-option-" + s++, e.role = "menuitem", e.classList.add("option", "editor-popup-menu-option"), e.replaceChildren(t.icon(), document.createTextNode(t.text)), e.onclick = e => { var o; e.defaultPrevented || (o = t.key, i = o, u(), r()) }, c.appendChild(e), 0 === d.length && (e.autofocus = !0), d.push(e) } l.appendChild(c), l.showModal(), c.scrollIntoView({ block: "nearest" }) })) } }, 2018: (t, e) => { "use strict"; var o, n; Object.defineProperty(e, "__esModule", { value: !0 }), e.UndoEventType = e.EditorEventType = void 0, function (t) { t[t.ToolEnabled = 0] = "ToolEnabled", t[t.ToolDisabled = 1] = "ToolDisabled", t[t.ToolUpdated = 2] = "ToolUpdated", t[t.UndoRedoStackUpdated = 3] = "UndoRedoStackUpdated", t[t.CommandDone = 4] = "CommandDone", t[t.CommandUndone = 5] = "CommandUndone", t[t.ObjectAdded = 6] = "ObjectAdded", t[t.ViewportChanged = 7] = "ViewportChanged", t[t.DisplayResized = 8] = "DisplayResized", t[t.SelectionUpdated = 9] = "SelectionUpdated", t[t.ReadOnlyModeToggled = 10] = "ReadOnlyModeToggled", t[t.ColorPickerToggled = 11] = "ColorPickerToggled", t[t.ColorPickerColorSelected = 12] = "ColorPickerColorSelected", t[t.ToolbarDropdownShown = 13] = "ToolbarDropdownShown" }(o || (e.EditorEventType = o = {})), function (t) { t[t.CommandDone = 0] = "CommandDone", t[t.CommandUndone = 1] = "CommandUndone", t[t.CommandRedone = 2] = "CommandRedone" }(n || (e.UndoEventType = n = {})) }, 9988: function (t, e, o) { "use strict"; var n, i = this && this.__classPrivateFieldGet || function (t, e, o, n) { if ("a" === o && !n) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === o ? n : "a" === o ? n.call(t) : n ? n.value : e.get(t) }, r = this && this.__classPrivateFieldSet || function (t, e, o, n, i) { if ("m" === n) throw new TypeError("Private method is not writable"); if ("a" === n && !i) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof e ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === n ? i.call(t, o) : i ? i.value = o : e.set(t, o), o }, s = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const a = o(7394), l = s(o(8733)), c = t => t.endsWith("+xml") || t.startsWith("text/"); n = new WeakMap, e.default = class { constructor(t, e) { this.editor = t, this.callbacks = e, n.set(this, !1) } paste(t) { const e = t => { if (this.callbacks?.onPasteError) return this.callbacks.onPasteError(t), Promise.resolve(!1); throw t }; try { return this.pasteInternal(t).catch(e) } catch (t) { return e(t) } } async pasteInternal(t) { const e = this.editor, o = t?.dataTransfer ?? t?.clipboardData ?? null, n = !!o, i = (t, o) => o && e.toolController.dispatchInputEvent({ kind: a.InputEvtType.PasteEvent, mime: t, data: o }), r = ["image/svg+xml", "text/html", "image/png", "image/jpeg", "text/plain"]; let s = []; const d = new Map; if (n) { s = [...o.files]; for (const t of r) { const e = o.getData(t); e && d.set(t, e) } } else { const t = await navigator.clipboard.read(); for (const e of t) for (const t of e.types) r.includes(t) && s.push(await e.getType(t)) } const h = async o => { const n = c(o); if (n) { const e = d.get(o); if (i(o, e)) return t?.preventDefault(), !0 } for (const r of s) { const s = r?.type?.toLowerCase(); if (s === o) if (n) { const e = await r.text(); if (i(o, e)) return t?.preventDefault(), !0 } else { e.showLoadingWarning(0); const n = t => { e.showLoadingWarning(t.loaded / t.total) }; try { const s = await (0, l.default)(r, { onprogress: n }); if (i(o, s)) return t?.preventDefault(), e.hideLoadingWarning(), !0 } catch (t) { console.error("Error reading image:", t) } e.hideLoadingWarning() } } return !1 }; for (const t of r) if (await h(t)) return !0; return !1 } copy(t) { const e = t => { if (this.callbacks?.onCopyError) return this.callbacks.onCopyError(t), Promise.resolve(); throw t }; try { return this.copyInternal(t).catch(e) } catch (t) { return e(t) } } copyInternal(t) { const e = new Map; this.editor.toolController.dispatchInputEvent({ kind: a.InputEvtType.CopyEvent, setData: (t, o) => { e.set(t, o) } }) && t?.preventDefault(); const o = [...e.keys()].some((t => !c(t))), s = o => { if (!t) throw new Error("Unable to copy -- no event provided" + (o ? `. Original error: ${o}` : "")); for (const [o, n] of e.entries()) "string" == typeof n && ("clipboardData" in t ? t.clipboardData?.setData(o, n) : t.dataTransfer?.setData(o, n)) }, l = "undefined" != typeof ClipboardItem && void 0 !== navigator?.clipboard?.write; if (i(this, n, "f") || !l || !o && t) s(); else { let t = null; const o = t => { console.warn("Unable to copy to the clipboard API. Future calls to .copy will use ClipboardEvents if possible.", t), r(this, n, !0, "f"), s(t) }; try { t = (() => { const t = (t => { const e = Object.create(null); for (const [o, n] of Object.entries(t)) "supports" in ClipboardItem && "function" == typeof ClipboardItem.supports && !ClipboardItem.supports(o) || (e[o] = n); return e })((t => { const e = Object.create(null); for (const [o, n] of t.entries()) { if ("string" == typeof n) { const t = new Blob([(new TextEncoder).encode(n)], { type: o }); e[o] = t } else e[o] = n; "image/svg+xml" === o && (e["text/html"] ??= e[o]) } return e })(e)); return navigator.clipboard.write([new ClipboardItem(t)]) })() } catch (t) { o(t) } if (t) return t.catch(o) } return Promise.resolve() } } }, 7988: function (t, e) { "use strict"; var o, n, i = this && this.__classPrivateFieldSet || function (t, e, o, n, i) { if ("m" === n) throw new TypeError("Private method is not writable"); if ("a" === n && !i) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof e ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === n ? i.call(t, o) : i ? i.value = o : e.set(t, o), o }, r = this && this.__classPrivateFieldGet || function (t, e, o, n) { if ("a" === o && !n) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === o ? n : "a" === o ? n.call(t) : n ? n.value : e.get(t) }; Object.defineProperty(e, "__esModule", { value: !0 }), e.MutableReactiveValue = e.ReactiveValue = void 0; const s = { remove() { } }, a = () => s; class l { waitForNextUpdate() { return new Promise((t => { const e = this.onUpdate((o => { e.remove(), t(o) })) })) } static fromInitialValue(t) { return new d(t) } static fromImmutable(t) { return { get: () => t, onUpdate: a, onUpdateAndNow: e => (e(t), s), waitForNextUpdate: () => new Promise((() => { })) } } static fromCallback(t, e) { const o = new d(t()), n = window.WeakRef ? new window.WeakRef(o) : { deref: () => o }; for (const o of e) { const e = o.onUpdate((() => { const o = n.deref(); o ? o.set(t()) : e.remove() })) } return o } static map(t, e, o) { const n = l.fromInitialValue(e(t.get())); let i = n.get(); return t.onUpdate((t => { i = e(t), n.set(i) })), o && n.onUpdate((e => { e !== i && t.set(o(e)) })), n } static union(t) { return l.fromCallback((() => t.map((t => t.get()))), t) } } e.ReactiveValue = l; class c extends l { static fromProperty(t, e) { const o = l.fromInitialValue(t.get()[e]), n = window.WeakRef ? new window.WeakRef(o) : { deref: () => o }, i = t.onUpdate((t => { const o = n.deref(); o ? o.set(t[e]) : i.remove() })); return o.onUpdate((o => { t.set({ ...t.get(), [e]: o }) })), o } } e.MutableReactiveValue = c; class d extends c { constructor(t) { super(), o.set(this, void 0), n.set(this, void 0), i(this, o, t, "f"), i(this, n, [], "f") } set(t) { if (r(this, o, "f") !== t) { i(this, o, t, "f"); for (const e of r(this, n, "f")) e(t) } } get() { return r(this, o, "f") } onUpdate(t) { return r(this, n, "f").push(t), { remove: () => { i(this, n, r(this, n, "f").filter((e => e !== t)), "f") } } } onUpdateAndNow(t) { return t(this.get()), this.onUpdate(t) } } o = new WeakMap, n = new WeakMap, e.default = l }, 3676: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(7184)); e.default = (t, e) => { const o = "has-long-press-or-hover", n = "no-long-press-or-hover"; t.classList.add("no-long-press-or-hover"); const { removeListeners: r } = (0, i.default)(t, { onStart() { t.classList.remove(n), t.classList.add(o) }, onEnd() { t.classList.add(n), t.classList.remove(o) }, longPressTimeout: e?.timeout }); return { removeEventListeners: () => { t.classList.remove(n), r() } } } }, 6710: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); const n = o(5379); e.default = (t, e) => { const o = t.getRootElement(), i = [["--background-color-1", "--foreground-color-1", !0, !0], ["--background-color-2", "--foreground-color-2", !0, !0], ["--background-color-3", "--foreground-color-3", !0, !0], ["--background-color-2", "--primary-action-foreground-color", !1, !0], ["--selection-background-color", "--selection-foreground-color", !1, !0]]; if (!e?.dontClearOverrides) for (const [t, e] of i) o.style.setProperty(t, null), o.style.setProperty(e, null); const r = getComputedStyle(o), s = Object.create(null), a = (t, e, i, a, l) => { let c = s[t] ? s[t] : n.Color4.fromString(r.getPropertyValue(t)), d = s[e] ? s[e] : n.Color4.fromString(r.getPropertyValue(e)); if (c.relativeLuminance() < d.relativeLuminance()) { const o = c; c = d, d = o; const n = e; e = t, t = n; const i = a; a = l, l = i } let h = !1, u = n.Color4.contrastRatio(c, d), p = 0; for (; u < i && p < 8;) { const t = n.Vec3.of(.1, .1, .1); a && (d.eq(n.Color4.white) && !l && (d = n.Color4.black), c = n.Color4.fromRGBVector(c.rgb.plus(t))), l && (d.eq(n.Color4.black) && !a && (d = n.Color4.white), d = n.Color4.fromRGBVector(d.rgb.minus(t))), u = n.Color4.contrastRatio(c, d), h = !0, p++ } h && (o.style.setProperty(t, c.toHexString()), o.style.setProperty(e, d.toHexString()), s[t] = c, s[e] = d) }; a("--selection-background-color", "--background-color-2", 1.29, !0, !1); for (const [t, e, o, n] of i) { a(t, e, 4.5, o, n) } } }, 7571: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.assertIsBoolean = e.assertIsNumberArray = e.assertIsNumber = e.assertUnreachable = void 0; e.assertUnreachable = t => { throw new Error(`Should be unreachable. Key: ${t}.`) }; e.assertIsNumber = (t, e = !1) => { if ("number" != typeof t || !e && isNaN(t)) throw new Error("Given value is not a number"); return !0 }; e.assertIsNumberArray = (t, o = !1) => { if ("object" != typeof t) throw new Error("Asserting isNumberArray: Given entity is not an array"); if (!(0, e.assertIsNumber)(t.length)) return !1; for (const n of t) if (!(0, e.assertIsNumber)(n, o)) return !1; return !0 }; e.assertIsBoolean = t => { if ("boolean" != typeof t) throw new Error("Given value is not a boolean"); return !0 } }, 42: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); e.default = t => { const e = t / 1024, o = e / 1024, n = o / 1024; let i = "B", r = t; return n >= 1 ? (r = n, i = "GiB") : o >= 1 ? (r = o, i = "MiB") : e >= 1 && (r = e, i = "KiB"), { size: r, units: i } } }, 4339: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); e.default = t => { const e = (t, o) => { const n = getComputedStyle(t); for (let t = 0; t < n.length; t++) { const e = n.item(t), i = n.getPropertyValue(e); o.style?.setProperty(e, i) } for (let n = 0; n < t.children.length; n++) { const i = t.children.item(n), r = o.children.item(n); i && r ? e(i, r) : console.warn("CloneElement: Missing child") } }, o = t.cloneNode(!0); return e(t, o), o } }, 7964: (t, e) => { "use strict"; var o; Object.defineProperty(e, "__esModule", { value: !0 }), e.createSvgPaths = e.createSvgElements = e.createSvgElement = e.ElementNamespace = void 0, function (t) { t.Html = "html", t.Svg = "svg" }(o || (e.ElementNamespace = o = {})); const n = (t, e, n = o.Html) => { let i; if (n === o.Html) i = document.createElement(t); else { if (n !== o.Svg) throw new Error(`Unknown element type ${n}`); i = document.createElementNS("http://www.w3.org/2000/svg", t) } for (const [t, o] of Object.entries(e)) if ("children" !== t) { if ("string" != typeof o && "number" != typeof o) throw new Error("Unsupported value type " + typeof o); i.setAttribute(t, o.toString()) } if (e.children) for (const t of e.children) i.appendChild(t); return i }; e.createSvgElement = (t, e) => n(t, e, o.Svg); e.createSvgElements = (t, o) => o.map((o => (0, e.createSvgElement)(t, o))); e.createSvgPaths = (...t) => (0, e.createSvgElements)("path", t), e.default = n }, 8733: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); e.default = async (t, e = {}) => { try { const o = new FileReader; return await new Promise(((n, i) => { o.onload = () => n(o.result), o.onerror = i, o.onabort = i, o.onprogress = t => { e.onprogress?.(t) }, o.readAsDataURL(t) })) } catch (o) { (e.onWarning ?? console.warn)("Unable to convert file to base64 with a FileReader: ", o); const n = await t.arrayBuffer(), i = new Uint8Array(n), r = 30, s = []; for (let t = 0; t < i.length; t += r) { const e = String.fromCharCode(...i.slice(t, t + r)); s.push(btoa(e)) } return `data:${t.type ?? "image/*"};base64,${s.join("")}` } } }, 2832: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); const o = { Control: "ControlLeft", "=": "Equal", "-": "Minus", ";": "Semicolon", " ": "Space" }; e.default = t => { const e = t.toUpperCase(); return "A" <= e && e <= "Z" ? `Key${e}` : "0" <= t && t <= "9" ? `Digit${t}` : t in o ? o[t] : t } }, 9395: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.MutableReactiveValue = e.ReactiveValue = e.adjustEditorThemeForContrast = void 0; var i = o(6710); Object.defineProperty(e, "adjustEditorThemeForContrast", { enumerable: !0, get: function () { return n(i).default } }); var r = o(7988); Object.defineProperty(e, "ReactiveValue", { enumerable: !0, get: function () { return r.ReactiveValue } }), Object.defineProperty(e, "MutableReactiveValue", { enumerable: !0, get: function () { return r.MutableReactiveValue } }) }, 6953: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); e.default = (t, e) => { const o = t.length < e.length ? t : e, n = o === t ? e : t; for (let t = 0; t < o.length; t++)if (o[t] !== n[t]) return !1; return !0 } }, 410: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); e.default = (t, e) => { let o = []; const n = (t, e) => t.key === e.key && t.code === e.code, i = t => { if ("keydown" === t.type) { if (r = t, o.some((t => n(t, r))) || o.push({ code: (i = t).code, key: i.key, ctrlKey: i.ctrlKey, altKey: i.altKey, shiftKey: i.shiftKey, metaKey: i.metaKey }), !e.filter(t)) return; e.handleKeyDown(t) } else { if (console.assert("keyup" === t.type), o = o.filter((e => !n(e, t))), !e.filter(t)) return; e.handleKeyUp(t) } var i, r }; t.addEventListener("keydown", (t => { i(t) })), t.addEventListener("keyup", (t => { i(t) })), t.addEventListener("focusout", (n => { let i = !1; if (n.relatedTarget) { const o = n.relatedTarget; i = t.contains(o) || e.getHandlesKeyEventsFrom(o) } if (!i) { for (const t of o) e.handleKeyUp(new KeyboardEvent("keyup", { ...t })); o = [] } })); const r = t => { let e = !1, n = !1, r = !1, s = !1; for (const t of o) { const o = t.code; e ||= !!o.match(/^Shift(Left|Right)$/), n ||= !!o.match(/^Control(Left|Right)$/), r ||= !!o.match(/^Alt(Left|Right)$/), s ||= !!o.match(/^Meta(Left|Right)$/) } const a = t => t ? "keydown" : "keyup", l = { shiftKey: t.shiftKey, altKey: t.altKey, metaKey: t.metaKey, ctrlKey: t.ctrlKey }; t.shiftKey !== e && i(new KeyboardEvent(a(t.shiftKey), { ...l, key: "Shift", code: "ShiftLeft" })), t.altKey !== r && i(new KeyboardEvent(a(t.altKey), { ...l, key: "Alt", code: "AltLeft" })), t.ctrlKey !== n && i(new KeyboardEvent(a(t.ctrlKey), { ...l, key: "Control", code: "ControlLeft" })), t.metaKey !== s && i(new KeyboardEvent(a(t.metaKey), { ...l, key: "Meta", code: "MetaLeft" })) }; t.addEventListener("mousedown", (t => { r(t) })), t.addEventListener("mousemove", (t => { r(t) })) } }, 7184: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); e.default = (t, e) => { const o = new Map; let n = null, i = !1; const r = () => { if (0 === o.size) i ? (i = !1, e.onEnd()) : null !== n && (clearTimeout(n), n = null); else { const t = Date.now(); let s = 0; for (const e of o.values()) { const o = t - e.timeEnter; s = Math.max(o, s) } const a = e.longPressTimeout ?? 700; null !== n && (clearTimeout(n), n = null); const l = a - s; l <= 0 ? (e.onStart(), i = !0) : n = setTimeout((() => { n = null, r() }), l) } }, s = t => { const e = { timeEnter: Date.now() }; "pointerenter" === t.type ? o.set(t.pointerId, e) : "pointerleave" !== t.type && "pointercancel" !== t.type || o.clear(), r() }; return t.addEventListener("pointerenter", s), t.addEventListener("pointerleave", s), t.addEventListener("pointercancel", s), { removeListeners: () => { t.removeEventListener("pointerenter", s), t.removeEventListener("pointerleave", s), t.removeEventListener("pointercancel", s) } } } }, 3718: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); e.default = t => `\nMIT License\n\nCopyright (c) ${t}\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the "Software"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.`.replace(/([^\n])[\n]([^\n])/g, "$1 $2") }, 9292: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); e.default = t => { const e = (t, e, o, n) => e !== n && 0 !== t && !(o + t <= 0) && !(o + e + t > n); t.onwheel = o => { const n = e(o.deltaX, t.clientWidth, t.scrollLeft, t.scrollWidth), i = e(o.deltaY, t.clientHeight, t.scrollTop, t.scrollHeight); (n || i) && o.stopPropagation() } } }, 6398: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); e.default = () => new Promise((t => { requestAnimationFrame((() => t())) })) }, 9713: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); e.default = t => { if (t.some((t => t && t.then))) return Promise.all(t).then((() => { })) } }, 8614: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); e.default = async t => { t.complete || await new Promise(((e, o) => { t.onload = t => e(t), t.onerror = t => o(t), t.onabort = t => o(t) })) } }, 6453: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); e.default = t => new Promise((e => { setTimeout((() => e()), t) })) }, 5711: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.default = { number: "1.24.2" } }, 9435: (t, e, o) => { "use strict"; var n = o(2591), i = o.n(n), r = o(1740), s = o.n(r), a = o(8128), l = o.n(a), c = o(855), d = o.n(c), h = o(3051), u = o.n(h), p = o(3656), f = o.n(p), m = o(5731), g = {}; g.styleTagTransform = f(), g.setAttributes = d(), g.insert = l().bind(null, "head"), g.domAPI = s(), g.insertStyleElement = u(); i()(m.A, g); m.A && m.A.locals && m.A.locals; var b = o(9724), y = {}; y.styleTagTransform = f(), y.setAttributes = d(), y.insert = l().bind(null, "head"), y.domAPI = s(), y.insertStyleElement = u(); i()(b.A, y); b.A && b.A.locals && b.A.locals }, 5035: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.Color4 = void 0; const i = n(o(4981)); class r { constructor(t, e, o, n) { this.r = t, this.g = e, this.b = o, this.a = n, this.hexString = null } static ofRGB(t, e, o) { return r.ofRGBA(t, e, o, 1) } static ofRGBA(t, e, o, n) { return t = Math.max(0, Math.min(t, 1)), e = Math.max(0, Math.min(e, 1)), o = Math.max(0, Math.min(o, 1)), n = Math.max(0, Math.min(n, 1)), new r(t, e, o, n) } static fromRGBArray(t, e = 255) { const o = t[0], n = t[1] ?? o, i = t[2] ?? o; let s = 255; return 3 < t.length && (s = t[3]), r.ofRGBA(o / e, n / e, i / e, s / e) } static fromHex(t) { if (!(t = (t = (t.match(/^[#]?(.*)$/) ?? [])[1]).toUpperCase()).match(/^[0-9A-F]+$/)) throw new Error(`${t} is not in a valid format.`); if (3 === t.length || 4 === t.length) { const e = t.split(""); t = e.map((t => `${t}0`)).join("") } 6 === t.length && (t += "FF"); const e = []; for (let o = 2; o <= t.length; o += 2) { const n = t.substring(o - 2, o); e.push(parseInt(n, 16) / 255) } if (4 !== e.length) throw new Error(`Unable to parse ${t}: Wrong number of components.`); return r.ofRGBA(e[0], e[1], e[2], e[3]) } static fromString(t) { if (t.startsWith("#")) return r.fromHex(t); if ("none" === t || "transparent" === t) return r.transparent; if ("" === t) return r.black; const e = t.replace(/\s*/g, "").match(/^rgba?\(([,0-9.]+)\)$/i); if (e) { const o = e[1], n = JSON.parse(`[ ${o} ]`); if (3 === n.length) return r.ofRGB(n[0] / 255, n[1] / 255, n[2] / 255); if (4 === n.length) return r.ofRGBA(n[0] / 255, n[1] / 255, n[2] / 255, n[3]); throw new Error(`RGB string, ${t}, has wrong number of components: ${n.length}`) } const o = document.createElement("canvas"); o.width = 1, o.height = 1; const n = o.getContext("2d"); if (!n) return r.black; n.fillStyle = t, n.fillRect(0, 0, 1, 1); const i = n.getImageData(0, 0, 1, 1), s = i.data[0] / 255, a = i.data[1] / 255, l = i.data[2] / 255, c = i.data[3] / 255; return r.ofRGBA(s, a, l, c) } eq(t) { return null != t && (0 === this.a && 0 === t.a || this.toHexString() === t.toHexString()) } mix(t, e) { const o = 1 - (e = Math.min(Math.max(e, 0), 1)); return new r(this.r * o + t.r * e, this.g * o + t.g * e, this.b * o + t.b * e, this.a * o + t.a * e) } get rgb() { return i.default.of(this.r, this.g, this.b) } relativeLuminance() { const t = [this.r, this.g, this.b].map((t => t < .03928 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4))); return .2126 * t[0] + .7152 * t[1] + .0722 * t[2] } static contrastRatio(t, e) { const o = t.relativeLuminance(), n = e.relativeLuminance(); return (Math.max(o, n) + .05) / (Math.min(o, n) + .05) } static average(t) { let e = 0, o = 0, n = 0, i = 0; for (const r of t) e += r.a, o += r.r, n += r.g, i += r.b; return t.length > 0 && (e /= t.length, o /= t.length, n /= t.length, i /= t.length), new r(o, n, i, e) } asHSV() { const t = Math.min(this.r, this.g, this.b), e = Math.max(this.r, this.g, this.b), o = e - t; let n; n = 0 === o ? 0 : this.r >= this.g && this.r >= this.b ? (this.g - this.b) / o % 6 : this.g >= this.r && this.g >= this.b ? (this.b - this.r) / o + 2 : (this.r - this.g) / o + 4, n *= 60, n *= Math.PI / 180, n < 0 && (n += 2 * Math.PI); const r = e, s = r > 0 ? o / r : 0; return i.default.of(n, s, r) } static fromHSV(t, e, o) { t < 0 && (t += 2 * Math.PI), t %= 2 * Math.PI; const n = (o = Math.max(0, Math.min(1, o))) * (e = Math.max(0, Math.min(1, e))), i = t / (Math.PI / 3), s = n * (1 - Math.abs(i % 2 - 1)); let a; a = i < 1 ? [n, s, 0] : i < 2 ? [s, n, 0] : i < 3 ? [0, n, s] : i < 4 ? [0, s, n] : i < 5 ? [s, 0, n] : [n, 0, s]; const l = o - n; return r.ofRGB(a[0] + l, a[1] + l, a[2] + l) } static fromRGBVector(t, e) { return r.ofRGBA(t.x, t.y, t.z, e ?? 1) } toHexString() { if (this.hexString) return this.hexString; const t = t => { const e = Math.round(255 * t).toString(16); return 1 === e.length ? `0${e}` : e }, e = t(this.a), o = t(this.r), n = t(this.g), i = t(this.b); return "ff" === e ? `#${o}${n}${i}` : (this.hexString = `#${o}${n}${i}${e}`, this.hexString) } toString() { return this.toHexString() } } e.Color4 = r, r.transparent = r.ofRGBA(0, 0, 0, 0), r.red = r.ofRGB(1, 0, 0), r.orange = r.ofRGB(1, .65, 0), r.green = r.ofRGB(0, 1, 0), r.blue = r.ofRGB(0, 0, 1), r.purple = r.ofRGB(.5, .2, .5), r.yellow = r.ofRGB(1, 1, .1), r.clay = r.ofRGB(.8, .4, .2), r.black = r.ofRGB(0, 0, 0), r.gray = r.ofRGB(.5, .5, .5), r.white = r.ofRGB(1, 1, 1), e.default = r }, 3128: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.Mat33 = void 0; const i = o(6742), r = n(o(4981)); class s { constructor(t, e, o, n, i, s, a, l, c) { this.a1 = t, this.a2 = e, this.a3 = o, this.b1 = n, this.b2 = i, this.b3 = s, this.c1 = a, this.c2 = l, this.c3 = c, this.cachedInverse = void 0, this.rows = [r.default.of(t, e, o), r.default.of(n, i, s), r.default.of(a, l, c)] } static ofRows(t, e, o) { return new s(t.x, t.y, t.z, e.x, e.y, e.z, o.x, o.y, o.z) } inverse() { return this.computeInverse() ?? s.identity } invertable() { return null !== this.computeInverse() } computeInverse() { if (void 0 !== this.cachedInverse) return this.cachedInverse; const t = [this.rows[0], this.rows[1], this.rows[2]], e = [r.default.unitX, r.default.unitY, r.default.unitZ]; for (let o = 0; o < 3; o++) { let n = t[o].at(o); const i = 1e-10; if (Math.abs(n) < i) { let r = -1; for (let e = 1; e <= 2; e++) { const n = (o + e) % 3; if (Math.abs(t[n].at(o)) >= i) { r = n; break } } if (-1 === r) return this.cachedInverse = null, null; const s = t[o], a = e[o]; t[o] = t[r], e[o] = e[r], t[r] = s, e[r] = a, n = t[o].at(o) } let r = 1 / n; t[o] = t[o].times(r), e[o] = e[o].times(r); const s = t[o], a = e[o]; for (let n = 1; n <= 2; n++) { const i = (o + n) % 3; r = -t[i].at(o), t[i] = t[i].plus(s.times(r)), e[i] = e[i].plus(a.times(r)) } } const o = s.ofRows(e[0], e[1], e[2]); return this.cachedInverse = o, o } transposed() { return new s(this.a1, this.b1, this.c1, this.a2, this.b2, this.c2, this.a3, this.b3, this.c3) } rightMul(t) { t = t.transposed(); const e = (e, o) => this.rows[e].dot(t.rows[o]); return new s(e(0, 0), e(0, 1), e(0, 2), e(1, 0), e(1, 1), e(1, 2), e(2, 0), e(2, 1), e(2, 2)) } transformVec2(t) { let e = r.default.of(t.x, t.y, 1); return e = this.transformVec3(e), i.Vec2.of(e.x, e.y) } transformVec3(t) { return r.default.of(this.rows[0].dot(t), this.rows[1].dot(t), this.rows[2].dot(t)) } isIdentity() { return this === s.identity || this.eq(s.identity) } eq(t, e = 0) { for (let o = 0; o < 3; o++)if (!this.rows[o].eq(t.rows[o], e)) return !1; return !0 } toString() { let t = ""; const e = [0, 0, 0]; for (const t of this.rows) for (let o = 0; o < 3; o++)e[o] = Math.max(e[0], `${t.at(o)}`.length); for (let o = 0; o < 3; o++) { t += 0 === o ? "⎡ " : 1 === o ? "⎢ " : "⎣ "; for (let n = 0; n < 3; n++) { const i = this.rows[o].at(n).toString(); let r = ""; for (let t = i.length; t < e[n]; t++)r += " "; t += i + ", " + r } t += 0 === o ? " ⎤" : 1 === o ? " ⎥" : " ⎦", t += "\n" } return t.trimEnd() } toArray() { return [this.a1, this.a2, this.a3, this.b1, this.b2, this.b3, this.c1, this.c2, this.c3] } mapEntries(t) { return new s(t(this.a1, [0, 0]), t(this.a2, [0, 1]), t(this.a3, [0, 2]), t(this.b1, [1, 0]), t(this.b2, [1, 1]), t(this.b3, [1, 2]), t(this.c1, [2, 0]), t(this.c2, [2, 1]), t(this.c3, [2, 2])) } getScaleFactor() { return Math.hypot(this.a1, this.a2) } getColumn(t) { return r.default.of(this.rows[0].at(t), this.rows[1].at(t), this.rows[2].at(t)) } maximumEntryMagnitude() { let t = Math.abs(this.a1); for (const e of this.toArray()) t = Math.max(t, Math.abs(e)); return t } static translation(t) { return new s(1, 0, t.x, 0, 1, t.y, 0, 0, 1) } static zRotation(t, e = i.Vec2.zero) { if (0 === t) return s.identity; const o = Math.cos(t), n = Math.sin(t); let r = s.translation(e); return r = r.rightMul(new s(o, -n, 0, n, o, 0, 0, 0, 1)), r.rightMul(s.translation(e.times(-1))) } static scaling2D(t, e = i.Vec2.zero) { let o, n, r = s.translation(e); return "number" == typeof t ? (o = t, n = t) : (o = t.x, n = t.y), r = r.rightMul(new s(o, 0, 0, 0, n, 0, 0, 0, 1)), r.rightMul(s.translation(e.times(-1))) } toCSSMatrix() { return `matrix(${this.a1},${this.b1},${this.a2},${this.b2},${this.a3},${this.b3})` } static fromCSSMatrix(t) { if ("" === t || "none" === t) return s.identity; t = t.trim().replace(/\s+/g, " "); const e = t => t.split(/[, \t\n]+/g).map((e => { if ("" === e.trim()) return null; let o = !1; e.endsWith("%") && (o = !0, e = e.substring(0, e.length - 1)), e = e.replace(/px$/gi, ""); if (!/^[-]?\d*(?:\.\d*)?(?:[eE][-+]?\d+)?$/i.exec(e)) throw new Error(`All arguments to transform functions must be numeric (state: ${JSON.stringify({ currentArgument: e, allArguments: t })})`); let n = parseFloat(e); return o && (n /= 100), n })).filter((t => null !== t)), o = { matrix: t => { if (6 !== t.length) throw new Error(`Invalid matrix argument: ${t}. Must have length 6`); const e = t[0], o = t[1], n = t[2], i = t[3], r = t[4], a = t[5]; return new s(e, n, r, o, i, a, 0, 0, 1) }, scale: t => { let e, o; if (1 === t.length) e = t[0], o = t[0]; else { if (2 !== t.length) throw new Error(`The scale() function only supports two arguments. Given: ${t}`); e = t[0], o = t[1] } return s.scaling2D(i.Vec2.of(e, o)) }, translate: t => { let e = 0, o = 0; if (1 === t.length) e = t[0]; else { if (2 !== t.length) throw new Error(`The translate() function requires either 1 or 2 arguments. Given ${t}`); e = t[0], o = t[1] } return s.translation(i.Vec2.of(e, o)) } }, n = /(?:^|\W)(\w+)\s?\(([^)]*)\)/gi; let r, a = null; for (; null !== (r = n.exec(t));) { const t = r[1].toLowerCase(); if (!(t in o)) throw new Error(`Unsupported CSS transform action: ${t}`); const n = e(r[2]), i = o[t](n); a = a ? a.rightMul(i) : i } return a ?? s.identity } } e.Mat33 = s, s.identity = new s(1, 0, 0, 0, 1, 0, 0, 0, 1), e.default = s }, 6742: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.Vec2 = e.Vec3 = void 0; const n = o(4981); Object.defineProperty(e, "Vec3", { enumerable: !0, get: function () { return n.Vec3 } }), Object.defineProperty(e, "Vec2", { enumerable: !0, get: function () { return n.Vec2 } }), e.default = n.Vec2 }, 4981: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.Vec3 = e.Vec2 = void 0; class o { constructor(t, e, o) { this.x = t, this.y = e, this.z = o } get xy() { return { x: this.x, y: this.y } } at(t) { if (0 === t) return this.x; if (1 === t) return this.y; if (2 === t) return this.z; throw new Error(`${t} out of bounds!`) } length() { return this.magnitude() } magnitude() { return Math.sqrt(this.magnitudeSquared()) } magnitudeSquared() { return this.x * this.x + this.y * this.y + this.z * this.z } squareDistanceTo(t) { const e = this.x - t.x, o = this.y - t.y, n = this.z - t.z; return e * e + o * o + n * n } distanceTo(t) { return Math.sqrt(this.squareDistanceTo(t)) } maximumEntryMagnitude() { return Math.max(Math.abs(this.x), Math.max(Math.abs(this.y), Math.abs(this.z))) } angle() { return Math.atan2(this.y, this.x) } normalized() { const t = this.magnitude(); return r.of(this.x / t, this.y / t, this.z / t) } normalizedOrZero() { return this.eq(r.zero) ? r.zero : this.normalized() } times(t) { return r.of(this.x * t, this.y * t, this.z * t) } plus(t) { return r.of(this.x + t.x, this.y + t.y, this.z + t.z) } minus(t) { return r.of(this.x - t.x, this.y - t.y, this.z - t.z) } dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z } cross(t) { return r.of(this.y * t.z - t.y * this.z, t.x * this.z - this.x * t.z, this.x * t.y - t.x * this.y) } scale(t) { return "number" == typeof t ? this.times(t) : r.of(this.x * t.x, this.y * t.y, this.z * t.z) } orthog() { return 0 === this.dot(r.unitX) && 0 === this.dot(r.unitY) ? 0 === this.dot(r.unitX) ? r.unitX : this.cross(r.unitX).normalized() : this.cross(r.unitZ.times(-1)).normalized() } extend(t, e) { return this.plus(e.normalized().times(t)) } lerp(t, e) { return this.times(1 - e).plus(t.times(e)) } zip(t, e) { return r.of(e(t.x, this.x), e(t.y, this.y), e(t.z, this.z)) } map(t) { return r.of(t(this.x, 0), t(this.y, 1), t(this.z, 2)) } asArray() { return [this.x, this.y, this.z] } eq(t, e = 1e-10) { return Math.abs(t.x - this.x) <= e && Math.abs(t.y - this.y) <= e && Math.abs(t.z - this.z) <= e } toString() { return `Vec(${this.x}, ${this.y}, ${this.z})` } } class n { constructor(t, e) { this.x = t, this.y = e } get z() { return 0 } get xy() { return { x: this.x, y: this.y } } at(t) { if (0 === t) return this.x; if (1 === t) return this.y; if (2 === t) return 0; throw new Error(`${t} out of bounds!`) } length() { return this.magnitude() } magnitude() { return Math.sqrt(this.x * this.x + this.y * this.y) } magnitudeSquared() { return this.x * this.x + this.y * this.y } squareDistanceTo(t) { const e = this.x - t.x, o = this.y - t.y; return e * e + o * o + t.z * t.z } distanceTo(t) { return Math.sqrt(this.squareDistanceTo(t)) } maximumEntryMagnitude() { return Math.max(Math.abs(this.x), Math.abs(this.y)) } angle() { return Math.atan2(this.y, this.x) } normalized() { const t = this.magnitude(); return i.of(this.x / t, this.y / t) } normalizedOrZero() { return this.eq(r.zero) ? r.zero : this.normalized() } times(t) { return i.of(this.x * t, this.y * t) } plus(t) { return r.of(this.x + t.x, this.y + t.y, t.z) } minus(t) { return r.of(this.x - t.x, this.y - t.y, -t.z) } dot(t) { return this.x * t.x + this.y * t.y } cross(t) { return r.of(this.y * t.z, -this.x * t.z, this.x * t.y - t.x * this.y) } scale(t) { return "number" == typeof t ? this.times(t) : i.of(this.x * t.x, this.y * t.y) } orthog() { return 0 === this.dot(r.unitX) && 0 === this.dot(r.unitY) ? 0 === this.dot(r.unitX) ? r.unitX : this.cross(r.unitX).normalized() : this.cross(r.unitZ.times(-1)).normalized() } extend(t, e) { return this.plus(e.normalized().times(t)) } lerp(t, e) { return this.times(1 - e).plus(t.times(e)) } zip(t, e) { return r.of(e(t.x, this.x), e(t.y, this.y), e(t.z, 0)) } map(t) { return r.of(t(this.x, 0), t(this.y, 1), t(0, 2)) } asArray() { return [this.x, this.y, 0] } eq(t, e = 1e-10) { return Math.abs(t.x - this.x) <= e && Math.abs(t.y - this.y) <= e && Math.abs(t.z) <= e } toString() { return `Vec(${this.x}, ${this.y})` } } var i, r; !function (t) { t.of = (t, e) => new n(t, e), t.ofXY = ({ x: e, y: o }) => t.of(e, o), t.unitX = t.of(1, 0), t.unitY = t.of(0, 1), t.zero = t.of(0, 0) }(i || (e.Vec2 = i = {})), function (t) { t.of = (t, e, n) => 0 === n ? i.of(t, e) : new o(t, e, n), t.unitX = i.unitX, t.unitY = i.unitY, t.zero = i.zero, t.unitZ = t.of(0, 0, 1) }(r || (e.Vec3 = r = {})), e.default = r }, 5379: function (t, e, o) { "use strict"; var n = this && this.__createBinding || (Object.create ? function (t, e, o, n) { void 0 === n && (n = o); var i = Object.getOwnPropertyDescriptor(e, o); i && !("get" in i ? !e.__esModule : i.writable || i.configurable) || (i = { enumerable: !0, get: function () { return e[o] } }), Object.defineProperty(t, n, i) } : function (t, e, o, n) { void 0 === n && (n = o), t[n] = e[o] }), i = this && this.__exportStar || function (t, e) { for (var o in t) "default" === o || Object.prototype.hasOwnProperty.call(e, o) || n(e, t, o) }; Object.defineProperty(e, "__esModule", { value: !0 }), e.Color4 = e.Vec3 = e.Vec2 = e.Mat33 = e.Abstract2DShape = e.QuadraticBezier = e.Parameterized2DShape = e.Rect2 = e.PathCommandType = e.comparePathIndices = e.stepPathIndexBy = e.Path = e.LineSegment2 = void 0; var r = o(3328); Object.defineProperty(e, "LineSegment2", { enumerable: !0, get: function () { return r.LineSegment2 } }); var s = o(5780); Object.defineProperty(e, "Path", { enumerable: !0, get: function () { return s.Path } }), Object.defineProperty(e, "stepPathIndexBy", { enumerable: !0, get: function () { return s.stepCurveIndexBy } }), Object.defineProperty(e, "comparePathIndices", { enumerable: !0, get: function () { return s.compareCurveIndices } }), Object.defineProperty(e, "PathCommandType", { enumerable: !0, get: function () { return s.PathCommandType } }); var a = o(683); Object.defineProperty(e, "Rect2", { enumerable: !0, get: function () { return a.Rect2 } }); var l = o(6831); Object.defineProperty(e, "Parameterized2DShape", { enumerable: !0, get: function () { return l.Parameterized2DShape } }); var c = o(9682); Object.defineProperty(e, "QuadraticBezier", { enumerable: !0, get: function () { return c.QuadraticBezier } }); var d = o(5150); Object.defineProperty(e, "Abstract2DShape", { enumerable: !0, get: function () { return d.Abstract2DShape } }); var h = o(3128); Object.defineProperty(e, "Mat33", { enumerable: !0, get: function () { return h.Mat33 } }); var u = o(6742); Object.defineProperty(e, "Vec2", { enumerable: !0, get: function () { return u.Vec2 } }); var p = o(4981); Object.defineProperty(e, "Vec3", { enumerable: !0, get: function () { return p.Vec3 } }); var f = o(5035); Object.defineProperty(e, "Color4", { enumerable: !0, get: function () { return f.Color4 } }), i(o(3606), e) }, 2364: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); e.default = (t, e, o) => { if (0 === t) { let t; return t = 0 === e ? 0 === o ? 0 : NaN : -o / e, [t, t] } const n = e * e - 4 * t * o; if (n < 0) return [NaN, NaN]; const i = Math.sqrt(n), r = (-e + i) / (2 * t), s = (-e - i) / (2 * t); return r > s ? [r, s] : [s, r] } }, 3760: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.cleanUpNumber = void 0; e.cleanUpNumber = t => { if (t.indexOf("e") > 0 && t.match(/[eE][-]\d{2,}$/)) return "0"; const e = t.charAt(t.length - 1); "0" !== e && "." !== e || (t = (t = (t = t.replace(/([.]\d*[^0])0+$/, "$1")).replace(/[.]0+$/, ".")).replace(/[.]$/, "")); const o = t.charAt(0); return "0" !== o && "-" !== o || (t = (t = (t = t.replace(/^(0+)[.]/, ".")).replace(/^-(0+)[.]/, "-.")).replace(/^(-?)0+$/, "$10")), "-0" === t ? "0" : t }, e.default = e.cleanUpNumber }, 1780: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.numberRegex = void 0, e.numberRegex = /^([-]?)(\d*)[.](\d+)$/ }, 8435: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.getLenAfterDecimal = void 0; const n = o(1780); e.getLenAfterDecimal = t => { const e = n.numberRegex.exec(t); if (!e) return -1 !== t.search(/[eE]/) || /^[a-zA-Z]+$/.exec(t) ? -1 : 0; return e[3].length }, e.default = e.getLenAfterDecimal }, 3606: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.toRoundedString = void 0; var n = o(858); Object.defineProperty(e, "toRoundedString", { enumerable: !0, get: function () { return n.toRoundedString } }) }, 858: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.toRoundedString = void 0; const i = n(o(3760)); e.toRoundedString = t => { let e = t.toString(10); if (-1 === e.indexOf(".")) return e; const o = /^([-]?)(\d*)\.(\d{3,}9{4,})\d{1,4}$/.exec(e); if (o) { const t = o[1], n = o[3], i = parseInt(n.charAt(n.length - 1), 10), r = parseInt(n, 10), s = parseInt(o[2], 10), a = o[3]; let l = (r + 10 - i).toString(), c = 0; for (l.length > r.toString().length && (l = l.substring(1), c = 1); l.length < a.length;)l = c.toString(10) + l, c = 0; e = `${t + (s + c).toString()}.${l}` } return e = e.replace(/^([-]?\d*\.\d{3,})0{4,}\d{1,4}$/, "$1"), (0, i.default)(e) }, e.default = e.toRoundedString }, 2568: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.toStringOfSamePrecision = void 0; const i = n(o(3760)), r = o(1780), s = n(o(8435)), a = n(o(858)); e.toStringOfSamePrecision = (t, ...e) => { const o = t.toString(10), n = r.numberRegex.exec(o); if (!n) return o; let l = -1; for (const t of e) l = Math.max((0, s.default)(t), l); if (-1 === l) return (0, a.default)(t); let c = n[3].substring(0, l), d = n[2]; const h = n[3].charAt(l); if ("" !== h) { if (parseInt(h, 10) >= 5) { if (c.length > 0) { const t = /^(0+)(\d*)$/.exec(c); let e = "", o = c; t && (e = t[1], o = t[2]), c = (parseInt(c) + 1).toString(), c.length > o.length && e.length > 0 && (e = e.substring(1)), c = e + c } (0 === c.length || c.length > l) && (d = (parseInt(d) + 1).toString(), c = c.substring(1)) } } const u = n[1]; return (0, i.default)(`${u}${d}.${c}`) }, e.default = e.toStringOfSamePrecision }, 5150: (t, e) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }), e.Abstract2DShape = void 0; class o { distance(t) { return Math.abs(this.signedDistance(t)) } containsPoint(t, e = o.smallValue) { return this.signedDistance(t) < e } getLooseBoundingBox() { return this.getTightBoundingBox() } } e.Abstract2DShape = o, o.smallValue = 1e-12, e.default = o }, 3212: function (t, e, o) { "use strict"; var n, i = this && this.__classPrivateFieldSet || function (t, e, o, n, i) { if ("m" === n) throw new TypeError("Private method is not writable"); if ("a" === n && !i) throw new TypeError("Private accessor was defined without a setter"); if ("function" == typeof e ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return "a" === n ? i.call(t, o) : i ? i.value = o : e.set(t, o), o }, r = this && this.__classPrivateFieldGet || function (t, e, o, n) { if ("a" === o && !n) throw new TypeError("Private accessor was defined without a getter"); if ("function" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return "m" === o ? n : "a" === o ? n.call(t) : n ? n.value : e.get(t) }, s = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.BezierJSWrapper = void 0; const a = o(5893), l = o(6742), c = s(o(3328)), d = s(o(683)), h = s(o(6831)); class u extends h.default { constructor(t) { super(), n.set(this, null), t && i(this, n, t, "f") } getBezier() { return r(this, n, "f") || i(this, n, new a.Bezier(this.getPoints().map((t => t.xy))), "f"), r(this, n, "f") } signedDistance(t) { return this.nearestPointTo(t).point.distanceTo(t) } distance(t) { return this.signedDistance(t) } at(t) { return l.Vec2.ofXY(this.getBezier().get(t)) } derivativeAt(t) { return l.Vec2.ofXY(this.getBezier().derivative(t)) } secondDerivativeAt(t) { return l.Vec2.ofXY(this.getBezier().dderivative(t)) } normal(t) { return l.Vec2.ofXY(this.getBezier().normal(t)) } normalAt(t) { return this.normal(t) } tangentAt(t) { return this.derivativeAt(t).normalized() } getTightBoundingBox() { const t = this.getBezier().bbox(), e = t.x.max - t.x.min, o = t.y.max - t.y.min; return new d.default(t.x.min, t.y.min, e, o) } argIntersectsLineSegment(t) { const e = c.default.ofSmallestContainingPoints(this.getPoints()); if (e) { return e.intersectsLineSegment(t).map((t => this.nearestPointTo(t).parameterValue)) } return this.getBezier().intersects(t).map((e => { "string" == typeof e && (e = parseFloat(e)); const o = l.Vec2.ofXY(this.at(e)); return o.distanceTo(t.p1) > t.length || o.distanceTo(t.p2) > t.length ? null : e })).filter((t => null !== t)) } splitAt(t) { if (t <= 0 || t >= 1) return [this]; const e = this.getBezier().split(t); return [new p(e.left.points.map((t => l.Vec2.ofXY(t))), e.left), new p(e.right.points.map((t => l.Vec2.ofXY(t))), e.right)] } nearestPointTo(t) { const e = e => t.squareDistanceTo(this.at(e)), o = e(0); let n = 0, i = o; for (let t = 0; t < 4; t++) { const o = t / 3, r = e(o); r < i && (n = o, i = r) } const r = e => { const o = this.at(e), n = this.derivativeAt(e), i = this.secondDerivativeAt(e); return 2 * n.x * n.x + 2 * o.x * i.x - 2 * t.x * i.x + 2 * n.y * n.y + 2 * o.y * i.y - 2 * t.y * i.y }, s = e => { const o = this.at(e), n = this.derivativeAt(e); return 2 * o.x * n.x - 2 * t.x * n.x + 2 * o.y * n.y - 2 * t.y * n.y }, a = () => { const t = r(n); if (0 === t) return; const e = (0 - s(n)) / t + n; n = e, n > 1 ? n = 1 : n < 0 && (n = 0) }; for (let t = 0; t < 12; t++)a(); return { parameterValue: n, point: this.at(n) } } intersectsBezier(t) { const e = this.getBezier().intersects(t.getBezier()); if (!e || 0 === e.length) return []; const o = []; for (const t of e) { const n = /^([-0-9.eE]+)\/([-0-9.eE]+)$/.exec(t); if (!n) throw new Error(`Incorrect format returned by .intersects: ${e} should be array of "number/number"!`); const i = parseFloat(n[1]); o.push({ parameterValue: i, point: this.at(i) }) } return o } toString() { return `Bézier(${this.getPoints().map((t => t.toString())).join(", ")})` } } e.BezierJSWrapper = u, n = new WeakMap; class p extends u { constructor(t, e) { super(e), this.controlPoints = t } getPoints() { return this.controlPoints } } e.default = u }, 1834: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = n(o(3212)), r = n(o(683)); class s extends i.default { constructor(t, e, o, n) { super(), this.p0 = t, this.p1 = e, this.p2 = o, this.p3 = n } getPoints() { return [this.p0, this.p1, this.p2, this.p3] } getLooseBoundingBox() { return r.default.bboxOf([this.p0, this.p1, this.p2, this.p3]) } } e.default = s }, 3328: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.LineSegment2 = void 0; const i = n(o(683)), r = o(6742), s = n(o(6831)); class a extends s.default { constructor(t, e) { super(), this.point1 = t, this.point2 = e, this.bbox = i.default.bboxOf([t, e]), this.direction = e.minus(t), this.length = this.direction.magnitude(), this.length > 0 && (this.direction = this.direction.times(1 / this.length)) } static ofSmallestContainingPoints(t) { if (t.length <= 1) return null; const e = [...t].sort(((t, e) => t.x !== e.x ? t.x - e.x : t.y - e.y)), o = new a(e[0], e[e.length - 1]); for (const t of e) if (!o.containsPoint(t)) return null; return o } get p1() { return this.point1 } get p2() { return this.point2 } get center() { return this.point1.lerp(this.point2, .5) } get(t) { return this.point1.plus(this.direction.times(t)) } at(t) { return this.get(t * this.length) } normalAt(t) { return this.direction.orthog() } tangentAt(t) { return this.direction } splitAt(t) { return t <= 0 || t >= 1 ? [this] : [new a(this.point1, this.at(t)), new a(this.at(t), this.point2)] } intersection(t) { let e, o; if (Math.abs(this.direction.x) < 4e-13) { if (0 === t.direction.x || 0 === this.direction.y) return null; const n = this.point1.x, i = (this.point1.x - t.point1.x) * t.direction.y / t.direction.x + t.point1.y; e = r.Vec2.of(n, i), o = (i - this.point1.y) / this.direction.y } else { const n = (this.point1.y - t.point1.y) * this.direction.x * t.direction.x + this.direction.x * t.direction.y * t.point1.x - this.direction.y * t.direction.x * this.point1.x, i = t.direction.y * this.direction.x - this.direction.y * t.direction.x; if (0 === i) return null; const s = n / i, a = (s - this.point1.x) / this.direction.x, l = this.point1.y + this.direction.y * a; e = r.Vec2.of(s, l), o = (s - this.point1.x) / this.direction.x } const n = e.distanceTo(this.point1), i = e.distanceTo(this.point2), s = e.distanceTo(t.point1), a = e.distanceTo(t.point2); return n > this.length || i > this.length || s > t.length || a > t.length ? null : { point: e, t: o } } intersects(t) { return null !== this.intersection(t) } argIntersectsLineSegment(t) { const e = this.intersection(t); return e ? [e.t / this.length] : [] } intersectsLineSegment(t) { const e = this.intersection(t); return e ? [e.point] : [] } closestPointTo(t) { return this.nearestPointTo(t).point } nearestPointTo(t) { const e = t.minus(this.p1).dot(this.direction), o = this.length - e, n = this.p1.plus(this.direction.times(e)); return e > 0 && e < this.length ? { point: n, parameterValue: e / this.length } : Math.abs(o) < Math.abs(e) ? { point: this.p2, parameterValue: 1 } : { point: this.p1, parameterValue: 0 } } signedDistance(t) { return this.closestPointTo(t).minus(t).magnitude() } transformedBy(t) { return new a(t.transformVec2(this.p1), t.transformVec2(this.p2)) } getTightBoundingBox() { return this.bbox } toString() { return `LineSegment(${this.p1.toString()}, ${this.p2.toString()})` } eq(t, e) { if (!(t instanceof a)) return !1; const o = e?.tolerance, n = e?.ignoreDirection ?? !0; return t.p1.eq(this.p1, o) && t.p2.eq(this.p2, o) || n && t.p1.eq(this.p2, o) && t.p2.eq(this.p1, o) } } e.LineSegment2 = a, e.default = a }, 6831: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.Parameterized2DShape = void 0; const i = n(o(5150)); class r extends i.default { intersectsLineSegment(t) { return this.argIntersectsLineSegment(t).map((t => this.at(t))) } } e.Parameterized2DShape = r, e.default = r }, 5780: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.Path = e.stepCurveIndexBy = e.compareCurveIndices = e.PathCommandType = void 0; const i = n(o(3328)), r = n(o(683)), s = o(6742), a = n(o(1834)), l = n(o(9682)), c = n(o(4502)), d = n(o(858)), h = n(o(2568)), u = n(o(1477)); var p; !function (t) { t[t.LineTo = 0] = "LineTo", t[t.MoveTo = 1] = "MoveTo", t[t.CubicBezierTo = 2] = "CubicBezierTo", t[t.QuadraticBezierTo = 3] = "QuadraticBezierTo" }(p || (e.PathCommandType = p = {})); e.compareCurveIndices = (t, e) => { const o = t.curveIndex - e.curveIndex; return 0 === o ? t.parameterValue - e.parameterValue : o }; e.stepCurveIndexBy = (t, e) => t.parameterValue + e > 1 ? { curveIndex: t.curveIndex + 1, parameterValue: t.parameterValue + e - 1 } : t.parameterValue + e < 0 ? 0 === t.curveIndex ? { curveIndex: 0, parameterValue: 0 } : { curveIndex: t.curveIndex - 1, parameterValue: t.parameterValue + e + 1 } : { curveIndex: t.curveIndex, parameterValue: t.parameterValue + e }; class f { constructor(t, e) { this.startPoint = t, this.cachedGeometry = null, this.cachedPolylineApproximation = null, this.cachedStringVersion = null, this.parts = e, this.bbox = r.default.bboxOf([t]); for (const e of this.parts) this.bbox = this.bbox.union(f.computeBBoxForSegment(t, e)) } getExactBBox() { const t = []; for (const e of this.geometry) t.push(e.getTightBoundingBox()); return r.default.union(...t) } get geometry() { if (this.cachedGeometry) return this.cachedGeometry; let t = this.startPoint; const e = []; for (const o of this.parts) { let n; switch (o.kind) { case p.CubicBezierTo: e.push(new a.default(t, o.controlPoint1, o.controlPoint2, o.endPoint)), t = o.endPoint; break; case p.QuadraticBezierTo: e.push(new l.default(t, o.controlPoint, o.endPoint)), t = o.endPoint; break; case p.LineTo: e.push(new i.default(t, o.point)), t = o.point; break; case p.MoveTo: e.push(new c.default(o.point)), t = o.point; break; default: return n = o, n } } return this.cachedGeometry = e, this.cachedGeometry } *startEndPoints() { yield this.startPoint; for (const t of this.parts) { let e; switch (t.kind) { case p.CubicBezierTo: case p.QuadraticBezierTo: yield t.endPoint; break; case p.LineTo: case p.MoveTo: yield t.point; break; default: return e = t, e } } } polylineApproximation() { if (this.cachedPolylineApproximation) return this.cachedPolylineApproximation; const t = []; for (const e of this.parts) switch (e.kind) { case p.CubicBezierTo: t.push(e.controlPoint1, e.controlPoint2, e.endPoint); break; case p.QuadraticBezierTo: t.push(e.controlPoint, e.endPoint); break; case p.MoveTo: case p.LineTo: t.push(e.point) }const e = []; let o = this.startPoint; for (const n of t) e.push(new i.default(o, n)), o = n; return e } static computeBBoxForSegment(t, e) { const o = [t]; let n; switch (e.kind) { case p.MoveTo: case p.LineTo: o.push(e.point); break; case p.CubicBezierTo: o.push(e.controlPoint1, e.controlPoint2, e.endPoint); break; case p.QuadraticBezierTo: o.push(e.controlPoint, e.endPoint); break; default: return n = e, n }return r.default.bboxOf(o) } signedDistance(t, e) { let o = 1 / 0; for (const n of this.geometry) { const i = n.signedDistance(t) - e; i < o && (o = i) } return o } raymarchIntersectionWith(t, e, o = []) { if (!t.bbox.intersects(this.bbox.grownBy(e))) return []; const n = t.length, i = []; for (const o of this.geometry) { const r = o.getTightBoundingBox().grownBy(e); if (!r.intersects(t.bbox)) continue; const s = t => o.signedDistance(t), a = t => s(t) - e; a(t.p1) > n && a(t.p2) > n || i.push({ part: o, distFn: s, bbox: r }) } if (0 === i.length) return []; const r = t => { let o = 1 / 0, n = null; const r = []; for (const e of i) { const { part: i, distFn: s, bbox: a } = e; if (!a.containsPoint(t)) { r.push(e); continue } const l = s(t); l <= o && (o = l, n = i) } for (const { part: e, distFn: i, bbox: s } of r) { if (isFinite(o) && !s.grownBy(o).containsPoint(t)) continue; const r = i(t); r <= o && (o = r, n = e) } return [n, o - e] }, s = [t.p1, ...o, t.p2], a = e => e.minus(t.p1).dot(t.direction); s.sort(((t, e) => a(t) - a(e))); const l = [], c = e / 1e3, d = (o, i, s) => { let d = o, [h, u] = r(d), p = a(d); if (u > n) return p; const f = t.direction.times(i); for (let t = 0; t < 8; t++) { const t = u; if (d = d.plus(f.times(t)), p = a(d), p <= s) return p; const [e, o] = r(d); if (Math.abs(o) > Math.abs(u)) return null; if (u = o, h = e, Math.abs(u) < c) break } if (h && (p >= 0 && p <= n) && Math.abs(u) < c) { l.push({ point: d, parameterValue: h.nearestPointTo(d).parameterValue, curve: h, curveIndex: this.geometry.indexOf(h) }); const o = e / 20 / t.length; p += isFinite(o) ? o : 0 } return p }; let h = 0; for (let t = 0; t < s.length; t++) { const e = s[t]; h = Math.max(h, d(e, 1, h) ?? h), h = Math.max(h, d(e, -1, h) ?? h) } return l } intersection(t, e) { let o = []; if (!t.bbox.intersects(this.bbox.grownBy(e ?? 0))) return []; if (0 === this.parts.length) return new f(this.startPoint, [{ kind: p.MoveTo, point: this.startPoint }]).intersection(t, e); let n = 0; for (const e of this.geometry) { const i = e.argIntersectsLineSegment(t); for (const t of i) o.push({ curve: e, curveIndex: n, point: e.at(t), parameterValue: t }); n++ } if (e && e > 1e-8) { const n = o.map((t => t.point)); o = this.raymarchIntersectionWith(t, e, n) } return o } nearestPointTo(t) { let e = 1 / 0, o = 0, n = 0, i = this.startPoint; for (let r = 0; r < this.geometry.length; r++) { const s = this.geometry[r].nearestPointTo(t), a = s.point.squareDistanceTo(t); (0 === r || a < e) && (o = r, e = a, n = s.parameterValue, i = s.point) } return { curve: this.geometry[o], curveIndex: o, parameterValue: n, point: i } } at(t) { return 0 === t.curveIndex && 0 === t.parameterValue ? this.startPoint : this.geometry[t.curveIndex].at(t.parameterValue) } tangentAt(t) { return this.geometry[t.curveIndex].tangentAt(t.parameterValue) } splitNear(t, e) { const o = this.nearestPointTo(t); return this.splitAt(o, e) } spliced(t, e, o, n) { if (r = e, (i = t).curveIndex < r.curveIndex || i.curveIndex === r.curveIndex && i.parameterValue <= r.parameterValue) { const i = this.splitAt(t, n), r = this.splitAt(e, n), s = i[0], a = r[r.length - 1]; return o ? s.union(o).union(a) : s.union(a) } { const i = this.splitAt([t], n)[0].splitNear(this.at(e), n), r = i[i.length - 1]; return o ? r.union(o) : r } var i, r } splitAt(t, o) { for (Array.isArray(t) || (t = [t]), (t = [...t]).sort(e.compareCurveIndices); t.length > 0 && t[t.length - 1].curveIndex >= this.parts.length - 1 && t[t.length - 1].parameterValue >= 1;)t.pop(); for (t.reverse(); t.length > 0 && t[t.length - 1].curveIndex <= 0 && t[t.length - 1].parameterValue <= 0;)t.pop(); if (0 === t.length || 0 === this.parts.length) return [this]; const n = t.length + 1, i = o?.mapNewPoint ?? (t => t), r = []; let s = this.startPoint, a = [], { curveIndex: l, parameterValue: c } = t.pop(); for (let e = 0; e < this.parts.length; e++)if (e !== l) a.push(this.parts[e]); else { let o = this.parts[e], n = this.geometry[e]; for (; e === l;) { let d; const h = []; switch (o.kind) { case p.MoveTo: a.push({ kind: o.kind, point: o.point }), d = o.point; break; case p.LineTo: { const t = n.splitAt(c); a.push({ kind: o.kind, point: i(t[0].p2) }), d = t[0].p2, t.length > 1 && (console.assert(2 === t.length), h.push({ kind: o.kind, point: t[1].p2 }), n = t[1]) } break; case p.QuadraticBezierTo: case p.CubicBezierTo: { const t = n.splitAt(c); let e = 2 === t.length; for (const r of t) { n = r; const t = e ? a : h, s = r.getPoints(); o.kind === p.CubicBezierTo ? t.push({ kind: o.kind, controlPoint1: i(s[1]), controlPoint2: i(s[2]), endPoint: i(s[3]) }) : t.push({ kind: o.kind, controlPoint: i(s[1]), endPoint: i(s[2]) }), e || (d = s[0]), e = !1 } } break; default: return o }r.push(new f(s, [...a])), s = i(d), console.assert(!!s, "should have a start point"), a = h, o = h[h.length - 1] ?? o; const u = t.pop(); if (!u) break; if (l = u.curveIndex, e === l) { const t = this.at(u); c = n.nearestPointTo(t).parameterValue, a = [] } else c = u.parameterValue } } return r.push(new f(s, a)), console.assert(r.length === n, `should split into splitAt.length + 1 splits (was ${r.length}, expected ${n})`), r } asClosed() { const t = []; let e = !1; for (const o of this.parts) o.kind === p.MoveTo ? (t.push({ kind: p.LineTo, point: o.point }), e = !0) : t.push(o); if (this.getEndPoint().eq(this.startPoint) || (t.push({ kind: p.LineTo, point: this.startPoint }), e = !0), !e) return this; const o = new f(this.startPoint, t); return console.assert(o.getEndPoint().eq(o.startPoint)), o } static mapPathCommand(t, e) { switch (t.kind) { case p.MoveTo: case p.LineTo: return { kind: t.kind, point: e(t.point) }; case p.CubicBezierTo: return { kind: t.kind, controlPoint1: e(t.controlPoint1), controlPoint2: e(t.controlPoint2), endPoint: e(t.endPoint) }; case p.QuadraticBezierTo: return { kind: t.kind, controlPoint: e(t.controlPoint), endPoint: e(t.endPoint) } }return t } mapPoints(t) { const e = t(this.startPoint), o = []; for (const e of this.parts) o.push(f.mapPathCommand(e, t)); return new f(e, o) } transformedBy(t) { return t.isIdentity() ? this : this.mapPoints((e => t.transformVec2(e))) } closedContainsPoint(t) { const e = this.getExactBBox(); if (!e.containsPoint(t)) return !1; const o = t.plus(s.Vec2.of(e.width, 0)), n = this.asClosed(), r = new i.default(t, o); return n.intersection(r).length % 2 == 1 } union(t, e = { allowReverse: !0 }) { if (!t) return this; if (Array.isArray(t)) return new f(this.startPoint, [...this.parts, ...t]); let o = []; if (this.getEndPoint().eq(t.startPoint)) o = this.parts.concat(t.parts); else { if (e.allowReverse && this.startPoint.eq(t.getEndPoint())) return t.union(this, { allowReverse: !1 }); if (e.allowReverse && this.startPoint.eq(t.startPoint)) return this.union(t.reversed(), { allowReverse: !1 }); o = [...this.parts, { kind: p.MoveTo, point: t.startPoint }, ...t.parts] } return new f(this.startPoint, o) } reversed() { const t = this.getEndPoint(), e = []; let o = this.startPoint; for (const t of this.parts) switch (t.kind) { case p.LineTo: case p.MoveTo: e.push({ kind: t.kind, point: o }), o = t.point; break; case p.CubicBezierTo: e.push({ kind: t.kind, controlPoint1: t.controlPoint2, controlPoint2: t.controlPoint1, endPoint: o }), o = t.endPoint; break; case p.QuadraticBezierTo: e.push({ kind: t.kind, controlPoint: t.controlPoint, endPoint: o }), o = t.endPoint; break; default: return t }return e.reverse(), new f(t, e) } getEndPoint() { if (0 === this.parts.length) return this.startPoint; const t = this.parts[this.parts.length - 1]; return t.kind === p.QuadraticBezierTo || t.kind === p.CubicBezierTo ? t.endPoint : t.point } roughlyIntersects(t, e = 0) { if (0 === this.parts.length) return t.containsPoint(this.startPoint); if (this.startPoint.eq(this.getEndPoint()) && 0 === e) return this.closedRoughlyIntersects(t); if (t.containsRect(this.bbox)) return !0; let o = this.startPoint; for (const n of this.parts) { const i = f.computeBBoxForSegment(o, n).grownBy(e); if (o = n.kind === p.LineTo || n.kind === p.MoveTo ? n.point : n.endPoint, t.intersects(i)) return !0 } return !1 } closedRoughlyIntersects(t) { if (t.containsRect(this.bbox)) return !0; const e = this.bbox.topLeft.minus(s.Vec2.of(1, 1)), o = t.corners, n = this.polylineApproximation(); for (const t of o) { const o = new i.default(t, e); let r = 0; for (const t of n) t.intersects(o) && r++; if (r % 2 == 1) return !0 } const r = t.grownBy(Math.min(t.size.x, t.size.y)), a = []; for (const t of r.divideIntoGrid(4, 4)) a.push(...t.getEdges()); for (const t of a) for (const e of n) if (t.intersects(e)) return !0; return !1 } eq(t, e) { if (t.parts.length !== this.parts.length) return !1; for (let o = 0; o < this.parts.length; o++) { const n = this.parts[o], i = t.parts[o]; switch (n.kind) { case p.LineTo: case p.MoveTo: if (n.kind !== i.kind) return !1; if (!n.point.eq(i.point, e)) return !1; break; case p.CubicBezierTo: if (n.kind !== i.kind) return !1; if (!n.controlPoint1.eq(i.controlPoint1, e) || !n.controlPoint2.eq(i.controlPoint2, e) || !n.endPoint.eq(i.endPoint, e)) return !1; break; case p.QuadraticBezierTo: if (n.kind !== i.kind) return !1; if (!n.controlPoint.eq(i.controlPoint, e) || !n.endPoint.eq(i.endPoint, e)) return !1; break; default: return n } } return !0 } static fromRect(t, e = null) { const o = []; let n, i; if (null !== e) { const o = s.Vec2.of(e, e).times(.5), a = r.default.fromCorners(t.topLeft.plus(o), t.bottomRight.minus(o)), l = r.default.fromCorners(t.topLeft.minus(o), t.bottomRight.plus(o)); n = [a.corners[3], ...a.corners, ...l.corners.reverse()], i = l.corners[3] } else n = t.corners.slice(1), i = t.corners[0]; for (const t of n) o.push({ kind: p.LineTo, point: t }); return o.push({ kind: p.LineTo, point: i }), new f(i, o) } toString(t, e = !1) { if (this.cachedStringVersion && !e) return this.cachedStringVersion; void 0 === t && (t = Math.abs(this.bbox.topLeft.x) > 10 && Math.abs(this.bbox.topLeft.y) > 10); const o = f.toString(this.startPoint, this.parts, !t); return this.cachedStringVersion = o, o } serialize() { return this.toString() } static toString(t, e, o) { const n = []; let i; const r = (t, ...e) => { const r = [], s = [], a = !i || o, l = i ? (0, d.default)(i.x) : "", c = i ? (0, d.default)(i.y) : ""; for (const t of e) { const e = (0, d.default)(t.x), o = (0, d.default)(t.y); if (a) r.push(`${e},${o}`); else { const n = (0, h.default)(t.x - i.x, e, l, c), r = (0, h.default)(t.y - i.y, o, l, c); "-" === r.charAt(0) ? s.push(`${n}${r}`) : s.push(`${n},${r}`) } } let u; u = a ? `${t}${r.join(" ")}` : `${t.toLowerCase()}${s.join(" ")}`, "l0,0" !== u && "m0,0" !== u && (n.push(u), e.length > 0 && (i = e[e.length - 1])) }; let s; e[0]?.kind !== p.MoveTo && r("M", t); for (let t = 0; t < e.length; t++) { const o = e[t]; switch (o.kind) { case p.MoveTo: r("M", o.point); break; case p.LineTo: r("L", o.point); break; case p.CubicBezierTo: r("C", o.controlPoint1, o.controlPoint2, o.endPoint); break; case p.QuadraticBezierTo: r("Q", o.controlPoint, o.endPoint); break; default: return s = o, s } } return n.join("") } static fromString(t) { t = t.split("\n").join(" "); let e = s.Vec2.zero, o = null, n = null, i = !0; const r = [], a = t => { i ? i = !1 : r.push({ kind: p.LineTo, point: t }) }, l = { m: 1, l: 1, c: 3, q: 2, z: 0, h: 1, v: 1 }, c = /([MZLHVCSQTA])\s*([^MZLHVCSQTA]*)/gi; let d; for (; null !== (d = c.exec(t));) { const t = d[2].trim().split(/[^0-9Ee.-]/).filter((t => t.length > 0)).reduce(((t, e) => { const o = (e = e.replace(/([^eE])[-]/g, "$1 -")).split(" -"); return "" !== o[0] && t.push(o[0]), t.push(...o.slice(1).map((t => `-${t}`))), t }), []); let c = t.map((t => parseFloat(t))), f = d[1].toLowerCase(), v = d[1] !== f; if ("v" === f || "h" === f) c = c.reduce(((t, o) => "v" === f ? t.concat(v ? e.x : 0, o) : t.concat(o, v ? e.y : 0)), []), f = "l"; else if ("z" === f) { if (!o) continue; c = [o.x, o.y], o = e, v = !0, f = "l" } const x = l[f] ?? 0, w = c.reduce(((t, e, o, n) => { if (o % 2 != 0) { const i = e, r = n[o - 1]; return t.concat(s.Vec2.of(r, i)) } return t }), []).map(((t, o) => { let n; return n = v ? t : e.plus(t), (o + 1) % x == 0 && (e = n), n })); if (w.length % x != 0) throw new Error([`Incorrect number of arguments: got ${JSON.stringify(w)} with a length of ${w.length} ≠ ${x}k, k ∈ ℤ.`, `The number of arguments to ${f} must be a multiple of ${x}!`, `Command: ${d[0]}`].join("\n")); for (let t = 0; t < w.length; t += x) { const e = w.slice(t, t + x); switch (f.toLowerCase()) { case "m": 0 === t ? (y = e[0], i ? i = !1 : r.push({ kind: p.MoveTo, point: y })) : a(e[0]); break; case "l": a(e[0]); break; case "c": m = e[0], g = e[1], b = e[2], r.push({ kind: p.CubicBezierTo, controlPoint1: m, controlPoint2: g, endPoint: b }); break; case "q": h = e[0], u = e[1], r.push({ kind: p.QuadraticBezierTo, controlPoint: h, endPoint: u }); break; default: throw new Error(`Unknown path command ${f}`) }i = !1 } w.length > 0 && (o ??= w[0], n ??= o, e = w[w.length - 1]) } var h, u, m, g, b, y; const v = new f(n ?? s.Vec2.zero, r); return v.cachedStringVersion = t, v } static fromConvexHullOf(t) { if (0 === t.length) return f.empty; const e = (0, u.default)(t), o = e.slice(1).map((t => ({ kind: p.LineTo, point: t }))); return o.push({ kind: p.LineTo, point: e[0] }), new f(e[0], o) } } e.Path = f, f.empty = new f(s.Vec2.zero, []), e.default = f }, 4502: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }); const i = o(6742), r = n(o(6831)), s = n(o(683)); class a extends r.default { constructor(t) { super(), this.p = t } signedDistance(t) { return this.p.distanceTo(t) } argIntersectsLineSegment(t, e) { return t.containsPoint(this.p, e) ? [0] : [] } getTightBoundingBox() { return new s.default(this.p.x, this.p.y, 0, 0) } at(t) { return this.p } normalAt(t) { return i.Vec2.unitY } tangentAt(t) { return i.Vec2.unitX } splitAt(t) { return [this] } nearestPointTo(t) { return { point: this.p, parameterValue: 0 } } } e.default = a }, 9682: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.QuadraticBezier = void 0; const i = o(6742), r = n(o(2364)), s = n(o(3212)), a = n(o(683)); class l extends s.default { constructor(t, e, o) { super(), this.p0 = t, this.p1 = e, this.p2 = o } static componentAt(t, e, o, n) { return e + t * (-2 * e + 2 * o) + t * t * (e - 2 * o + n) } static derivativeComponentAt(t, e, o, n) { return -2 * e + 2 * o + 2 * t * (e - 2 * o + n) } static secondDerivativeComponentAt(t, e, o, n) { return 2 * (e - 2 * o + n) } at(t) { if (0 === t) return this.p0; if (1 === t) return this.p2; const e = this.p0, o = this.p1, n = this.p2; return i.Vec2.of(l.componentAt(t, e.x, o.x, n.x), l.componentAt(t, e.y, o.y, n.y)) } derivativeAt(t) { const e = this.p0, o = this.p1, n = this.p2; return i.Vec2.of(l.derivativeComponentAt(t, e.x, o.x, n.x), l.derivativeComponentAt(t, e.y, o.y, n.y)) } secondDerivativeAt(t) { const e = this.p0, o = this.p1, n = this.p2; return i.Vec2.of(l.secondDerivativeComponentAt(t, e.x, o.x, n.x), l.secondDerivativeComponentAt(t, e.y, o.y, n.y)) } normal(t) { return this.derivativeAt(t).orthog().normalized() } getLooseBoundingBox() { return a.default.bboxOf([this.p0, this.p1, this.p2]) } approximateDistance(t) { const e = this.p0.x - t.x, o = -2 * this.p0.x + 2 * this.p1.x, n = this.p0.x - 2 * this.p1.x + this.p2.x, i = this.p0.y - t.y, s = -2 * this.p0.y + 2 * this.p1.y, a = this.p0.y - 2 * this.p1.y + this.p2.y, l = 2 * e * o + 2 * i * s - t.x * o - t.y * s, c = 2 * o * o + 2 * s * s + 2 * n * e + 2 * a * i - t.x * n - t.y * a, d = 2 * (2 * s * a + 2 * o * n + 2 * n * o + 2 * a * s); let [h, u] = (0, r.default)(d / 2, c, l); isNaN(h) && (h = .25), isNaN(u) && (u = .75); const p = this.at(h), f = this.at(u), m = p.squareDistanceTo(t), g = f.squareDistanceTo(t), b = this.at(0).squareDistanceTo(t), y = this.at(1).squareDistanceTo(t); return Math.sqrt(Math.min(m, g, b, y)) } getPoints() { return [this.p0, this.p1, this.p2] } } e.QuadraticBezier = l, e.default = l }, 683: function (t, e, o) { "use strict"; var n = this && this.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(e, "__esModule", { value: !0 }), e.Rect2 = void 0; const i = n(o(3328)), r = n(o(3128)), s = o(6742), a = n(o(5150)); class l extends a.default { constructor(t, e, o, n) { super(), this.x = t, this.y = e, this.w = o, this.h = n, o < 0 && (this.x += o, this.w = Math.abs(o)), n < 0 && (this.y += n, this.h = Math.abs(n)), this.topLeft = s.Vec2.of(this.x, this.y), this.size = s.Vec2.of(this.w, this.h), this.area = this.w * this.h } translatedBy(t) { return new l(t.x + this.x, t.y + this.y, this.w, this.h) } resizedTo(t) { return new l(this.x, this.y, t.x, t.y) } containsPoint(t) { return this.x <= t.x && this.y <= t.y && this.x + this.w >= t.x && this.y + this.h >= t.y } containsRect(t) { return this.x <= t.x && this.y <= t.y && this.x + this.w >= t.x + t.w && this.y + this.h >= t.y + t.h } intersects(t) { const e = this.x, o = e + this.w, n = t.x, i = t.x + t.w; if (o < n || e > i) return !1; const r = this.y, s = r + this.h, a = t.y, l = t.y + t.h; return !(s < a || r > l) } intersection(t) { if (!this.intersects(t)) return null; const e = this.topLeft.zip(t.topLeft, Math.max), o = this.bottomRight.zip(t.bottomRight, Math.min); return l.fromCorners(e, o) } union(t) { return l.union(this, t) } divideIntoGrid(t, e) { const o = []; if (t <= 0 || e <= 0) return o; const n = this.w / t, i = this.h / e; 0 === n && (t = 1), 0 === i && (e = 1); for (let r = 0; r < e; r++)for (let e = 0; e < t; e++) { const t = n * e + this.x, s = i * r + this.y; o.push(new l(t, s, n, i)) } return o } grownToPoint(t, e = 0) { const o = new l(t.x - e, t.y - e, 2 * e, 2 * e); return this.union(o) } grownBy(t) { if (0 === t) return this; if (t < 0) { const e = -Math.min(-t, this.w / 2), o = -Math.min(-t, this.h / 2); return new l(this.x - e, this.y - o, this.w + 2 * e, this.h + 2 * o) } return new l(this.x - t, this.y - t, this.w + 2 * t, this.h + 2 * t) } getClosestPointOnBoundaryTo(t) { const e = this.getEdges().map((e => e.closestPointTo(t))); let o = null, n = null; for (const i of e) { const e = i.distanceTo(t); (null === n || e < n) && (o = i, n = e) } return o } isWithinRadiusOf(t, e) { if (this.maxDimension > t) return !1; const o = t * t; return this.corners.every((t => t.minus(e).magnitudeSquared() < o)) } get corners() { return [this.bottomRight, this.topRight, this.topLeft, this.bottomLeft] } get maxDimension() { return Math.max(this.w, this.h) } get minDimension() { return Math.min(this.w, this.h) } get bottomRight() { return this.topLeft.plus(this.size) } get topRight() { return this.bottomRight.plus(s.Vec2.of(0, -this.h)) } get bottomLeft() { return this.topLeft.plus(s.Vec2.of(0, this.h)) } get width() { return this.w } get height() { return this.h } get center() { return s.Vec2.of(this.x + this.w / 2, this.y + this.h / 2) } getEdges() { const t = this.corners; return [new i.default(t[0], t[1]), new i.default(t[1], t[2]), new i.default(t[2], t[3]), new i.default(t[3], t[0])] } intersectsLineSegment(t) { const e = []; for (const o of this.getEdges()) { o.intersectsLineSegment(t).forEach((t => e.push(t))) } return e } signedDistance(t) { const e = this.getClosestPointOnBoundaryTo(t), o = t.minus(e).magnitude(); return this.containsPoint(t) ? -o : o } getTightBoundingBox() { return this } transformedBoundingBox(t) { return t === r.default.identity ? this : l.bboxOf(this.corners.map((e => t.transformVec2(e)))) } eq(t, e = 0) { return this.topLeft.eq(t.topLeft, e) && this.size.eq(t.size, e) } toString() { return `Rect(point(${this.x}, ${this.y}), size(${this.w}, ${this.h}))` } static fromCorners(t, e) { return new l(Math.min(t.x, e.x), Math.min(t.y, e.y), Math.abs(t.x - e.x), Math.abs(t.y - e.y)) } static bboxOf(t, e = 0) { let o = 0, n = 0, i = 0, r = 0, a = !0; for (const e of t) a && (o = e.x, n = e.y, i = e.x, r = e.y, a = !1), o = Math.min(o, e.x), n = Math.min(n, e.y), i = Math.max(i, e.x), r = Math.max(r, e.y); return l.fromCorners(s.Vec2.of(o - e, n - e), s.Vec2.of(i + e, r + e)) } static union(...t) { if (0 === t.length) return l.empty; const e = t[0]; let o = e.x, n = e.y, i = e.x + e.w, r = e.y + e.h; for (let e = 1; e < t.length; e++) { const s = t[e]; o = Math.min(o, s.x), n = Math.min(n, s.y), i = Math.max(i, s.x + s.w), r = Math.max(r, s.y + s.h) } return new l(o, n, i - o, r - n) } static of(t) { const e = t.width ?? t.w ?? 0, o = t.height ?? t.h ?? 0; return new l(t.x, t.y, e, o) } } e.Rect2 = l, l.empty = new l(0, 0, 0, 0), l.unitSquare = new l(0, 0, 1, 1), e.default = l }, 1477: (t, e, o) => { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); const n = o(6742); e.default = t => { if (0 === t.length) return []; const e = t.reduce(((t, e) => e.y < t.y ? e : t), t[0]), o = [e]; let i = [...t.filter((t => !t.eq(e)))], r = n.Vec2.of(-1, 0); for (; i.length > 0;) { const t = o[o.length - 1]; let n = r.dot(e.minus(t).normalizedOrZero()), s = e; for (const e of i) { const o = r.dot(e.minus(t).normalizedOrZero()); o <= n && (s = e, n = o) } i = i.filter((t => !t.eq(s))); const a = s.minus(t).normalized(); if (1 === Math.abs(a.dot(r)) && o.length > 1 && o.pop(), s.eq(e)) break; o.push(s), r = t.minus(s).normalized() } return o } }, 1666: (t, e) => {
            var o, n, i; "undefined" != typeof self && self, n = [], void 0 === (i = "function" == typeof (o = function () {
                /*!
                  * Copyright (c) 2021-2023 Momo Bassit.
                  * Licensed under the MIT License (MIT)
                  * https://github.com/mdbassit/Coloris
                  * Version: 0.21.1
                  * NPM: https://github.com/melloware/coloris-npm
                  */
                return ((t, e, o, n) => { const i = e.createElement("canvas").getContext("2d"), r = { r: 0, g: 0, b: 0, h: 0, s: 0, v: 0, a: 1 }; let s, a, l, c, d, h, u, p, f, m, g, b, y, v, x, w, S = {}; const T = { el: "[data-coloris]", parent: "body", theme: "default", themeMode: "light", rtl: !1, wrap: !0, margin: 2, format: "hex", formatToggle: !1, swatches: [], swatchesOnly: !1, alpha: !0, forceAlpha: !1, focusInput: !0, selectInput: !1, inline: !1, defaultColor: "#000000", clearButton: !1, clearLabel: "Clear", closeButton: !1, closeLabel: "Close", onChange: () => n, a11y: { open: "Open color picker", close: "Close color picker", clear: "Clear the selected color", marker: "Saturation: {s}. Brightness: {v}.", hueSlider: "Hue slider", alphaSlider: "Opacity slider", input: "Color value field", format: "Color format", swatch: "Color swatch", instruction: "Saturation and brightness selector. Use up, down, left and right arrow keys to select." } }, C = {}; let P = "", k = {}, E = !1; function z(o) { if ("object" == typeof o) for (const i in o) switch (i) { case "el": B(o.el), !1 !== o.wrap && L(o.el); break; case "parent": s = e.querySelector(o.parent), s && (s.appendChild(a), T.parent = o.parent, s === e.body && (s = n)); break; case "themeMode": T.themeMode = o.themeMode, "auto" === o.themeMode && t.matchMedia && t.matchMedia("(prefers-color-scheme: dark)").matches && (T.themeMode = "dark"); case "theme": o.theme && (T.theme = o.theme), a.className = `clr-picker clr-${T.theme} clr-${T.themeMode}`, T.inline && O(); break; case "rtl": T.rtl = !!o.rtl, e.querySelectorAll(".clr-field").forEach((t => t.classList.toggle("clr-rtl", T.rtl))); break; case "margin": o.margin *= 1, T.margin = isNaN(o.margin) ? T.margin : o.margin; break; case "wrap": o.el && o.wrap && L(o.el); break; case "formatToggle": T.formatToggle = !!o.formatToggle, it("clr-format").style.display = T.formatToggle ? "block" : "none", T.formatToggle && (T.format = "auto"); break; case "swatches": if (Array.isArray(o.swatches)) { const t = []; o.swatches.forEach(((e, o) => { t.push(`<button type="button" id="clr-swatch-${o}" aria-labelledby="clr-swatch-label clr-swatch-${o}" style="color: ${e};">${e}</button>`) })), it("clr-swatches").innerHTML = t.length ? `<div>${t.join("")}</div>` : "", T.swatches = o.swatches.slice() } break; case "swatchesOnly": T.swatchesOnly = !!o.swatchesOnly, a.setAttribute("data-minimal", T.swatchesOnly); break; case "alpha": T.alpha = !!o.alpha, a.setAttribute("data-alpha", T.alpha); break; case "inline": if (T.inline = !!o.inline, a.setAttribute("data-inline", T.inline), T.inline) { const t = o.defaultColor || T.defaultColor; v = j(t), O(), A(t) } break; case "clearButton": "object" == typeof o.clearButton && (o.clearButton.label && (T.clearLabel = o.clearButton.label, u.innerHTML = T.clearLabel), o.clearButton = o.clearButton.show), T.clearButton = !!o.clearButton, u.style.display = T.clearButton ? "block" : "none"; break; case "clearLabel": T.clearLabel = o.clearLabel, u.innerHTML = T.clearLabel; break; case "closeButton": T.closeButton = !!o.closeButton, T.closeButton ? a.insertBefore(p, d) : d.appendChild(p); break; case "closeLabel": T.closeLabel = o.closeLabel, p.innerHTML = T.closeLabel; break; case "a11y": const r = o.a11y; let c = !1; if ("object" == typeof r) for (const t in r) r[t] && T.a11y[t] && (T.a11y[t] = r[t], c = !0); if (c) { const t = it("clr-open-label"), e = it("clr-swatch-label"); t.innerHTML = T.a11y.open, e.innerHTML = T.a11y.swatch, p.setAttribute("aria-label", T.a11y.close), u.setAttribute("aria-label", T.a11y.clear), f.setAttribute("aria-label", T.a11y.hueSlider), g.setAttribute("aria-label", T.a11y.alphaSlider), h.setAttribute("aria-label", T.a11y.input), l.setAttribute("aria-label", T.a11y.instruction) } break; default: T[i] = o[i] } } function M(t, e) { "string" == typeof t && "object" == typeof e && (C[t] = e, E = !0) } function _(t) { delete C[t], 0 === Object.keys(C).length && (E = !1, t === P && R()) } function I(t) { if (E) { const e = ["el", "wrap", "rtl", "inline", "defaultColor", "a11y"]; for (let o in C) { const n = C[o]; if (t.matches(o)) { P = o, k = {}, e.forEach((t => delete n[t])); for (let t in n) k[t] = Array.isArray(T[t]) ? T[t].slice() : T[t]; z(n); break } } } } function R() { Object.keys(k).length > 0 && (z(k), P = "", k = {}) } function B(t) { rt(e, "click", t, (t => { T.inline || (I(t.target), y = t.target, x = y.value, v = j(x), a.classList.add("clr-open"), O(), A(x), (T.focusInput || T.selectInput) && (h.focus({ preventScroll: !0 }), h.setSelectionRange(y.selectionStart, y.selectionEnd)), T.selectInput && h.select(), (w || T.swatchesOnly) && nt().shift().focus(), y.dispatchEvent(new Event("open", { bubbles: !0 }))) })), rt(e, "input", t, (t => { const e = t.target.parentNode; e.classList.contains("clr-field") && (e.style.color = t.target.value) })) } function O() { if (!a || !y && !T.inline) return; const o = s, n = t.scrollY, i = a.offsetWidth, r = a.offsetHeight, c = { left: !1, top: !1 }; let d, h, u, p = { x: 0, y: 0 }; if (o && (d = t.getComputedStyle(o), h = parseFloat(d.marginTop), u = parseFloat(d.borderTopWidth), p = o.getBoundingClientRect(), p.y += u + n), !T.inline) { const t = y.getBoundingClientRect(); let s = t.x, l = n + t.y + t.height + T.margin; o ? (s -= p.x, l -= p.y, s + i > o.clientWidth && (s += t.width - i, c.left = !0), l + r > o.clientHeight - h && r + T.margin <= t.top - (p.y - n) && (l -= t.height + r + 2 * T.margin, c.top = !0), l += o.scrollTop) : (s + i > e.documentElement.clientWidth && (s += t.width - i, c.left = !0), l + r - n > e.documentElement.clientHeight && r + T.margin <= t.top && (l = n + t.y - r - T.margin, c.top = !0)), a.classList.toggle("clr-left", c.left), a.classList.toggle("clr-top", c.top), a.style.left = `${s}px`, a.style.top = `${l}px`, p.x += a.offsetLeft, p.y += a.offsetTop } S = { width: l.offsetWidth, height: l.offsetHeight, x: l.offsetLeft + p.x, y: l.offsetTop + p.y } } function L(t) { e.querySelectorAll(t).forEach((t => { const o = t.parentNode; if (!o.classList.contains("clr-field")) { const n = e.createElement("div"); let i = "clr-field"; (T.rtl || t.classList.contains("clr-rtl")) && (i += " clr-rtl"), n.innerHTML = '<button type="button" aria-labelledby="clr-open-label"></button>', o.insertBefore(n, t), n.setAttribute("class", i), n.style.color = t.value, n.appendChild(t) } })) } function D(t) { if (y && !T.inline) { const e = y; t && (y = n, x !== e.value && (e.value = x, e.dispatchEvent(new Event("input", { bubbles: !0 })))), setTimeout((() => { x !== e.value && e.dispatchEvent(new Event("change", { bubbles: !0 })) })), a.classList.remove("clr-open"), E && R(), e.dispatchEvent(new Event("close", { bubbles: !0 })), T.focusInput && e.focus({ preventScroll: !0 }), y = n } } function A(t) { const e = J(t), o = X(e); N(o.s, o.v), K(e, o), f.value = o.h, a.style.color = `hsl(${o.h}, 100%, 50%)`, m.style.left = o.h / 360 * 100 + "%", c.style.left = S.width * o.s / 100 + "px", c.style.top = S.height - S.height * o.v / 100 + "px", g.value = 100 * o.a, b.style.left = 100 * o.a + "%" } function j(t) { const e = t.substring(0, 3).toLowerCase(); return "rgb" === e || "hsl" === e ? e : "hex" } function V(o) { o = o !== n ? o : h.value, y && (y.value = o, y.dispatchEvent(new Event("input", { bubbles: !0 }))), T.onChange && T.onChange.call(t, o, y), e.dispatchEvent(new CustomEvent("coloris:pick", { detail: { color: o, currentEl: y } })) } function F(t, e) { const o = { h: 1 * f.value, s: t / S.width * 100, v: 100 - e / S.height * 100, a: g.value / 100 }, n = Z(o); N(o.s, o.v), K(n, o), V() } function N(t, e) { let o = T.a11y.marker; t = 1 * t.toFixed(1), e = 1 * e.toFixed(1), o = o.replace("{s}", t), o = o.replace("{v}", e), c.setAttribute("aria-label", o) } function $(t) { return { pageX: t.changedTouches ? t.changedTouches[0].pageX : t.pageX, pageY: t.changedTouches ? t.changedTouches[0].pageY : t.pageY } } function U(t) { const e = $(t); let o = e.pageX - S.x, n = e.pageY - S.y; s && (n += s.scrollTop), W(o, n), t.preventDefault(), t.stopPropagation() } function H(t, e) { W(1 * c.style.left.replace("px", "") + t, 1 * c.style.top.replace("px", "") + e) } function W(t, e) { t = t < 0 ? 0 : t > S.width ? S.width : t, e = e < 0 ? 0 : e > S.height ? S.height : e, c.style.left = `${t}px`, c.style.top = `${e}px`, F(t, e), c.focus() } function K(t, o) { void 0 === t && (t = {}), void 0 === o && (o = {}); let n = T.format; for (const e in t) r[e] = t[e]; for (const t in o) r[t] = o[t]; const i = Q(r), s = i.substring(0, 7); switch (c.style.color = s, b.parentNode.style.color = s, b.style.color = i, d.style.color = i, l.style.display = "none", l.offsetHeight, l.style.display = "", b.nextElementSibling.style.display = "none", b.nextElementSibling.offsetHeight, b.nextElementSibling.style.display = "", "mixed" === n ? n = 1 === r.a ? "hex" : "rgb" : "auto" === n && (n = v), n) { case "hex": h.value = i; break; case "rgb": h.value = tt(r); break; case "hsl": h.value = et(Y(r)) }e.querySelector(`.clr-format [value="${n}"]`).checked = !0 } function G() { const t = 1 * f.value, e = 1 * c.style.left.replace("px", ""), o = 1 * c.style.top.replace("px", ""); a.style.color = `hsl(${t}, 100%, 50%)`, m.style.left = t / 360 * 100 + "%", F(e, o) } function q() { const t = g.value / 100; b.style.left = 100 * t + "%", K({ a: t }), V() } function Z(t) { const e = t.s / 100, n = t.v / 100; let i = e * n, r = t.h / 60, s = i * (1 - o.abs(r % 2 - 1)), a = n - i; i += a, s += a; const l = o.floor(r) % 6, c = [i, s, a, a, s, i][l], d = [s, i, i, s, a, a][l], h = [a, a, s, i, i, s][l]; return { r: o.round(255 * c), g: o.round(255 * d), b: o.round(255 * h), a: t.a } } function Y(t) { const e = t.v / 100, n = e * (1 - t.s / 100 / 2); let i; return n > 0 && n < 1 && (i = o.round((e - n) / o.min(n, 1 - n) * 100)), { h: t.h, s: i || 0, l: o.round(100 * n), a: t.a } } function X(t) { const e = t.r / 255, n = t.g / 255, i = t.b / 255, r = o.max(e, n, i), s = r - o.min(e, n, i), a = r; let l = 0, c = 0; return s && (r === e && (l = (n - i) / s), r === n && (l = 2 + (i - e) / s), r === i && (l = 4 + (e - n) / s), r && (c = s / r)), l = o.floor(60 * l), { h: l < 0 ? l + 360 : l, s: o.round(100 * c), v: o.round(100 * a), a: t.a } } function J(t) { const e = /^((rgba)|rgb)[\D]+([\d.]+)[\D]+([\d.]+)[\D]+([\d.]+)[\D]*?([\d.]+|$)/i; let o, n; return i.fillStyle = "#000", i.fillStyle = t, o = e.exec(i.fillStyle), o ? (n = { r: 1 * o[3], g: 1 * o[4], b: 1 * o[5], a: 1 * o[6] }, n.a = +n.a.toFixed(2)) : (o = i.fillStyle.replace("#", "").match(/.{2}/g).map((t => parseInt(t, 16))), n = { r: o[0], g: o[1], b: o[2], a: 1 }), n } function Q(t) { let e = t.r.toString(16), o = t.g.toString(16), n = t.b.toString(16), i = ""; if (t.r < 16 && (e = "0" + e), t.g < 16 && (o = "0" + o), t.b < 16 && (n = "0" + n), T.alpha && (t.a < 1 || T.forceAlpha)) { const e = 255 * t.a | 0; i = e.toString(16), e < 16 && (i = "0" + i) } return "#" + e + o + n + i } function tt(t) { return !T.alpha || 1 === t.a && !T.forceAlpha ? `rgb(${t.r}, ${t.g}, ${t.b})` : `rgba(${t.r}, ${t.g}, ${t.b}, ${t.a})` } function et(t) { return !T.alpha || 1 === t.a && !T.forceAlpha ? `hsl(${t.h}, ${t.s}%, ${t.l}%)` : `hsla(${t.h}, ${t.s}%, ${t.l}%, ${t.a})` } function ot() { e.getElementById("clr-picker") || (s = n, a = e.createElement("div"), a.setAttribute("id", "clr-picker"), a.className = "clr-picker", a.innerHTML = `<input id="clr-color-value" name="clr-color-value" class="clr-color" type="text" value="" spellcheck="false" aria-label="${T.a11y.input}"><div id="clr-color-area" class="clr-gradient" role="application" aria-label="${T.a11y.instruction}"><div id="clr-color-marker" class="clr-marker" tabindex="0"></div></div><div class="clr-hue"><input id="clr-hue-slider" name="clr-hue-slider" type="range" min="0" max="360" step="1" aria-label="${T.a11y.hueSlider}"><div id="clr-hue-marker"></div></div><div class="clr-alpha"><input id="clr-alpha-slider" name="clr-alpha-slider" type="range" min="0" max="100" step="1" aria-label="${T.a11y.alphaSlider}"><div id="clr-alpha-marker"></div><span></span></div><div id="clr-format" class="clr-format"><fieldset class="clr-segmented"><legend>${T.a11y.format}</legend><input id="clr-f1" type="radio" name="clr-format" value="hex"><label for="clr-f1">Hex</label><input id="clr-f2" type="radio" name="clr-format" value="rgb"><label for="clr-f2">RGB</label><input id="clr-f3" type="radio" name="clr-format" value="hsl"><label for="clr-f3">HSL</label><span></span></fieldset></div><div id="clr-swatches" class="clr-swatches"></div><button type="button" id="clr-clear" class="clr-clear" aria-label="${T.a11y.clear}">${T.clearLabel}</button><div id="clr-color-preview" class="clr-preview"><button type="button" id="clr-close" class="clr-close" aria-label="${T.a11y.close}">${T.closeLabel}</button></div><span id="clr-open-label" hidden>${T.a11y.open}</span><span id="clr-swatch-label" hidden>${T.a11y.swatch}</span>`, e.body.appendChild(a), l = it("clr-color-area"), c = it("clr-color-marker"), u = it("clr-clear"), p = it("clr-close"), d = it("clr-color-preview"), h = it("clr-color-value"), f = it("clr-hue-slider"), m = it("clr-hue-marker"), g = it("clr-alpha-slider"), b = it("clr-alpha-marker"), B(T.el), L(T.el), rt(a, "mousedown", (t => { a.classList.remove("clr-keyboard-nav"), t.stopPropagation() })), rt(l, "mousedown", (t => { rt(e, "mousemove", U) })), rt(l, "touchstart", (t => { e.addEventListener("touchmove", U, { passive: !1 }) })), rt(c, "mousedown", (t => { rt(e, "mousemove", U) })), rt(c, "touchstart", (t => { e.addEventListener("touchmove", U, { passive: !1 }) })), rt(h, "change", (t => { const e = h.value; (y || T.inline) && V("" === e ? e : A(e)) })), rt(u, "click", (t => { V(""), D() })), rt(p, "click", (t => { V(), D() })), rt(it("clr-format"), "click", ".clr-format input", (t => { v = t.target.value, K(), V() })), rt(a, "click", ".clr-swatches button", (t => { A(t.target.textContent), V(), T.swatchesOnly && D() })), rt(e, "mouseup", (t => { e.removeEventListener("mousemove", U) })), rt(e, "touchend", (t => { e.removeEventListener("touchmove", U) })), rt(e, "mousedown", (t => { w = !1, a.classList.remove("clr-keyboard-nav"), D() })), rt(e, "keydown", (t => { const e = t.key, o = t.target, n = t.shiftKey, i = ["Tab", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"]; if ("Escape" === e ? D(!0) : i.includes(e) && (w = !0, a.classList.add("clr-keyboard-nav")), "Tab" === e && o.matches(".clr-picker *")) { const e = nt(), i = e.shift(), r = e.pop(); n && o === i ? (r.focus(), t.preventDefault()) : n || o !== r || (i.focus(), t.preventDefault()) } })), rt(e, "click", ".clr-field button", (t => { E && R(), t.target.nextElementSibling.dispatchEvent(new Event("click", { bubbles: !0 })) })), rt(c, "keydown", (t => { const e = { ArrowUp: [0, -1], ArrowDown: [0, 1], ArrowLeft: [-1, 0], ArrowRight: [1, 0] }; Object.keys(e).includes(t.key) && (H(...e[t.key]), t.preventDefault()) })), rt(l, "click", U), rt(f, "input", G), rt(g, "input", q)) } function nt() { return Array.from(a.querySelectorAll("input, button")).filter((t => !!t.offsetWidth)) } function it(t) { return e.getElementById(t) } function rt(t, e, o, n) { const i = Element.prototype.matches || Element.prototype.msMatchesSelector; "string" == typeof o ? t.addEventListener(e, (t => { i.call(t.target, o) && n.call(t.target, t) })) : (n = o, t.addEventListener(e, n)) } function st(t, o) { o = o !== n ? o : [], "loading" !== e.readyState ? t(...o) : e.addEventListener("DOMContentLoaded", (() => { t(...o) })) } function at(t, e) { y = e, x = y.value, I(e), v = j(t), O(), A(t), V(), x !== t && y.dispatchEvent(new Event("change", { bubbles: !0 })) } NodeList !== n && NodeList.prototype && !NodeList.prototype.forEach && (NodeList.prototype.forEach = Array.prototype.forEach); const lt = (() => { const e = { init: ot, set: z, wrap: L, close: D, setInstance: M, setColor: at, removeInstance: _, updatePosition: O, ready: st }; function o(t) { st((() => { t && ("string" == typeof t ? B(t) : z(t)) })) } for (const t in e) o[t] = function () { for (var o = arguments.length, n = new Array(o), i = 0; i < o; i++)n[i] = arguments[i]; st(e[t], n) }; return st((() => { t.addEventListener("resize", (t => { o.updatePosition() })), t.addEventListener("scroll", (t => { o.updatePosition() })) })), o })(); return lt.coloris = lt, lt })(window, document, Math)
            }) ? o.apply(e, n) : o) || (t.exports = i)
        }, 5893: e => { var o = Object.defineProperty, n = Object.getOwnPropertyDescriptor, i = Object.getOwnPropertyNames, r = Object.prototype.hasOwnProperty, s = (t => (e, s) => t && t.get(e) || (s = ((t, e, s, a) => { if (e && "object" == typeof e || "function" == typeof e) for (let l of i(e)) r.call(t, l) || !s && "default" === l || o(t, l, { get: () => e[l], enumerable: !(a = n(e, l)) || a.enumerable }); return t })(o({}, "__esModule", { value: !0 }), e, 1), t && t.set(e, s), s))("undefined" != typeof WeakMap ? new WeakMap : 0), a = {}; ((t, e) => { for (var n in e) o(t, n, { get: e[n], enumerable: !0 }) })(a, { Bezier: () => R }); var { abs: l, cos: c, sin: d, acos: h, atan2: u, sqrt: p, pow: f } = Math; function m(t) { return t < 0 ? -f(-t, 1 / 3) : f(t, 1 / 3) } var g = Math.PI, b = 2 * g, y = g / 2, v = Number.MAX_SAFE_INTEGER || 9007199254740991, x = Number.MIN_SAFE_INTEGER || -9007199254740991, w = { x: 0, y: 0, z: 0 }, S = { Tvalues: [-.06405689286260563, .06405689286260563, -.1911188674736163, .1911188674736163, -.3150426796961634, .3150426796961634, -.4337935076260451, .4337935076260451, -.5454214713888396, .5454214713888396, -.6480936519369755, .6480936519369755, -.7401241915785544, .7401241915785544, -.820001985973903, .820001985973903, -.8864155270044011, .8864155270044011, -.9382745520027328, .9382745520027328, -.9747285559713095, .9747285559713095, -.9951872199970213, .9951872199970213], Cvalues: [.12793819534675216, .12793819534675216, .1258374563468283, .1258374563468283, .12167047292780339, .12167047292780339, .1155056680537256, .1155056680537256, .10744427011596563, .10744427011596563, .09761865210411388, .09761865210411388, .08619016153195327, .08619016153195327, .0733464814110803, .0733464814110803, .05929858491543678, .05929858491543678, .04427743881741981, .04427743881741981, .028531388628933663, .028531388628933663, .0123412297999872, .0123412297999872], arcfn: function (t, e) { const o = e(t); let n = o.x * o.x + o.y * o.y; return void 0 !== o.z && (n += o.z * o.z), p(n) }, compute: function (t, e, o) { if (0 === t) return e[0].t = 0, e[0]; const n = e.length - 1; if (1 === t) return e[n].t = 1, e[n]; const i = 1 - t; let r = e; if (0 === n) return e[0].t = t, e[0]; if (1 === n) { const e = { x: i * r[0].x + t * r[1].x, y: i * r[0].y + t * r[1].y, t }; return o && (e.z = i * r[0].z + t * r[1].z), e } if (n < 4) { let e, s, a, l = i * i, c = t * t, d = 0; 2 === n ? (r = [r[0], r[1], r[2], w], e = l, s = i * t * 2, a = c) : 3 === n && (e = l * i, s = l * t * 3, a = i * c * 3, d = t * c); const h = { x: e * r[0].x + s * r[1].x + a * r[2].x + d * r[3].x, y: e * r[0].y + s * r[1].y + a * r[2].y + d * r[3].y, t }; return o && (h.z = e * r[0].z + s * r[1].z + a * r[2].z + d * r[3].z), h } const s = JSON.parse(JSON.stringify(e)); for (; s.length > 1;) { for (let e = 0; e < s.length - 1; e++)s[e] = { x: s[e].x + (s[e + 1].x - s[e].x) * t, y: s[e].y + (s[e + 1].y - s[e].y) * t }, void 0 !== s[e].z && (s[e] = s[e].z + (s[e + 1].z - s[e].z) * t); s.splice(s.length - 1, 1) } return s[0].t = t, s[0] }, computeWithRatios: function (t, e, o, n) { const i = 1 - t, r = o, s = e; let a, l = r[0], c = r[1], d = r[2], h = r[3]; return l *= i, c *= t, 2 === s.length ? (a = l + c, { x: (l * s[0].x + c * s[1].x) / a, y: (l * s[0].y + c * s[1].y) / a, z: !!n && (l * s[0].z + c * s[1].z) / a, t }) : (l *= i, c *= 2 * i, d *= t * t, 3 === s.length ? (a = l + c + d, { x: (l * s[0].x + c * s[1].x + d * s[2].x) / a, y: (l * s[0].y + c * s[1].y + d * s[2].y) / a, z: !!n && (l * s[0].z + c * s[1].z + d * s[2].z) / a, t }) : (l *= i, c *= 1.5 * i, d *= 3 * i, h *= t * t * t, 4 === s.length ? (a = l + c + d + h, { x: (l * s[0].x + c * s[1].x + d * s[2].x + h * s[3].x) / a, y: (l * s[0].y + c * s[1].y + d * s[2].y + h * s[3].y) / a, z: !!n && (l * s[0].z + c * s[1].z + d * s[2].z + h * s[3].z) / a, t }) : void 0)) }, derive: function (t, e) { const o = []; for (let n = t, i = n.length, r = i - 1; i > 1; i--, r--) { const t = []; for (let o, i = 0; i < r; i++)o = { x: r * (n[i + 1].x - n[i].x), y: r * (n[i + 1].y - n[i].y) }, e && (o.z = r * (n[i + 1].z - n[i].z)), t.push(o); o.push(t), n = t } return o }, between: function (t, e, o) { return e <= t && t <= o || S.approximately(t, e) || S.approximately(t, o) }, approximately: function (t, e, o) { return l(t - e) <= (o || 1e-6) }, length: function (t) { const e = S.Tvalues.length; let o = 0; for (let n, i = 0; i < e; i++)n = .5 * S.Tvalues[i] + .5, o += S.Cvalues[i] * S.arcfn(n, t); return .5 * o }, map: function (t, e, o, n, i) { return n + (i - n) * ((t - e) / (o - e)) }, lerp: function (t, e, o) { const n = { x: e.x + t * (o.x - e.x), y: e.y + t * (o.y - e.y) }; return void 0 !== e.z && void 0 !== o.z && (n.z = e.z + t * (o.z - e.z)), n }, pointToString: function (t) { let e = t.x + "/" + t.y; return void 0 !== t.z && (e += "/" + t.z), e }, pointsToString: function (t) { return "[" + t.map(S.pointToString).join(", ") + "]" }, copy: function (t) { return JSON.parse(JSON.stringify(t)) }, angle: function (t, e, o) { const n = e.x - t.x, i = e.y - t.y, r = o.x - t.x, s = o.y - t.y; return u(n * s - i * r, n * r + i * s) }, round: function (t, e) { const o = "" + t, n = o.indexOf("."); return parseFloat(o.substring(0, n + 1 + e)) }, dist: function (t, e) { const o = t.x - e.x, n = t.y - e.y; return p(o * o + n * n) }, closest: function (t, e) { let o, n, i = f(2, 63); return t.forEach((function (t, r) { n = S.dist(e, t), n < i && (i = n, o = r) })), { mdist: i, mpos: o } }, abcratio: function (t, e) { if (2 !== e && 3 !== e) return !1; if (void 0 === t) t = .5; else if (0 === t || 1 === t) return t; const o = f(t, e) + f(1 - t, e); return l((o - 1) / o) }, projectionratio: function (t, e) { if (2 !== e && 3 !== e) return !1; if (void 0 === t) t = .5; else if (0 === t || 1 === t) return t; const o = f(1 - t, e); return o / (f(t, e) + o) }, lli8: function (t, e, o, n, i, r, s, a) { const l = (t - o) * (r - a) - (e - n) * (i - s); return 0 != l && { x: ((t * n - e * o) * (i - s) - (t - o) * (i * a - r * s)) / l, y: ((t * n - e * o) * (r - a) - (e - n) * (i * a - r * s)) / l } }, lli4: function (t, e, o, n) { const i = t.x, r = t.y, s = e.x, a = e.y, l = o.x, c = o.y, d = n.x, h = n.y; return S.lli8(i, r, s, a, l, c, d, h) }, lli: function (t, e) { return S.lli4(t, t.c, e, e.c) }, makeline: function (t, e) { return new R(t.x, t.y, (t.x + e.x) / 2, (t.y + e.y) / 2, e.x, e.y) }, findbbox: function (t) { let e = v, o = v, n = x, i = x; return t.forEach((function (t) { const r = t.bbox(); e > r.x.min && (e = r.x.min), o > r.y.min && (o = r.y.min), n < r.x.max && (n = r.x.max), i < r.y.max && (i = r.y.max) })), { x: { min: e, mid: (e + n) / 2, max: n, size: n - e }, y: { min: o, mid: (o + i) / 2, max: i, size: i - o } } }, shapeintersections: function (t, e, o, n, i) { if (!S.bboxoverlap(e, n)) return []; const r = [], s = [t.startcap, t.forward, t.back, t.endcap], a = [o.startcap, o.forward, o.back, o.endcap]; return s.forEach((function (e) { e.virtual || a.forEach((function (n) { if (n.virtual) return; const s = e.intersects(n, i); s.length > 0 && (s.c1 = e, s.c2 = n, s.s1 = t, s.s2 = o, r.push(s)) })) })), r }, makeshape: function (t, e, o) { const n = e.points.length, i = t.points.length, r = S.makeline(e.points[n - 1], t.points[0]), s = S.makeline(t.points[i - 1], e.points[0]), a = { startcap: r, forward: t, back: e, endcap: s, bbox: S.findbbox([r, t, e, s]), intersections: function (t) { return S.shapeintersections(a, a.bbox, t, t.bbox, o) } }; return a }, getminmax: function (t, e, o) { if (!o) return { min: 0, max: 0 }; let n, i, r = v, s = x; -1 === o.indexOf(0) && (o = [0].concat(o)), -1 === o.indexOf(1) && o.push(1); for (let a = 0, l = o.length; a < l; a++)n = o[a], i = t.get(n), i[e] < r && (r = i[e]), i[e] > s && (s = i[e]); return { min: r, mid: (r + s) / 2, max: s, size: s - r } }, align: function (t, e) { const o = e.p1.x, n = e.p1.y, i = -u(e.p2.y - n, e.p2.x - o); return t.map((function (t) { return { x: (t.x - o) * c(i) - (t.y - n) * d(i), y: (t.x - o) * d(i) + (t.y - n) * c(i) } })) }, roots: function (t, e) { e = e || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } }; const o = t.length - 1, n = S.align(t, e), i = function (t) { return 0 <= t && t <= 1 }; if (2 === o) { const t = n[0].y, e = n[1].y, o = n[2].y, r = t - 2 * e + o; if (0 !== r) { const n = -p(e * e - t * o), s = -t + e; return [-(n + s) / r, -(-n + s) / r].filter(i) } return e !== o && 0 === r ? [(2 * e - o) / (2 * e - 2 * o)].filter(i) : [] } const r = n[0].y, s = n[1].y, a = n[2].y; let l = 3 * s - r - 3 * a + n[3].y, d = 3 * r - 6 * s + 3 * a, u = -3 * r + 3 * s, f = r; if (S.approximately(l, 0)) { if (S.approximately(d, 0)) return S.approximately(u, 0) ? [] : [-f / u].filter(i); const t = p(u * u - 4 * d * f), e = 2 * d; return [(t - u) / e, (-u - t) / e].filter(i) } d /= l, u /= l, f /= l; const g = (3 * u - d * d) / 3, y = g / 3, v = (2 * d * d * d - 9 * d * u + 27 * f) / 27, x = v / 2, w = x * x + y * y * y; let T, C, P, k, E; if (w < 0) { const t = -g / 3, e = p(t * t * t), o = -v / (2 * e), n = h(o < -1 ? -1 : o > 1 ? 1 : o), r = 2 * m(e); return P = r * c(n / 3) - d / 3, k = r * c((n + b) / 3) - d / 3, E = r * c((n + 2 * b) / 3) - d / 3, [P, k, E].filter(i) } if (0 === w) return T = x < 0 ? m(-x) : -m(x), P = 2 * T - d / 3, k = -T - d / 3, [P, k].filter(i); { const t = p(w); return T = m(-x + t), C = m(x + t), [T - C - d / 3].filter(i) } }, droots: function (t) { if (3 === t.length) { const e = t[0], o = t[1], n = t[2], i = e - 2 * o + n; if (0 !== i) { const t = -p(o * o - e * n), r = -e + o; return [-(t + r) / i, -(-t + r) / i] } return o !== n && 0 === i ? [(2 * o - n) / (2 * (o - n))] : [] } if (2 === t.length) { const e = t[0], o = t[1]; return e !== o ? [e / (e - o)] : [] } return [] }, curvature: function (t, e, o, n, i) { let r, s, a, c, d = 0, h = 0; const u = S.compute(t, e), m = S.compute(t, o), g = u.x * u.x + u.y * u.y; if (n ? (r = p(f(u.y * m.z - m.y * u.z, 2) + f(u.z * m.x - m.z * u.x, 2) + f(u.x * m.y - m.x * u.y, 2)), s = f(g + u.z * u.z, 1.5)) : (r = u.x * m.y - u.y * m.x, s = f(g, 1.5)), 0 === r || 0 === s) return { k: 0, r: 0 }; if (d = r / s, h = s / r, !i) { const i = S.curvature(t - .001, e, o, n, !0).k, r = S.curvature(t + .001, e, o, n, !0).k; c = (r - d + (d - i)) / 2, a = (l(r - d) + l(d - i)) / 2 } return { k: d, r: h, dk: c, adk: a } }, inflections: function (t) { if (t.length < 4) return []; const e = S.align(t, { p1: t[0], p2: t.slice(-1)[0] }), o = e[2].x * e[1].y, n = e[3].x * e[1].y, i = e[1].x * e[2].y, r = 18 * (-3 * o + 2 * n + 3 * i - e[3].x * e[2].y), s = 18 * (3 * o - n - 3 * i), a = 18 * (i - o); if (S.approximately(r, 0)) { if (!S.approximately(s, 0)) { let t = -a / s; if (0 <= t && t <= 1) return [t] } return [] } const l = 2 * r; if (S.approximately(l, 0)) return []; const c = s * s - 4 * r * a; if (c < 0) return []; const d = Math.sqrt(c); return [(d - s) / l, -(s + d) / l].filter((function (t) { return 0 <= t && t <= 1 })) }, bboxoverlap: function (t, e) { const o = ["x", "y"], n = o.length; for (let i, r, s, a, c = 0; c < n; c++)if (i = o[c], r = t[i].mid, s = e[i].mid, a = (t[i].size + e[i].size) / 2, l(r - s) >= a) return !1; return !0 }, expandbox: function (t, e) { e.x.min < t.x.min && (t.x.min = e.x.min), e.y.min < t.y.min && (t.y.min = e.y.min), e.z && e.z.min < t.z.min && (t.z.min = e.z.min), e.x.max > t.x.max && (t.x.max = e.x.max), e.y.max > t.y.max && (t.y.max = e.y.max), e.z && e.z.max > t.z.max && (t.z.max = e.z.max), t.x.mid = (t.x.min + t.x.max) / 2, t.y.mid = (t.y.min + t.y.max) / 2, t.z && (t.z.mid = (t.z.min + t.z.max) / 2), t.x.size = t.x.max - t.x.min, t.y.size = t.y.max - t.y.min, t.z && (t.z.size = t.z.max - t.z.min) }, pairiteration: function (t, e, o) { const n = t.bbox(), i = e.bbox(), r = 1e5, s = o || .5; if (n.x.size + n.y.size < s && i.x.size + i.y.size < s) return [(r * (t._t1 + t._t2) / 2 | 0) / r + "/" + (r * (e._t1 + e._t2) / 2 | 0) / r]; let a = t.split(.5), l = e.split(.5), c = [{ left: a.left, right: l.left }, { left: a.left, right: l.right }, { left: a.right, right: l.right }, { left: a.right, right: l.left }]; c = c.filter((function (t) { return S.bboxoverlap(t.left.bbox(), t.right.bbox()) })); let d = []; return 0 === c.length || (c.forEach((function (t) { d = d.concat(S.pairiteration(t.left, t.right, s)) })), d = d.filter((function (t, e) { return d.indexOf(t) === e }))), d }, getccenter: function (t, e, o) { const n = e.x - t.x, i = e.y - t.y, r = o.x - e.x, s = o.y - e.y, a = n * c(y) - i * d(y), l = n * d(y) + i * c(y), h = r * c(y) - s * d(y), p = r * d(y) + s * c(y), f = (t.x + e.x) / 2, m = (t.y + e.y) / 2, g = (e.x + o.x) / 2, v = (e.y + o.y) / 2, x = f + a, w = m + l, T = g + h, C = v + p, P = S.lli8(f, m, x, w, g, v, T, C), k = S.dist(P, t); let E, z = u(t.y - P.y, t.x - P.x), M = u(e.y - P.y, e.x - P.x), _ = u(o.y - P.y, o.x - P.x); return z < _ ? ((z > M || M > _) && (z += b), z > _ && (E = _, _ = z, z = E)) : _ < M && M < z ? (E = _, _ = z, z = E) : _ += b, P.s = z, P.e = _, P.r = k, P }, numberSort: function (t, e) { return t - e } }, T = class { constructor(t) { this.curves = [], this._3d = !1, t && (this.curves = t, this._3d = this.curves[0]._3d) } valueOf() { return this.toString() } toString() { return "[" + this.curves.map((function (t) { return S.pointsToString(t.points) })).join(", ") + "]" } addCurve(t) { this.curves.push(t), this._3d = this._3d || t._3d } length() { return this.curves.map((function (t) { return t.length() })).reduce((function (t, e) { return t + e })) } curve(t) { return this.curves[t] } bbox() { const t = this.curves; for (var e = t[0].bbox(), o = 1; o < t.length; o++)S.expandbox(e, t[o].bbox()); return e } offset(t) { const e = []; return this.curves.forEach((function (o) { e.push(...o.offset(t)) })), new T(e) } }, { abs: C, min: P, max: k, cos: E, sin: z, acos: M, sqrt: _ } = Math, I = Math.PI, R = class { constructor(t) { let e = t && t.forEach ? t : Array.from(arguments).slice(), o = !1; if ("object" == typeof e[0]) { o = e.length; const t = []; e.forEach((function (e) { ["x", "y", "z"].forEach((function (o) { void 0 !== e[o] && t.push(e[o]) })) })), e = t } let n = !1; const i = e.length; if (o) { if (o > 4) { if (1 !== arguments.length) throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves"); n = !0 } } else if (6 !== i && 8 !== i && 9 !== i && 12 !== i && 1 !== arguments.length) throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves"); const r = this._3d = !n && (9 === i || 12 === i) || t && t[0] && void 0 !== t[0].z, s = this.points = []; for (let t = 0, o = r ? 3 : 2; t < i; t += o) { var a = { x: e[t], y: e[t + 1] }; r && (a.z = e[t + 2]), s.push(a) } const l = this.order = s.length - 1, c = this.dims = ["x", "y"]; r && c.push("z"), this.dimlen = c.length; const d = S.align(s, { p1: s[0], p2: s[l] }), h = S.dist(s[0], s[l]); this._linear = d.reduce(((t, e) => t + C(e.y)), 0) < h / 50, this._lut = [], this._t1 = 0, this._t2 = 1, this.update() } static quadraticFromPoints(t, e, o, n) { if (void 0 === n && (n = .5), 0 === n) return new R(e, e, o); if (1 === n) return new R(t, e, e); const i = R.getABC(2, t, e, o, n); return new R(t, i.A, o) } static cubicFromPoints(t, e, o, n, i) { void 0 === n && (n = .5); const r = R.getABC(3, t, e, o, n); void 0 === i && (i = S.dist(e, r.C)); const s = i * (1 - n) / n, a = S.dist(t, o), l = (o.x - t.x) / a, c = (o.y - t.y) / a, d = i * l, h = i * c, u = s * l, p = s * c, f = e.x - d, m = e.y - h, g = e.x + u, b = e.y + p, y = r.A, v = y.x + (f - y.x) / (1 - n), x = y.y + (m - y.y) / (1 - n), w = y.x + (g - y.x) / n, T = y.y + (b - y.y) / n, C = { x: t.x + (v - t.x) / n, y: t.y + (x - t.y) / n }, P = { x: o.x + (w - o.x) / (1 - n), y: o.y + (T - o.y) / (1 - n) }; return new R(t, C, P, o) } static getUtils() { return S } getUtils() { return R.getUtils() } static get PolyBezier() { return T } valueOf() { return this.toString() } toString() { return S.pointsToString(this.points) } toSVG() { if (this._3d) return !1; const t = this.points, e = ["M", t[0].x, t[0].y, 2 === this.order ? "Q" : "C"]; for (let o = 1, n = t.length; o < n; o++)e.push(t[o].x), e.push(t[o].y); return e.join(" ") } setRatios(t) { if (t.length !== this.points.length) throw new Error("incorrect number of ratio values"); this.ratios = t, this._lut = [] } verify() { const t = this.coordDigest(); t !== this._print && (this._print = t, this.update()) } coordDigest() { return this.points.map((function (t, e) { return "" + e + t.x + t.y + (t.z ? t.z : 0) })).join("") } update() { this._lut = [], this.dpoints = S.derive(this.points, this._3d), this.computedirection() } computedirection() { const t = this.points, e = S.angle(t[0], t[this.order], t[1]); this.clockwise = e > 0 } length() { return S.length(this.derivative.bind(this)) } static getABC(t = 2, e, o, n, i = .5) { const r = S.projectionratio(i, t), s = 1 - r, a = { x: r * e.x + s * n.x, y: r * e.y + s * n.y }, l = S.abcratio(i, t); return { A: { x: o.x + (o.x - a.x) / l, y: o.y + (o.y - a.y) / l }, B: o, C: a, S: e, E: n } } getABC(t, e) { e = e || this.get(t); let o = this.points[0], n = this.points[this.order]; return R.getABC(this.order, o, e, n, t) } getLUT(t) { if (this.verify(), t = t || 100, this._lut.length === t + 1) return this._lut; this._lut = [], t++, this._lut = []; for (let e, o, n = 0; n < t; n++)o = n / (t - 1), e = this.compute(o), e.t = o, this._lut.push(e); return this._lut } on(e, o) { o = o || 5; const n = this.getLUT(), i = []; for (let t, r = 0, s = 0; r < n.length; r++)t = n[r], S.dist(t, e) < o && (i.push(t), s += r / n.length); return !!i.length && (t /= i.length) } project(t) { const e = this.getLUT(), o = e.length - 1, n = S.closest(e, t), i = n.mpos, r = (i - 1) / o, s = (i + 1) / o, a = .1 / o; let l, c = n.mdist, d = r, h = d; c += 1; for (let e; d < s + a; d += a)l = this.compute(d), e = S.dist(t, l), e < c && (c = e, h = d); return h = h < 0 ? 0 : h > 1 ? 1 : h, l = this.compute(h), l.t = h, l.d = c, l } get(t) { return this.compute(t) } point(t) { return this.points[t] } compute(t) { return this.ratios ? S.computeWithRatios(t, this.points, this.ratios, this._3d) : S.compute(t, this.points, this._3d, this.ratios) } raise() { const t = this.points, e = [t[0]], o = t.length; for (let n, i, r = 1; r < o; r++)n = t[r], i = t[r - 1], e[r] = { x: (o - r) / o * n.x + r / o * i.x, y: (o - r) / o * n.y + r / o * i.y }; return e[o] = t[o - 1], new R(e) } derivative(t) { return S.compute(t, this.dpoints[0], this._3d) } dderivative(t) { return S.compute(t, this.dpoints[1], this._3d) } align() { let t = this.points; return new R(S.align(t, { p1: t[0], p2: t[t.length - 1] })) } curvature(t) { return S.curvature(t, this.dpoints[0], this.dpoints[1], this._3d) } inflections() { return S.inflections(this.points) } normal(t) { return this._3d ? this.__normal3(t) : this.__normal2(t) } __normal2(t) { const e = this.derivative(t), o = _(e.x * e.x + e.y * e.y); return { t, x: -e.y / o, y: e.x / o } } __normal3(t) { const e = this.derivative(t), o = this.derivative(t + .01), n = _(e.x * e.x + e.y * e.y + e.z * e.z), i = _(o.x * o.x + o.y * o.y + o.z * o.z); e.x /= n, e.y /= n, e.z /= n, o.x /= i, o.y /= i, o.z /= i; const r = { x: o.y * e.z - o.z * e.y, y: o.z * e.x - o.x * e.z, z: o.x * e.y - o.y * e.x }, s = _(r.x * r.x + r.y * r.y + r.z * r.z); r.x /= s, r.y /= s, r.z /= s; const a = [r.x * r.x, r.x * r.y - r.z, r.x * r.z + r.y, r.x * r.y + r.z, r.y * r.y, r.y * r.z - r.x, r.x * r.z - r.y, r.y * r.z + r.x, r.z * r.z]; return { t, x: a[0] * e.x + a[1] * e.y + a[2] * e.z, y: a[3] * e.x + a[4] * e.y + a[5] * e.z, z: a[6] * e.x + a[7] * e.y + a[8] * e.z } } hull(t) { let e = this.points, o = [], n = [], i = 0; for (n[i++] = e[0], n[i++] = e[1], n[i++] = e[2], 3 === this.order && (n[i++] = e[3]); e.length > 1;) { o = []; for (let r, s = 0, a = e.length - 1; s < a; s++)r = S.lerp(t, e[s], e[s + 1]), n[i++] = r, o.push(r); e = o } return n } split(t, e) { if (0 === t && e) return this.split(e).left; if (1 === e) return this.split(t).right; const o = this.hull(t), n = { left: 2 === this.order ? new R([o[0], o[3], o[5]]) : new R([o[0], o[4], o[7], o[9]]), right: 2 === this.order ? new R([o[5], o[4], o[2]]) : new R([o[9], o[8], o[6], o[3]]), span: o }; return n.left._t1 = S.map(0, 0, 1, this._t1, this._t2), n.left._t2 = S.map(t, 0, 1, this._t1, this._t2), n.right._t1 = S.map(t, 0, 1, this._t1, this._t2), n.right._t2 = S.map(1, 0, 1, this._t1, this._t2), e ? (e = S.map(e, t, 1, 0, 1), n.right.split(e).left) : n } extrema() { const t = {}; let e = []; return this.dims.forEach(function (o) { let n = function (t) { return t[o] }, i = this.dpoints[0].map(n); t[o] = S.droots(i), 3 === this.order && (i = this.dpoints[1].map(n), t[o] = t[o].concat(S.droots(i))), t[o] = t[o].filter((function (t) { return t >= 0 && t <= 1 })), e = e.concat(t[o].sort(S.numberSort)) }.bind(this)), t.values = e.sort(S.numberSort).filter((function (t, o) { return e.indexOf(t) === o })), t } bbox() { const t = this.extrema(), e = {}; return this.dims.forEach(function (o) { e[o] = S.getminmax(this, o, t[o]) }.bind(this)), e } overlaps(t) { const e = this.bbox(), o = t.bbox(); return S.bboxoverlap(e, o) } offset(t, e) { if (void 0 !== e) { const o = this.get(t), n = this.normal(t), i = { c: o, n, x: o.x + n.x * e, y: o.y + n.y * e }; return this._3d && (i.z = o.z + n.z * e), i } if (this._linear) { const e = this.normal(0), o = this.points.map((function (o) { const n = { x: o.x + t * e.x, y: o.y + t * e.y }; return o.z && e.z && (n.z = o.z + t * e.z), n })); return [new R(o)] } return this.reduce().map((function (e) { return e._linear ? e.offset(t)[0] : e.scale(t) })) } simple() { if (3 === this.order) { const t = S.angle(this.points[0], this.points[3], this.points[1]), e = S.angle(this.points[0], this.points[3], this.points[2]); if (t > 0 && e < 0 || t < 0 && e > 0) return !1 } const t = this.normal(0), e = this.normal(1); let o = t.x * e.x + t.y * e.y; return this._3d && (o += t.z * e.z), C(M(o)) < I / 3 } reduce() { let t, e, o = 0, n = 0, i = .01, r = [], s = [], a = this.extrema().values; for (-1 === a.indexOf(0) && (a = [0].concat(a)), -1 === a.indexOf(1) && a.push(1), o = a[0], t = 1; t < a.length; t++)n = a[t], e = this.split(o, n), e._t1 = o, e._t2 = n, r.push(e), o = n; return r.forEach((function (t) { for (o = 0, n = 0; n <= 1;)for (n = o + i; n <= 1.01; n += i)if (e = t.split(o, n), !e.simple()) { if (n -= i, C(o - n) < i) return []; e = t.split(o, n), e._t1 = S.map(o, 0, 1, t._t1, t._t2), e._t2 = S.map(n, 0, 1, t._t1, t._t2), s.push(e), o = n; break } o < 1 && (e = t.split(o, 1), e._t1 = S.map(o, 0, 1, t._t1, t._t2), e._t2 = t._t2, s.push(e)) })), s } translate(t, e, o) { o = "number" == typeof o ? o : e; const n = this.order; let i = this.points.map(((t, i) => (1 - i / n) * e + i / n * o)); return new R(this.points.map(((e, o) => ({ x: e.x + t.x * i[o], y: e.y + t.y * i[o] })))) } scale(t) { const e = this.order; let o = !1; if ("function" == typeof t && (o = t), o && 2 === e) return this.raise().scale(o); const n = this.clockwise, i = this.points; if (this._linear) return this.translate(this.normal(0), o ? o(0) : t, o ? o(1) : t); const r = o ? o(0) : t, s = o ? o(1) : t, a = [this.offset(0, 10), this.offset(1, 10)], l = [], c = S.lli4(a[0], a[0].c, a[1], a[1].c); if (!c) throw new Error("cannot scale this curve. Try reducing it first."); return [0, 1].forEach((function (t) { const o = l[t * e] = S.copy(i[t * e]); o.x += (t ? s : r) * a[t].n.x, o.y += (t ? s : r) * a[t].n.y })), o ? ([0, 1].forEach((function (r) { if (2 !== e || !r) { var s = i[r + 1], a = { x: s.x - c.x, y: s.y - c.y }, d = o ? o((r + 1) / e) : t; o && !n && (d = -d); var h = _(a.x * a.x + a.y * a.y); a.x /= h, a.y /= h, l[r + 1] = { x: s.x + d * a.x, y: s.y + d * a.y } } })), new R(l)) : ([0, 1].forEach((t => { if (2 === e && t) return; const o = l[t * e], n = this.derivative(t), r = { x: o.x + n.x, y: o.y + n.y }; l[t + 1] = S.lli4(o, r, c, i[t + 1]) })), new R(l)) } outline(t, e, o, n) { if (e = void 0 === e ? t : e, this._linear) { const i = this.normal(0), r = this.points[0], s = this.points[this.points.length - 1]; let a, l, c; void 0 === o && (o = t, n = e), a = { x: r.x + i.x * t, y: r.y + i.y * t }, c = { x: s.x + i.x * o, y: s.y + i.y * o }, l = { x: (a.x + c.x) / 2, y: (a.y + c.y) / 2 }; const d = [a, l, c]; a = { x: r.x - i.x * e, y: r.y - i.y * e }, c = { x: s.x - i.x * n, y: s.y - i.y * n }, l = { x: (a.x + c.x) / 2, y: (a.y + c.y) / 2 }; const h = [c, l, a], u = S.makeline(h[2], d[0]), p = S.makeline(d[2], h[0]), f = [u, new R(d), p, new R(h)]; return new T(f) } const i = this.reduce(), r = i.length, s = []; let a, l = [], c = 0, d = this.length(); const h = void 0 !== o && void 0 !== n; function u(t, e, o, n, i) { return function (r) { const s = n / o, a = (n + i) / o, l = e - t; return S.map(r, 0, 1, t + s * l, t + a * l) } } i.forEach((function (i) { const r = i.length(); h ? (s.push(i.scale(u(t, o, d, c, r))), l.push(i.scale(u(-e, -n, d, c, r)))) : (s.push(i.scale(t)), l.push(i.scale(-e))), c += r })), l = l.map((function (t) { return a = t.points, a[3] ? t.points = [a[3], a[2], a[1], a[0]] : t.points = [a[2], a[1], a[0]], t })).reverse(); const p = s[0].points[0], f = s[r - 1].points[s[r - 1].points.length - 1], m = l[r - 1].points[l[r - 1].points.length - 1], g = l[0].points[0], b = S.makeline(m, p), y = S.makeline(f, g), v = [b].concat(s).concat([y]).concat(l); return new T(v) } outlineshapes(t, e, o) { e = e || t; const n = this.outline(t, e).curves, i = []; for (let t = 1, e = n.length; t < e / 2; t++) { const r = S.makeshape(n[t], n[e - t], o); r.startcap.virtual = t > 1, r.endcap.virtual = t < e / 2 - 1, i.push(r) } return i } intersects(t, e) { return t ? t.p1 && t.p2 ? this.lineIntersects(t) : (t instanceof R && (t = t.reduce()), this.curveintersects(this.reduce(), t, e)) : this.selfintersects(e) } lineIntersects(t) { const e = P(t.p1.x, t.p2.x), o = P(t.p1.y, t.p2.y), n = k(t.p1.x, t.p2.x), i = k(t.p1.y, t.p2.y); return S.roots(this.points, t).filter((t => { var r = this.get(t); return S.between(r.x, e, n) && S.between(r.y, o, i) })) } selfintersects(t) { const e = this.reduce(), o = e.length - 2, n = []; for (let i, r, s, a = 0; a < o; a++)r = e.slice(a, a + 1), s = e.slice(a + 2), i = this.curveintersects(r, s, t), n.push(...i); return n } curveintersects(t, e, o) { const n = []; t.forEach((function (t) { e.forEach((function (e) { t.overlaps(e) && n.push({ left: t, right: e }) })) })); let i = []; return n.forEach((function (t) { const e = S.pairiteration(t.left, t.right, o); e.length > 0 && (i = i.concat(e)) })), i } arcs(t) { return t = t || .5, this._iterate(t, []) } _error(t, e, o, n) { const i = (n - o) / 4, r = this.get(o + i), s = this.get(n - i), a = S.dist(t, e), l = S.dist(t, r), c = S.dist(t, s); return C(l - a) + C(c - a) } _iterate(t, e) { let o, n = 0, i = 1; do { o = 0, i = 1; let r, s, a, l, c, d = this.get(n), h = !1, u = !1, p = i, f = 1, m = 0; do { if (u = h, l = a, p = (n + i) / 2, m++, r = this.get(p), s = this.get(i), a = S.getccenter(d, r, s), a.interval = { start: n, end: i }, h = this._error(a, d, n, i) <= t, c = u && !h, c || (f = i), h) { if (i >= 1) { if (a.interval.end = f = 1, l = a, i > 1) { let t = { x: a.x + a.r * E(a.e), y: a.y + a.r * z(a.e) }; a.e += S.angle({ x: a.x, y: a.y }, t, this.get(1)) } break } i += (i - n) / 2 } else i = p } while (!c && o++ < 100); if (o >= 100) break; l = l || a, e.push(l), n = f } while (i < 1); return e } }; e.exports = s(a) }
    }, o = {}; function n(t) { var i = o[t]; if (void 0 !== i) return i.exports; var r = o[t] = { id: t, exports: {} }; return e[t].call(r.exports, r, r.exports, n), r.exports } n.n = t => { var e = t && t.__esModule ? () => t.default : () => t; return n.d(e, { a: e }), e }, n.d = (t, e) => { for (var o in e) n.o(e, o) && !n.o(t, o) && Object.defineProperty(t, o, { enumerable: !0, get: e[o] }) }, n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), n.nc = void 0; var i = n(2728); window.jsdraw = i
})();
